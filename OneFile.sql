CREATE TABLE public."DatabaseVersionHistory" 
(
	"DatabaseVersionId" VARCHAR(150) PRIMARY KEY,
	"InsertionDateTime" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO public."DatabaseVersionHistory" VALUES ('000_DW_DatabaseVersionHistory_Create_Scripts');CREATE SCHEMA ct;
CREATE TABLE ct."LoadStream"
(
    "StreamId" BIGSERIAL PRIMARY KEY NOT NULL,
    "FromSyncDateUTC" TIMESTAMP NOT NULL,
	"ToSyncDateUTC" TIMESTAMP NOT NULL,
    "ProcessStartDateTime" TIMESTAMP NULL,
    "ProcessEndDateTime" TIMESTAMP,
    "Status" VARCHAR(10)
);

CREATE TABLE ct."LoadCycle"
(
    "LoadCycleId" BIGSERIAL PRIMARY KEY NOT NULL,
	"EnvCode" VARCHAR(50) NOT NULL,
    "SourceSchema" VARCHAR(30) NOT NULL,
    "DestinationSchema" VARCHAR(30) NOT NULL,
	"LoadType" VARCHAR(30) NOT NULL,
    "StartingDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Status" VARCHAR(10),
    "StreamId" BIGINT NOT NULL
);
ALTER TABLE ct."LoadCycle" ADD CONSTRAINT FK_LoadCycle_LoadStream FOREIGN KEY ("StreamId") REFERENCES ct."LoadStream" ("StreamId");

CREATE TABLE ct."Audit"
(
    "AuditKey" BIGSERIAL PRIMARY KEY NOT NULL,
    "ParentAuditKey" BIGINT,
    "TableName" VARCHAR(50) NOT NULL,
    "JobName" VARCHAR(50) NOT NULL,
    "ExecutionStartDateTime" TIMESTAMP NOT NULL,
    "ExecutionStopDateTime" TIMESTAMP,
    "ExtractRowCount" INT,
    "InsertRowCount" INT,
    "UpdateRowCount" INT,
    "ErrorRowCount" INT,
    "TableInitialRow" INT,
    "TableFinalRow" INT,
    "ProcessingStatus" INT,
    "LoadCycleId" BIGINT NOT NULL
);
ALTER TABLE ct."Audit" ADD CONSTRAINT FK_Audit_LoadCycle FOREIGN KEY ("LoadCycleId") REFERENCES ct."LoadCycle" ("LoadCycleId");

INSERT INTO public."DatabaseVersionHistory" VALUES ('001_DW_ControlTables_Create_Scripts');--CREATE DBLINK EXTENSION
CREATE EXTENSION dblink;

CREATE SCHEMA dw;
-- DimWeatherStation
CREATE TABLE dw."DimWeatherStation"
(
    "StationKey" SERIAL PRIMARY KEY NOT NULL,
    "StationAlternateKey" INT NOT NULL,
    "Name" VARCHAR(5) NOT NULL
);
COMMENT ON TABLE dw."DimWeatherStation" IS 'Weather Station Dimension';
CREATE UNIQUE INDEX DimWeatherStation_StationAlternateKey_index ON dw."DimWeatherStation" ("StationAlternateKey");
CREATE INDEX DimWeatherStation_StationAlternateKey_Name_index ON dw."DimWeatherStation" ("StationAlternateKey","Name");


-- DimLocation
CREATE TABLE dw."DimLocation"
(
    "LocationKey" SERIAL PRIMARY KEY NOT NULL,
    "LocationAlternateKey" INT NOT NULL,
    "City" VARCHAR(100) NOT NULL,
    "StateProvinceAbbr" VARCHAR(3) NOT NULL,
    "StateProvinceName" VARCHAR(30) NOT NULL,
    "CountryAbbr" VARCHAR(3) NOT NULL,
    "EnglishCountryName" VARCHAR(30) NOT NULL,
    "SpanishCountryName" VARCHAR(30) NOT NULL
);
COMMENT ON TABLE dw."DimLocation" IS 'Location Dimension';
CREATE UNIQUE INDEX DimLocation_LocationAlternateKey_index ON dw."DimLocation" ("LocationAlternateKey");
CREATE INDEX DimLocation_LocationAlternateKey_City_index ON dw."DimLocation" ("LocationAlternateKey","City");


-- DimISO
CREATE TABLE dw."DimISO"
(
    "ISOKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "ISOAlternateKey" SMALLINT NOT NULL,
    "ISOName" VARCHAR(20) NOT NULL,
    "ISOEnglishDescription" VARCHAR(50) NOT NULL,
    "ISOSpanishDescription" VARCHAR(50) NOT NULL,
    "ISODefaultFormat" VARCHAR(20) NOT NULL
);
COMMENT ON TABLE dw."DimISO" IS 'Independant System Operation Dimension';
CREATE UNIQUE INDEX DimISO_ISOAlternateKey_index ON dw."DimISO" ("ISOAlternateKey");
CREATE INDEX DimISO_ISOAlternateKey_ISOName_index ON dw."DimISO" ("ISOAlternateKey","ISOName");

--DimControlArea
CREATE TABLE dw."DimControlArea"
(
    "ControlAreaKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "ControlAreaAlternateKey" INT NOT NULL,
    "Name" VARCHAR(50) NOT NULL,
    "Abbreviation" VARCHAR(5) NOT NULL,
    "Duns" VARCHAR(100),
	"ISOKey" SMALLINT
);
COMMENT ON TABLE dw."DimControlArea" IS 'Control Area Dimension';
ALTER TABLE dw."DimControlArea" ADD CONSTRAINT FK_ControlArea_ISO FOREIGN KEY ("ISOKey") REFERENCES dw."DimISO" ("ISOKey");
CREATE UNIQUE INDEX DimControlArea_ControlAreaAlternateKey_index ON dw."DimControlArea" ("ControlAreaAlternateKey");
CREATE INDEX DimControlArea_ControlAreaAlternateKey_Name_index ON dw."DimControlArea" ("ControlAreaAlternateKey","Name");


-- DimClient
CREATE TABLE dw."DimClient"
(
    "ClientKey" SERIAL PRIMARY KEY NOT NULL,
    "ClientAlternateKey" INT,
    "ClientName" VARCHAR(50) NOT NULL,
    "LogoFileName" VARCHAR(100),
    "LogoFileBinaryContent" BYTEA,
    "ClientUrl" VARCHAR(255),
    "MonthsToRetain" SMALLINT NOT NULL,
	"Duns" VARCHAR (13),
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimClient" IS 'Client Dimension';
CREATE UNIQUE INDEX DimClient_ClientAlternateKey_index ON dw."DimClient" ("ClientAlternateKey"); -- TEMPORARY INDEX
CREATE INDEX DimClient_ClientAlternateKey_ClientName_Current_index ON dw."DimClient" ("ClientAlternateKey","ClientName","Current");


--DimCustomer
CREATE TABLE dw."DimCustomer"
(
    "CustomerKey" SERIAL PRIMARY KEY NOT NULL,
    "CustomerAlternateKey" VARCHAR(256) NOT NULL,
	"ApplicationCode" varchar(4) NOT NULL,
    "Name" VARCHAR(256),
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimCustomer" IS 'Customer Dimension';
CREATE UNIQUE INDEX DimCustomer_CustomerAlternateKey_ApplicationCode_index ON dw."DimCustomer" ("CustomerAlternateKey","ApplicationCode"); -- TEMPORARY INDEX
CREATE INDEX DimCustomer_CustomerAlternateKey_Name_Current_index ON dw."DimCustomer" ("CustomerAlternateKey","Name","Current");

--DimAccount
CREATE TABLE dw."DimAccount"
(
    "AccountKey" SERIAL PRIMARY KEY NOT NULL,
    "AccountAlternateKey" INTEGER NOT NULL,
	"ApplicationCode" varchar(4),
    "AccountNumber" VARCHAR(50),
    "PremiseNumber" VARCHAR(5),
	"TimeZoneKey" integer,
	"ClientAccountKey" character varying(100),
	"ClientKey" INT,
	"CustomerKey" INT NULL,
	"ControlAreaKey" SMALLINT,
	"StartActiveDateTimeUTC"   TIMESTAMP,
	"EndActiveDateTimeUTC"     TIMESTAMP,
	"StartActiveDateTimeLocal" TIMESTAMP,
	"EndActiveDateTimeLocal"   TIMESTAMP,
    "StartDateTime"            TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimAccount" IS 'Account Information Dimension';
CREATE INDEX DimAccount_AccountAlternateKey_ApplicationCode_AccountNumber_CustomerKey_ClientKey_ControlArea_index ON dw."DimAccount" ("AccountAlternateKey","ApplicationCode","AccountNumber","CustomerKey","ClientKey","ControlAreaKey","Current");
ALTER TABLE dw."DimAccount" ADD CONSTRAINT FK_Account_Client FOREIGN KEY ("ClientKey") REFERENCES dw."DimClient" ("ClientKey");
ALTER TABLE dw."DimAccount" ADD CONSTRAINT FK_Account_Customer FOREIGN KEY ("CustomerKey") REFERENCES dw."DimCustomer" ("CustomerKey");
ALTER TABLE dw."DimAccount" ADD CONSTRAINT FK_Account_ControlArea FOREIGN KEY ("ControlAreaKey") REFERENCES dw."DimControlArea" ("ControlAreaKey");

-- DimCurrency
CREATE TABLE dw."DimPriceCurrency"
(
    "CurrencyKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "CurrencyCode" VARCHAR(3) NOT NULL,
    "EnglishCurrencyName" VARCHAR(50) NOT NULL,
    "SpanishCurrencyName" VARCHAR(50) NOT NULL
);
COMMENT ON TABLE dw."DimPriceCurrency" IS 'Currency Dimension';
CREATE UNIQUE INDEX DimPriceCurrency_CurrencyCode_index ON dw."DimPriceCurrency" ("CurrencyCode");


-- DimOriginFactValue
CREATE TABLE dw."DimOriginFactValue"
(
    "OriginConsumptionKey" SMALLINT PRIMARY KEY NOT NULL,
	"Code" VARCHAR(8) NOT NULL,
    "OriginValueEnglishDescription" VARCHAR(20) NOT NULL,
    "OriginValueSpanishDescription" VARCHAR(20) NOT NULL
);
COMMENT ON TABLE dw."DimOriginFactValue" IS 'Is Fact Consumption Value Calculated, Estimated or Real ?';

-- DimFactValueGoal
CREATE TABLE dw."DimFactValueGoal"
(
    "FactValueGoalKey" SMALLINT PRIMARY KEY NOT NULL,
	"Code" VARCHAR(8) NOT NULL,
    "FactValueGoalEnglishDescription" VARCHAR(20) NOT NULL,
    "FactValueGoalSpanishDescription" VARCHAR(20) NOT NULL
);
COMMENT ON TABLE dw."DimFactValueGoal" IS 'Is Fact Consumption Value Initial, New Value or Correction ?';

--DimTimeZone
CREATE TABLE dw."DimTimeZone"
(
    "TimeZoneKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "TimeZoneAlternateKey" SMALLINT NOT NULL,
    "Abbreviation" VARCHAR(5) NOT NULL,
    "EnglishName" VARCHAR(50) NOT NULL,
    "SpanishName" VARCHAR(50) NOT NULL,
    "OffsetToGMT" INT NOT NULL
);
COMMENT ON TABLE dw."DimTimeZone" IS 'Time Zone Dimension';
CREATE UNIQUE INDEX DimTimeZone_TimeZoneAlternateKey_index ON dw."DimTimeZone" ("TimeZoneAlternateKey");
CREATE INDEX DimTimeZone_TimeZoneAlternateKey_Abbreviation_EnglishName_index ON dw."DimTimeZone" ("TimeZoneAlternateKey","Abbreviation","EnglishName");


-- DimEnergyPowerType
CREATE TABLE dw."DimEnergyPowerType"
(
    "EnergyPowerTypeKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "EnergyPowerTypeAlternateKey" SMALLINT NOT NULL,
    "EnglishEnergyPowerTypeDescription" VARCHAR(20) NOT NULL,
    "SpanishPowerTypeDescription" VARCHAR(20) NOT NULL
);
COMMENT ON TABLE dw."DimEnergyPowerType" IS 'Power Type Classification Dimension';
CREATE UNIQUE INDEX DimEnergyPowerType_EnergyPowerTypeAlternateKey_index ON dw."DimEnergyPowerType" ("EnergyPowerTypeAlternateKey");
CREATE INDEX DimEnergyPowerType_EnergyPowerTypeAlternateKey_EnglishDescription_index ON dw."DimEnergyPowerType" ("EnergyPowerTypeAlternateKey","EnglishEnergyPowerTypeDescription");

-- DimDate
CREATE TABLE dw."DimDate"
(
    "DateKey" INT PRIMARY KEY NOT NULL,
    "FullAlternateDateKey" DATE NOT NULL,
	"FullAlternateDateTimeStamp" TIMESTAMP NOT NULL,
    "DayNumberOfWeek" SMALLINT NOT NULL,
    "EnglishDayNameOfWeek" VARCHAR(10) NOT NULL,
    "SpanishDayNameOfWeek" VARCHAR(10) NOT NULL,
    "DayNumberOfMonth" SMALLINT NOT NULL,
    "DayNumberOfYear" SMALLINT NOT NULL,
    "WeekNumberOfYear" SMALLINT NOT NULL,
    "EnglishMonthName" VARCHAR(10) NOT NULL,
    "SpanishMonthName" VARCHAR(10) NOT NULL,
    "MonthNumberOfYear" SMALLINT NOT NULL,
    "CalendarQuarter" SMALLINT NOT NULL,
    "CalendarYear" SMALLINT NOT NULL,
    "CalendarSemester" SMALLINT NOT NULL,
    "DateStyle101" VARCHAR(10) NOT NULL,
    "DateStyle103" VARCHAR(10) NOT NULL
);
COMMENT ON TABLE dw."DimDate" IS 'Date Dimension';
CREATE UNIQUE INDEX DimDate_FullDateAlternateKey_uindex ON dw."DimDate" ("FullAlternateDateKey","FullAlternateDateTimeStamp");

-- DimTime
CREATE TABLE dw."DimTime"
(
    "TimeKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "TimeAlternateKey" VARCHAR(5) NOT NULL,
    "12_hr" SMALLINT NOT NULL,
    "24_hr" SMALLINT NOT NULL,
    "am_pm" VARCHAR(2) NOT NULL,
    "MinuteInHour" SMALLINT NOT NULL,
    "Time05Min" SMALLINT NOT NULL,
    "Time10Min" SMALLINT NOT NULL,
    "Time15Min" SMALLINT NOT NULL,
    "Time30Min" SMALLINT NOT NULL,
    "Time60Min" SMALLINT NOT NULL,
    "TimeValue" VARCHAR(10) NOT NULL
);
COMMENT ON TABLE dw."DimTime" IS 'Time Dimension';
CREATE UNIQUE INDEX DimTime_TimeAlternateKey_TimeValue_uindex ON dw."DimTime" ("TimeAlternateKey","TimeValue");


-- DimMeter
CREATE TABLE dw."DimMeter"
(
    "MeterKey" SERIAL PRIMARY KEY NOT NULL,
    "MeterAlternateKey" VARCHAR(50) NOT NULL,
    "ApplicationCode" varchar(4) NOT NULL,
    "Name" VARCHAR(50) NOT NULL,
    "IntervalsPerHour" SMALLINT NOT NULL,
    "IsDSTEnabled" boolean NOT NULL,
    "IsVirtual" boolean NOT NULL,
    "MeterType" VARCHAR(50) NULL,
    "Manufacturer" VARCHAR(50) NULL,
    "TimeZoneKey" SMALLINT NULL,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimMeter" IS 'Meter, MeterType and MeterManufacturer Dimension';
CREATE INDEX DimMeter_MeterAlternateKey_Name_Current_index ON dw."DimMeter" ("MeterAlternateKey","Name","Current");
ALTER TABLE dw."DimMeter" ADD CONSTRAINT FK_Meter_TimeZone FOREIGN KEY ("TimeZoneKey") REFERENCES dw."DimTimeZone" ("TimeZoneKey");

-- DimSDP
CREATE TABLE dw."DimSDP"
(
    "SDPKey" SERIAL PRIMARY KEY NOT NULL,
    "SDPAlternateKey" INT NOT NULL,
    "Address" VARCHAR(250),
    "Address1" VARCHAR(250),
    "PostalCode" VARCHAR(9),
    "Longitude" DECIMAL(9,6),
    "Latitude" DECIMAL(9,6),
    "Name" VARCHAR(50),
    "IsVirtual" boolean NOT NULL,
    "LoadReductionPriceCode" VARCHAR(20),
    "CustomerBaseLineAdjLoadReduction" DECIMAL(18,2),
    "CustomerBaseLineAdjType" VARCHAR(1),
    "LocationKey" INT ,
    "StationKey" INT ,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimSDP" IS 'SDP Information Dimension';
CREATE UNIQUE INDEX DimSDP_SDPAlternateKey_index ON dw."DimSDP" ("SDPAlternateKey"); --TEMPORARY INDEX
CREATE INDEX DimSDP_SDPAlternateKey_Name_Current_index ON dw."DimSDP" ("SDPAlternateKey","Name","Current");

ALTER TABLE dw."DimSDP" ADD CONSTRAINT FK_SDP_Location FOREIGN KEY ("LocationKey") REFERENCES dw."DimLocation" ("LocationKey");
ALTER TABLE dw."DimSDP" ADD CONSTRAINT FK_SDP_WeatherStation FOREIGN KEY ("StationKey") REFERENCES dw."DimWeatherStation" ("StationKey");

-- DimUOM
CREATE TABLE dw."DimUOM"
(
    "UomKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "UomAlternateKey" SMALLINT NOT NULL,
    "EnglishDescription" VARCHAR(20) NOT NULL,
    "SpanishDescription" VARCHAR(20) NOT NULL,
    "Code" VARCHAR(20) NOT NULL,
    "UomFromMV90" INT,
    "ConversionKey" SMALLINT,
    "EnglishUomTypeDescription" VARCHAR(20) NOT NULL,
    "SpanishUomTypeDescription" VARCHAR(20) NOT NULL,
    "EnergyPowerTypeKey" SMALLINT,
	"EDI867Code" VARCHAR (200)
);
COMMENT ON TABLE dw."DimUOM" IS 'Unit Of Measurement and Uom Type  Dimension';
CREATE UNIQUE INDEX DimUOM_UomAlternateKey_index ON dw."DimUOM" ("UomAlternateKey");
CREATE INDEX DimUOM_UomAlternateKey_EnglishDescription_index ON dw."DimUOM" ("UomAlternateKey","EnglishDescription");
ALTER TABLE dw."DimUOM" ADD CONSTRAINT FK_UOM_EnergyPowerType FOREIGN KEY ("EnergyPowerTypeKey") REFERENCES dw."DimEnergyPowerType"("EnergyPowerTypeKey");


-- DimPowerFctConfig
CREATE TABLE dw."DimPowerFctConfig"
(
    "PowerFctConfigKey" SERIAL PRIMARY KEY NOT NULL,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP
);
COMMENT ON TABLE dw."DimPowerFctConfig" IS 'Power Factor Configuration Dimension';

-- DimChannel
CREATE TABLE dw."DimChannel"
(
    "ChannelKey" SERIAL PRIMARY KEY NOT NULL,
    "ChannelAlternateKey" INT NOT NULL,
    "ChannelNumber" SMALLINT NOT NULL,
    "SetNumber" SMALLINT,
    "NumberOfDials" SMALLINT NOT NULL,
    "MeterMultiplier" DECIMAL(12,5) NOT NULL,
    "PulseMultiplier" DECIMAL(12,5) NOT NULL,
    "PulseOffset" DECIMAL(12,5) NOT NULL,
    "BillingMultiplier" DECIMAL(12,5) NOT NULL,
    "EnglishChannelTypeDescription" VARCHAR(20) NOT NULL,
    "SpanishChannelTypeDescription" VARCHAR(20) NOT NULL,
    "IntervalsPerHour" SMALLINT NOT NULL,
    "IsDelivered" boolean,
    "IsVirtual" boolean NOT NULL,
    "UomKey" SMALLINT NOT NULL,
	"PowerFctConfigKey" INT,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimChannel" IS 'Channel and Channel Type Dimension';
CREATE UNIQUE INDEX DimChannel_ChannelAlternateKey_index ON dw."DimChannel" ("ChannelAlternateKey"); -- TEMPORARY INDEX
CREATE INDEX DimChannel_ChannelAlternateKey_ChannelNumber_Current_index ON dw."DimChannel" ("ChannelAlternateKey","ChannelNumber","Current");
ALTER TABLE dw."DimChannel" ADD CONSTRAINT FK_Channel_UOM FOREIGN KEY ("UomKey") REFERENCES dw."DimUOM"("UomKey");
ALTER TABLE dw."DimChannel" ADD CONSTRAINT FK_Channel_PowerFctConfig   FOREIGN KEY ("PowerFctConfigKey") REFERENCES dw."DimPowerFctConfig"("PowerFctConfigKey");


-- DimServiceType
CREATE TABLE dw."DimServiceType"
(
    "ServiceTypeKey" SMALLINT PRIMARY KEY NOT NULL,
	"Code" VARCHAR(8) NOT NULL,
    "Description" VARCHAR(50) NOT NULL
);
COMMENT ON TABLE dw."DimServiceType" IS 'Is Service OMDA or Settlement ?';



-- DimFactStatus
CREATE TABLE dw."DimFactStatus"
(
    "FactStatusKey" SMALLINT PRIMARY KEY NOT NULL,
	"Code" VARCHAR(8) NOT NULL,
    "EnglishFactStatusDescription" VARCHAR(20) NOT NULL,
    "SpanishFactStatusDescription" VARCHAR(20) NOT NULL
);
COMMENT ON TABLE dw."DimFactStatus" IS 'Is Fact Current or Old ?';

INSERT INTO public."DatabaseVersionHistory" VALUES ('002_DW_Dimensions_Create_Scripts');-- FactIntervals
CREATE TABLE dw."FactIntervals"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
    "MontlhyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,	
    "UsageDLF" NUMERIC(28,4),	
    "Demand" NUMERIC(28,4) ,    
    "DemandDLF" NUMERIC(28,4) ,    
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
    "DLP" NUMERIC(18,6),	
    "DLPSum" NUMERIC(18,6),
    "DLPRation" NUMERIC(18,6),	
    "DLF" NUMERIC(18,7),
    "Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
    "MarginalUsage" NUMERIC(28,4),
    "MarginalCost" NUMERIC(28,4),
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
    "StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
    "AccountKey" INT,
    "SDPKey" INT ,
    "MeterKey" INT,
    "ChannelKey" INT,
    "CurrencyKey" SMALLINT,
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
    "ServiceTypeKey" SMALLINT,
    "ParentIntervalKey" BIGINT,
    "FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
    "RecordedDateUTCKey" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactIntervals" IS 'Intervals Fact Table';

--2015
CREATE TABLE dw.intervals_y2015m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m07 ("StartDateTimeUTC", "EndDateTimeUTC");


CREATE TABLE dw.intervals_y2015m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m12 ("StartDateTimeUTC", "EndDateTimeUTC");


--2016
CREATE TABLE dw.intervals_y2016m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m12 ("StartDateTimeUTC", "EndDateTimeUTC");

--2017
CREATE TABLE dw.intervals_y2017m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m12 ("StartDateTimeUTC", "EndDateTimeUTC");

--2018
CREATE TABLE dw.intervals_y2018m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m12 ("StartDateTimeUTC", "EndDateTimeUTC");

--2019
CREATE TABLE dw.intervals_y2019m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m12 ("StartDateTimeUTC", "EndDateTimeUTC");

INSERT INTO public."DatabaseVersionHistory" VALUES ('003_DW_FactIntervals_Create_Scripts');-- FactWeather
CREATE TABLE dw."FactWeather"
(
    "WeatherKey" BIGSERIAL,
    "InsertionDateTime" TIMESTAMP,
    "TimeZoneKey" SMALLINT,
    "StationKey" INT,
	"EndDateTimeLocal" TIMESTAMP ,
	"EndDateTimeUTC" TIMESTAMP ,
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
    "oC" INT,
    "oF" INT,
    "Humidity" INT
)PARTITION BY RANGE ("EndDateLocalKey");
COMMENT ON TABLE dw."FactWeather" IS 'Weather Fact Table';


--2015
CREATE TABLE dw.weather_y2015m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.weather_y2015m06 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2015m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.weather_y2015m07 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");


CREATE TABLE dw.weather_y2015m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.weather_y2015m08 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2015m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.weather_y2015m09 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2015m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.weather_y2015m10 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2015m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.weather_y2015m11 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2015m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.weather_y2015m12 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");


--2016
CREATE TABLE dw.weather_y2016m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.weather_y2016m01 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.weather_y2016m02 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.weather_y2016m03 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.weather_y2016m04 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.weather_y2016m05 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.weather_y2016m06 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.weather_y2016m07 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.weather_y2016m08 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.weather_y2016m09 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.weather_y2016m10 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.weather_y2016m11 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.weather_y2016m12 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

--2017
CREATE TABLE dw.weather_y2017m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.weather_y2017m01 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.weather_y2017m02 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.weather_y2017m03 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.weather_y2017m04 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.weather_y2017m05 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.weather_y2017m06 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.weather_y2017m07 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.weather_y2017m08 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.weather_y2017m09 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.weather_y2017m10 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.weather_y2017m11 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.weather_y2017m12 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

--2018
CREATE TABLE dw.weather_y2018m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.weather_y2018m01 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.weather_y2018m02 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.weather_y2018m03 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.weather_y2018m04 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.weather_y2018m05 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.weather_y2018m06 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.weather_y2018m07 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.weather_y2018m08 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.weather_y2018m09 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.weather_y2018m10 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.weather_y2018m11 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.weather_y2018m12 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

--2019
CREATE TABLE dw.weather_y2019m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.weather_y2019m01 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.weather_y2019m02 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.weather_y2019m03 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.weather_y2019m04 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.weather_y2019m05 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.weather_y2019m06 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.weather_y2019m07 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.weather_y2019m08 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.weather_y2019m09 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.weather_y2019m10 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.weather_y2019m11 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.weather_y2019m12 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

INSERT INTO public."DatabaseVersionHistory" VALUES ('004_DW_FactWeather_Create_Scripts');CREATE SCHEMA stg;
-- Stg_Account
CREATE TABLE stg."Account"
(
    "AccountId" integer ,
    "CustomerId" integer,
	"CustomerName" character varying(256),
    "ClientId" integer,
    "AccountNumber" character varying(50),
    "PremiseNumber" character varying(5),
    "ControlAreaId" integer,
	"TimeZoneId" integer,
	"ClientAccountKey" character varying(100),
    "ApplicationCode" varchar(4),
	"StartActiveDateTimeUTC"   TIMESTAMP,
	"EndActiveDateTimeUTC"     TIMESTAMP,
	"StartActiveDateTimeLocal" TIMESTAMP,
	"EndActiveDateTimeLocal"   TIMESTAMP,
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."Account" IS 'Account Staging Table';


-- Stg_Channel
CREATE TABLE stg."Channel"
(
    "ChannelId" integer ,
    "ChannelNumber" integer,
    "UnitOfMeasureId" integer,
    "ChannelTypeId" integer,
    "RTPId" integer,
    "IntervalsPerHour" integer,
    "NumberOfDials" integer,
    "IsDelivered" boolean,
    "SetNumber" integer,
    "MeterMultiplier" numeric(12,5),
    "PulseMultiplier" numeric(12,5),
    "PulseOffset" numeric(12,5),
    "BillingMultiplier" numeric(12,5),
    "IsVirtual" boolean,
    "IsSum" boolean,
	"ChannelTypeDescription" character varying(20),
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."Channel" IS 'Channel Staging Table';

--Stg_Client
CREATE TABLE stg."Client"
(
    "ClientId" integer ,
    "Name" character varying(50) ,
    "LogoFileName" character varying(100) ,
    "ClientUrl" character varying(255) ,
    "IsUserSetupAllowed" boolean ,
    "MonthsToRetain" integer ,
    "ShowIntervalStatus" boolean ,
    "CustomThemeId" integer ,
    "Duns" text,
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."Client" IS 'Client Staging Table';


--Stg_ControlArea
CREATE TABLE stg."ControlArea"
(
    "ControlAreaId" integer ,
    "Name" character varying(50),
    "Abbreviation" character varying(5),
    "Duns" text,
    "StatusDateTime" timestamp without time zone,
    "StatusId" integer,
    "StatusWebUserId" integer,
    "IndSysOperatorId" integer
);
COMMENT ON TABLE stg."ControlArea" IS 'ControlArea Staging Table';

--Stg_Customer
CREATE TABLE stg."Customer"
(
    "CustomerId" integer,
    "Name" character varying(256),
	"ApplicationCode" varchar(4),
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."Customer" IS 'Customer Staging Table';


--Stg_EnergyPowerType
CREATE TABLE stg."EnergyPowerType"
(
    "EnergyPowerTypeId" integer,
    "Description" character varying(20)
);
COMMENT ON TABLE stg."EnergyPowerType" IS 'EnergyPowerType Staging Table';

--Stg_IndSysOperator
CREATE TABLE stg."IndSysOperator"
(
    "IndSysOperatorId" integer,
    "Name" character varying(50),
    "Description" text,
    "StatusDateTime" timestamp without time zone,
    "StatusId" integer,
    "StatusWebUserId" integer
);
COMMENT ON TABLE stg."IndSysOperator" IS 'IndSysOperator Staging Table';

--Stg_Meter
CREATE TABLE stg."Meter"
(
    "MeterId" integer,
    "MeterTypeId" integer,
    "Name" character varying(50),
    "DeviceCode" character varying(50),
    "IntervalsPerHour" integer,
    "IsDSTEnabled" boolean,
    "TimeZoneId" integer,
    "IsVirtual" boolean,
    "DSTRegionId" integer,
    "FirstEndDateTime" timestamp(0) with time zone,
    "LastEndDateTime" timestamp(0) with time zone,
	"Manufacturer" character varying(50),
	"Type" character varying(50),
	"ApplicationCode" varchar(4),
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."Meter" IS 'Meter Staging Table';

--Stg_ObservationStation
CREATE TABLE stg."ObservationStation"
(
    "ObservationStationId" integer,
    "Name" character varying(5)
);
COMMENT ON TABLE stg."ObservationStation" IS 'ObservationStation Staging Table';

--Stg_PowerFactorGroup
CREATE TABLE stg."PowerFactorGroup"
(
    "PowerFactorGroupId" integer,
    "ActiveUnitOfMeasureId" integer,
    "ReactiveUnitOfMeasureId" integer,
    "ApparentUnitOfMeasureId" integer,
    "QuadergyUnitOfMeasureId" integer
);
COMMENT ON TABLE stg."PowerFactorGroup" IS 'PowerFactorGroup Staging Table';

--Stg_SDP
CREATE TABLE stg."SDP"
(
    "SDPId" integer,
    "Name" character varying(50),
    "Address" character varying(250),
    "Address1" character varying(250),
    "CityId" integer,
    "PostalCode" character varying(9),
    "Longitude" numeric(9,6),
    "Latitude" numeric(9,6),
    "TimeZoneId" integer,
    "DSTRegionId" integer,
    "IsVirtual" boolean,
    "LoadReductionPriceCode" character varying(20),
    "CustomerBaseLineAdjustmentLoadReduction" numeric(18,2),
    "CustomerBaseLineAdjustmentType" character varying(1),
    "RtpId" integer,
    "ObservationStationId" integer,
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."SDP" IS 'SDP Staging Table';

--Stg_Location
CREATE TABLE stg."Location"
(
   "CityId" integer ,
   "CityName" character varying(100),
   "StateAbbreviation" character varying(3),
   "StateName" character varying(30),
   "CountryAbbreviation" character varying(3),
   "CountryName" character varying(30)
);
COMMENT ON TABLE stg."Location" IS 'Location Staging Table';

--Stg_TimeZone
CREATE TABLE stg."TimeZone"
(
    "TimeZoneId" integer,
    "OffsetToGMT" integer,
	"Abbreviation" character varying(5),
    "Name" character varying(50)
);
COMMENT ON TABLE stg."TimeZone" IS 'TimeZone Staging Table';

--Stg_UnitOfMeasure
CREATE TABLE stg."UnitOfMeasure"
(
    "UnitOfMeasureId" integer,
    "Code" character varying(20),
    "UnitOfMeasureTypeId" integer,
    "EnergyPowerTypeId" integer,
    "UomFromMV90" integer,
    "Description" character varying(20),
    "UnitOfMeasureConversionId" integer,
    "EDI867Code" text,
	"UomTypeDescription" character varying(20)
);
COMMENT ON TABLE stg."UnitOfMeasure" IS 'UnitOfMeasure Staging Table';




-- FactIntervals
CREATE TABLE stg."FactIntervals"
(
	"MontlhyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,
	"UsageDLF" NUMERIC(28,4),
    "Demand" NUMERIC(28,4) ,
	"DemandDLF" NUMERIC(28,4) ,
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
    "DLP" NUMERIC(18,6),
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),
    "DLF" NUMERIC(18,7),
	"Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
    "MarginalUsage" NUMERIC(28,4),
    "MarginalCost" NUMERIC(28,4),
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
	"ClientId" INT,
    "AccountId" INT,
    "SDPId" INT ,
    "DeviceCode" character varying(50),
    "ChannelId" INT,
    "CurrencyCode" VARCHAR(3),
	"OriginConsumptionCode" VARCHAR(8),
	"ApplicationCode" varchar(4),
    "EndDateLocal" TIMESTAMP,
    "EndTimeLocal" VARCHAR(10),
    "EndDateUTC" TIMESTAMP,
    "EndTimeUTC" VARCHAR(10),
	"RecordedDateUTC" TIMESTAMP
);
COMMENT ON TABLE stg."FactIntervals" IS 'Intervals Staging Fact Table';
CREATE INDEX ON stg."FactIntervals" ("EndDateTimeUTC", "ApplicationCode");


-- TEMPORARY TABLE USED DURING  MERGE OPERATION
CREATE TABLE public.meter_temp
(
    "MeterId" integer,
    "MeterTypeId" integer,
    "Name" character varying(50) COLLATE pg_catalog."default",
    "DeviceCode" character varying(50) COLLATE pg_catalog."default",
    "IntervalsPerHour" integer,
    "IsDSTEnabled" boolean,
    "TimeZoneId" integer,
    "InsertionTimeZoneKey" smallint,
    "IsVirtual" boolean,
    "DSTRegionId" integer,
    "FirstEndDateTime" timestamp(0) with time zone,
    "LastEndDateTime" timestamp(0) with time zone,
    "Manufacturer" character varying(50) COLLATE pg_catalog."default",
    "Type" character varying(50) COLLATE pg_catalog."default",
    "ApplicationCode" character varying(4) COLLATE pg_catalog."default",
    "StartDateTime" timestamp without time zone,
    "MeterKey" integer,
    "Current" boolean,
    "TimeZoneKey" smallint
);


CREATE TABLE public.account_temp
(
    "AccountId" integer,
    "CustomerId" integer,
    "CustomerName" character varying(256) COLLATE pg_catalog."default",
    "CustomerAlternateId" character varying COLLATE pg_catalog."default",
    "ClientId" integer,
    "InsertionClientKey" integer,
    "AccountNumber" character varying(50) COLLATE pg_catalog."default",
    "PremiseNumber" character varying(5) COLLATE pg_catalog."default",
    "ControlAreaId" integer,
    "InsertionControlAreaKey" smallint,
    "TimeZoneId" integer,
    "InsertionTimeZoneKey" smallint,
    "ClientAccountKey" character varying(100) COLLATE pg_catalog."default",
    "ApplicationCode" character varying(4) COLLATE pg_catalog."default",
    "StartActiveDateTimeUTC" timestamp without time zone,
    "EndActiveDateTimeUTC" timestamp without time zone,
    "StartActiveDateTimeLocal" timestamp without time zone,
    "EndActiveDateTimeLocal" timestamp without time zone,
    "StartDateTime" timestamp without time zone,
    "AccountKey" integer,
	"ClientKey" integer,
    "InsertionCustomerKey" integer
);

CREATE TABLE public.facts_temp
(
    "dw_IntervalKey" bigint,
    "dw_InsertionDateTime" timestamp without time zone,
    "dw_MontlhyRead" numeric(28,4),
    "dw_Usage" numeric(28,4),
    "dw_UsageDLF" numeric(28,4),
    "dw_Demand" numeric(28,4),
    "dw_DemandDLF" numeric(28,4),
    "dw_TCC" numeric(28,4),
    "dw_CBL" numeric(28,4),
    "dw_DLP" numeric(18,6),
    "dw_DLPSum" numeric(18,6),
    "dw_DLPRation" numeric(18,6),
    "dw_DLF" numeric(18,7),
    "dw_Price" numeric(28,4),
    "dw_PriceReduction" numeric(28,4),
    "dw_MarginalUsage" numeric(28,4),
    "dw_MarginalCost" numeric(28,4),
    "dw_StartDateTimeUTC" timestamp without time zone,
    "dw_EndDateTimeUTC" timestamp without time zone,
    "dw_StartDateTimeLocal" timestamp without time zone,
    "dw_EndDateTimeLocal" timestamp without time zone,
    "dw_AccountKey" integer,
    "dw_SDPKey" integer,
    "dw_MeterKey" integer,
    "dw_ChannelKey" integer,
    "dw_CurrencyKey" smallint,
    "dw_OriginConsumptionKey" smallint,
    "dw_FactValueGoalKey" smallint,
    "dw_ServiceTypeKey" smallint,
    "dw_ParentIntervalKey" bigint,
    "dw_FactStatusKey" smallint,
    "dw_EndDateLocalKey" integer,
    "dw_EndTimeLocalKey" smallint,
    "dw_EndDateUTCKey" integer,
    "dw_EndTimeUTCKey" smallint,
    "dw_RecordedDateUTCKey" integer,
    "dw_ClientKey" integer,
    "stg_MontlhyRead" numeric(28,4),
    "stg_Usage" numeric(28,4),
    "stg_UsageDLF" numeric(28,4),
    "stg_Demand" numeric(28,4),
    "stg_DemandDLF" numeric(28,4),
    "stg_TCC" numeric(28,4),
    "stg_CBL" numeric(28,4),
    "stg_DLP" numeric(18,6),
    "stg_DLPSum" numeric(18,6),
    "stg_DLPRation" numeric(18,6),
    "stg_DLF" numeric(18,7),
    "stg_Price" numeric(28,4),
    "stg_PriceReduction" numeric(28,4),
    "stg_MarginalUsage" numeric(28,4),
    "stg_MarginalCost" numeric(28,4),
    "stg_StartDateTimeUTC" timestamp without time zone,
    "stg_EndDateTimeUTC" timestamp without time zone,
    "stg_StartDateTimeLocal" timestamp without time zone,
    "stg_EndDateTimeLocal" timestamp without time zone,
    "stg_ClientKey" integer,
    "stg_AccountKey" integer,
    "stg_SDPKey" integer,
    "stg_MeterKey" integer,
    "stg_ChannelKey" integer,
    "stg_OriginConsumptionKey" smallint,
    "stg_OriginConsumptionCode" character varying(8) COLLATE pg_catalog."default",
    "stg_CurrencyKey" smallint,
    "stg_ServiceTypeKey" smallint,
    "stg_EndDateLocalKey" integer,
    "stg_EndDateUTCKey" integer,
    "stg_EndTimeLocalKey" smallint,
    "stg_EndTimeUTCKey" smallint,
    "stg_RecordedDateKey" integer
) ;
CREATE INDEX ON public.facts_temp ("stg_EndDateUTCKey","dw_IntervalKey");

INSERT INTO public."DatabaseVersionHistory" VALUES ('005_DW_StagingTables_Create_Scripts');DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals";
CREATE OR REPLACE FUNCTION public."stpMergeDailyFactIntervals"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN


   -- TRUNCATE TEMP TABLE
  TRUNCATE  TABLE public.facts_temp ;

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MontlhyRead"        as "dw_MontlhyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "TCC"                as "dw_TCC",
                 "CBL"                as "dw_CBL",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "Price"              as "dw_Price",
                 "PriceReduction"     as "dw_PriceReduction",
                 "MarginalUsage"      as "dw_MarginalUsage",
                 "MarginalCost"       as "dw_MarginalCost",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "CurrencyKey"        as "dw_CurrencyKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
          	"MontlhyRead"           as "stg_MontlhyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "TCC"                   as "stg_TCC",
            "CBL"                   as "stg_CBL",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "Price"                 as "stg_Price",
            "PriceReduction"        as "stg_PriceReduction",
            "MarginalUsage"         as "stg_MarginalUsage",
            "MarginalCost"          as "stg_MarginalCost",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "CurrencyKey"           as "stg_CurrencyKey",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimPriceCurrency" price
        ON price."CurrencyCode" = fct."CurrencyCode"
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO public.facts_temp
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"      = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"
        AND dw_fact."dw_CurrencyKey"    = stg_fact."stg_CurrencyKey"
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_TCC",
           "stg_CBL",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_Price",
           "stg_PriceReduction",
           "stg_MarginalUsage",
           "stg_MarginalCost",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_CurrencyKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals" dw_fct
       SET "FactStatusKey" = 2
   FROM public.facts_temp fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_TCC"            != fct."dw_TCC"
               OR fct."stg_CBL"            != fct."dw_CBL"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
               OR fct."stg_Price"          != fct."dw_Price"
               OR fct."stg_PriceReduction" != fct."dw_PriceReduction"
               OR fct."stg_MarginalUsage"  != fct."dw_MarginalUsage"
               OR fct."stg_MarginalCost"   != fct."dw_MarginalCost"
            );

    INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
            now()::timestamp,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_TCC",
           "stg_CBL",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_Price",
           "stg_PriceReduction",
           "stg_MarginalUsage",
           "stg_MarginalCost",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_CurrencyKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_TCC"            != fct."dw_TCC"
               OR fct."stg_CBL"            != fct."dw_CBL"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
               OR fct."stg_Price"          != fct."dw_Price"
               OR fct."stg_PriceReduction" != fct."dw_PriceReduction"
               OR fct."stg_MarginalUsage"  != fct."dw_MarginalUsage"
               OR fct."stg_MarginalCost"   != fct."dw_MarginalCost"
            );

  -- CANCEL UNEXISTANTS FACTS
  UPDATE dw."FactIntervals" dw_fct
       SET "FactStatusKey" = 2
   FROM public.facts_temp fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;

   INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
   SELECT
           now()::timestamp,
           "dw_MontlhyRead",
           "dw_Usage",
           "dw_UsageDLF",
           "dw_Demand",
           "dw_DemandDLF",
           "dw_TCC",
           "dw_CBL",
           "dw_DLP",
           "dw_DLPSum",
           "dw_DLPRation",
           "dw_DLF",
           "dw_Price",
           "dw_PriceReduction",
           "dw_MarginalUsage",
           "dw_MarginalCost",
           "dw_StartDateTimeUTC",
           "dw_EndDateTimeUTC",
           "dw_StartDateTimeLocal",
           "dw_EndDateTimeLocal",
           "dw_AccountKey",
           "dw_SDPKey",
           "dw_MeterKey",
           "dw_ChannelKey",
           "dw_CurrencyKey",
           "dw_OriginConsumptionKey",
           3,
           "dw_ServiceTypeKey",
           "dw_ParentIntervalKey",
           2,
           "dw_EndDateLocalKey",
           "dw_EndTimeLocalKey",
           "dw_EndDateUTCKey",
           "dw_EndTimeUTCKey",
           "dw_RecordedDateUTCKey"
   FROM public.facts_temp fct
   WHERE    fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;




  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('006_DW_MergeDailyFacts_Create_Scripts');CREATE or REPLACE FUNCTION dw."stpGetSettlementInfos" ( "clientIdParam"      INTEGER,
                                                        "startTradeDayUTC"   TIMESTAMP,
                                                        "transactionDate"    TIMESTAMP)
RETURNS
  TABLE
      (
          "TotalAccounts"        BIGINT ,
          "TotalIntervals"       BIGINT ,
          "CompletedIntervals"   BIGINT ,
          "EstimatedIntervals"   BIGINT ,
          "ExtraneousMeterReads" BIGINT ,
          "TotalKWH"             NUMERIC(28,4),
          "TotalMeters"          BIGINT,
          "TotalChannels"        BIGINT
      ) AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN

    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                orig."Code" as "OriginConsumptionCode",
                act."AccountAlternateKey",
                meter."MeterAlternateKey",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateUTCKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimOriginFactValue" orig
          ON orig."OriginConsumptionKey" = fct."OriginConsumptionKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND status."Code" = 'CURRENT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND fct."InsertionDateTime" <= "transactionDate"
              AND act."ApplicationCode"    = 'SETT'
              AND meter."ApplicationCode"  = 'SETT'
		),
    totals_CTE as
    (
        SELECT
              COUNT(DISTINCT "AccountAlternateKey") AS "Accounts",
              COUNT(*) AS "Intervals",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('REAL','CALC') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsCompleted",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('ESTI') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsEstimated",
              0::BIGINT AS "ExtraneousReads",
              sum("UsageDLF") AS "KWH",
              COUNT(DISTINCT "MeterAlternateKey") AS "Meters",
              COUNT(DISTINCT "ChannelAlternateKey") AS "Channels"
        FROM intervalsData_CTE
    )
    SELECT  *
    FROM totals_CTE;
END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('007_DW_SettlementInfos_Create_Scripts');DROP FUNCTION IF EXISTS dw."stpGetSettlementInfos";
CREATE or REPLACE FUNCTION dw."stpGetSettlementInfos" ( "clientIdParam"      INTEGER,
                                                        "isoIdParam"         INTEGER,
                                                        "startTradeDayUTC"   TIMESTAMP,
                                                        "transactionDate"    TIMESTAMP)
RETURNS
  TABLE
      (
          "TotalAccounts"        BIGINT ,
          "TotalIntervals"       BIGINT ,
          "CompletedIntervals"   BIGINT ,
          "EstimatedIntervals"   BIGINT ,
          "ExtraneousMeterReads" BIGINT ,
          "TotalKWH"             NUMERIC(28,4),
          "TotalMeters"          BIGINT,
          "TotalChannels"        BIGINT
      ) AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN

    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                orig."Code" as "OriginConsumptionCode",
                act."AccountAlternateKey",
                meter."MeterAlternateKey",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateUTCKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimOriginFactValue" orig
          ON orig."OriginConsumptionKey" = fct."OriginConsumptionKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND status."Code" = 'CURRENT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND fct."InsertionDateTime" <= "transactionDate"
              AND act."ApplicationCode"    = 'SETT'
              AND meter."ApplicationCode"  = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
		),
    totals_CTE as
    (
        SELECT
              COUNT(DISTINCT "AccountAlternateKey") AS "Accounts",
              COUNT(*) AS "Intervals",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('REAL','CALC') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsCompleted",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('ESTI') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsEstimated",
              0::BIGINT AS "ExtraneousReads",
              sum("UsageDLF") AS "KWH",
              COUNT(DISTINCT "MeterAlternateKey") AS "Meters",
              COUNT(DISTINCT "ChannelAlternateKey") AS "Channels"
        FROM intervalsData_CTE
    )
    SELECT  *
    FROM totals_CTE;
END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('008_DW_SettlementInfos_Create_Scripts');DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals";
CREATE OR REPLACE FUNCTION public."stpMergeDailyFactIntervals"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MontlhyRead"        as "dw_MontlhyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "TCC"                as "dw_TCC",
                 "CBL"                as "dw_CBL",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "Price"              as "dw_Price",
                 "PriceReduction"     as "dw_PriceReduction",
                 "MarginalUsage"      as "dw_MarginalUsage",
                 "MarginalCost"       as "dw_MarginalCost",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "CurrencyKey"        as "dw_CurrencyKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
          	"MontlhyRead"           as "stg_MontlhyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "TCC"                   as "stg_TCC",
            "CBL"                   as "stg_CBL",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "Price"                 as "stg_Price",
            "PriceReduction"        as "stg_PriceReduction",
            "MarginalUsage"         as "stg_MarginalUsage",
            "MarginalCost"          as "stg_MarginalCost",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "CurrencyKey"           as "stg_CurrencyKey",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimPriceCurrency" price
        ON price."CurrencyCode" = fct."CurrencyCode"
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO public.facts_temp
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"      = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"
        AND dw_fact."dw_CurrencyKey"    = stg_fact."stg_CurrencyKey"
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_TCC",
           "stg_CBL",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_Price",
           "stg_PriceReduction",
           "stg_MarginalUsage",
           "stg_MarginalCost",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_CurrencyKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals" dw_fct
       SET "FactStatusKey" = 2
   FROM public.facts_temp fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_TCC"            != fct."dw_TCC"
               OR fct."stg_CBL"            != fct."dw_CBL"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
               OR fct."stg_Price"          != fct."dw_Price"
               OR fct."stg_PriceReduction" != fct."dw_PriceReduction"
               OR fct."stg_MarginalUsage"  != fct."dw_MarginalUsage"
               OR fct."stg_MarginalCost"   != fct."dw_MarginalCost"
            );

    INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
            now()::timestamp,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_TCC",
           "stg_CBL",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_Price",
           "stg_PriceReduction",
           "stg_MarginalUsage",
           "stg_MarginalCost",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_CurrencyKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_TCC"            != fct."dw_TCC"
               OR fct."stg_CBL"            != fct."dw_CBL"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
               OR fct."stg_Price"          != fct."dw_Price"
               OR fct."stg_PriceReduction" != fct."dw_PriceReduction"
               OR fct."stg_MarginalUsage"  != fct."dw_MarginalUsage"
               OR fct."stg_MarginalCost"   != fct."dw_MarginalCost"
            );

  -- CANCEL UNEXISTANTS FACTS
  UPDATE dw."FactIntervals" dw_fct
       SET "FactStatusKey" = 2
   FROM public.facts_temp fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;

   INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
   SELECT
           now()::timestamp,
           "dw_MontlhyRead",
           "dw_Usage",
           "dw_UsageDLF",
           "dw_Demand",
           "dw_DemandDLF",
           "dw_TCC",
           "dw_CBL",
           "dw_DLP",
           "dw_DLPSum",
           "dw_DLPRation",
           "dw_DLF",
           "dw_Price",
           "dw_PriceReduction",
           "dw_MarginalUsage",
           "dw_MarginalCost",
           "dw_StartDateTimeUTC",
           "dw_EndDateTimeUTC",
           "dw_StartDateTimeLocal",
           "dw_EndDateTimeLocal",
           "dw_AccountKey",
           "dw_SDPKey",
           "dw_MeterKey",
           "dw_ChannelKey",
           "dw_CurrencyKey",
           "dw_OriginConsumptionKey",
           3,
           "dw_ServiceTypeKey",
           "dw_ParentIntervalKey",
           2,
           "dw_EndDateLocalKey",
           "dw_EndTimeLocalKey",
           "dw_EndDateUTCKey",
           "dw_EndTimeUTCKey",
           "dw_RecordedDateUTCKey"
   FROM public.facts_temp fct
   WHERE    fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;




  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('010_DW_MergeDailyFacts_Create_Scripts');DROP TABLE dw."FactIntervals";
-- FactIntervals
CREATE TABLE dw."FactIntervals"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"MontlhyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,	
	"UsageDLF" NUMERIC(28,4),	
    "Demand" NUMERIC(28,4) ,    
	"DemandDLF" NUMERIC(28,4) ,    
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
    "DLP" NUMERIC(18,6),	
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),	
    "DLF" NUMERIC(18,7),
	"Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
    "MarginalUsage" NUMERIC(28,4),
    "MarginalCost" NUMERIC(28,4),
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
    "AccountKey" INT,
    "SDPKey" INT ,
    "MeterKey" INT,
    "ChannelKey" INT,
    "CurrencyKey" SMALLINT,
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
	"ServiceTypeKey" SMALLINT,
	"ParentIntervalKey" BIGINT,
	"FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactIntervals" IS 'Intervals Fact Table';

--2015
CREATE TABLE dw.intervals_y2015m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m07 ("StartDateTimeUTC", "EndDateTimeUTC");


CREATE TABLE dw.intervals_y2015m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m12 ("StartDateTimeUTC", "EndDateTimeUTC");


--2016
CREATE TABLE dw.intervals_y2016m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m12 ("StartDateTimeUTC", "EndDateTimeUTC");

--2017
CREATE TABLE dw.intervals_y2017m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m12 ("StartDateTimeUTC", "EndDateTimeUTC");

--2018
CREATE TABLE dw.intervals_y2018m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m12 ("StartDateTimeUTC", "EndDateTimeUTC");

--2019
CREATE TABLE dw.intervals_y2019m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m12 ("StartDateTimeUTC", "EndDateTimeUTC");

INSERT INTO public."DatabaseVersionHistory" VALUES ('011_DW_FactIntervals_Drop_Create_Scripts');DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals";
CREATE OR REPLACE FUNCTION public."stpMergeDailyFactIntervals"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MontlhyRead"        as "dw_MontlhyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "TCC"                as "dw_TCC",
                 "CBL"                as "dw_CBL",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "Price"              as "dw_Price",
                 "PriceReduction"     as "dw_PriceReduction",
                 "MarginalUsage"      as "dw_MarginalUsage",
                 "MarginalCost"       as "dw_MarginalCost",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "CurrencyKey"        as "dw_CurrencyKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MontlhyRead"           as "stg_MontlhyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "TCC"                   as "stg_TCC",
            "CBL"                   as "stg_CBL",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "Price"                 as "stg_Price",
            "PriceReduction"        as "stg_PriceReduction",
            "MarginalUsage"         as "stg_MarginalUsage",
            "MarginalCost"          as "stg_MarginalCost",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "CurrencyKey"           as "stg_CurrencyKey",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimPriceCurrency" price
        ON price."CurrencyCode" = fct."CurrencyCode"
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO public.facts_temp
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"      = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"
        AND dw_fact."dw_CurrencyKey"    = stg_fact."stg_CurrencyKey"
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "AgingDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_TCC",
           "stg_CBL",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_Price",
           "stg_PriceReduction",
           "stg_MarginalUsage",
           "stg_MarginalCost",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_CurrencyKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_TCC"            != fct."dw_TCC"
               OR fct."stg_CBL"            != fct."dw_CBL"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
               OR fct."stg_Price"          != fct."dw_Price"
               OR fct."stg_PriceReduction" != fct."dw_PriceReduction"
               OR fct."stg_MarginalUsage"  != fct."dw_MarginalUsage"
               OR fct."stg_MarginalCost"   != fct."dw_MarginalCost"
            );

    INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "AgingDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_TCC",
           "stg_CBL",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_Price",
           "stg_PriceReduction",
           "stg_MarginalUsage",
           "stg_MarginalCost",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_CurrencyKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_TCC"            != fct."dw_TCC"
               OR fct."stg_CBL"            != fct."dw_CBL"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
               OR fct."stg_Price"          != fct."dw_Price"
               OR fct."stg_PriceReduction" != fct."dw_PriceReduction"
               OR fct."stg_MarginalUsage"  != fct."dw_MarginalUsage"
               OR fct."stg_MarginalCost"   != fct."dw_MarginalCost"
            );

  -- CANCEL UNEXISTANTS FACTS
  UPDATE dw."FactIntervals" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;

   INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "AgingDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
   SELECT
           now()::timestamp,
	   now()::timestamp,
           "dw_MontlhyRead",
           "dw_Usage",
           "dw_UsageDLF",
           "dw_Demand",
           "dw_DemandDLF",
           "dw_TCC",
           "dw_CBL",
           "dw_DLP",
           "dw_DLPSum",
           "dw_DLPRation",
           "dw_DLF",
           "dw_Price",
           "dw_PriceReduction",
           "dw_MarginalUsage",
           "dw_MarginalCost",
           "dw_StartDateTimeUTC",
           "dw_EndDateTimeUTC",
           "dw_StartDateTimeLocal",
           "dw_EndDateTimeLocal",
           "dw_AccountKey",
           "dw_SDPKey",
           "dw_MeterKey",
           "dw_ChannelKey",
           "dw_CurrencyKey",
           "dw_OriginConsumptionKey",
           3,
           "dw_ServiceTypeKey",
           "dw_ParentIntervalKey",
           2,
           "dw_EndDateLocalKey",
           "dw_EndTimeLocalKey",
           "dw_EndDateUTCKey",
           "dw_EndTimeUTCKey",
           "dw_RecordedDateUTCKey"
   FROM public.facts_temp fct
   WHERE    fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;




  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('012_DW_MergeDailyFacts_Create_Scripts');CREATE or REPLACE FUNCTION dw."stpGetOMARNewData"("ClientId" INTEGER, "TradeDay" TIMESTAMP WITHOUT TIME ZONE, "TransactionDateTime" TIMESTAMP WITHOUT TIME ZONE)
  RETURNS TABLE("Id" INTEGER, "TheClientId" INTEGER, "TheTradeDay" TIMESTAMP WITHOUT TIME ZONE, "TheTransactionDateTime" TIMESTAMP WITHOUT TIME ZONE)
LANGUAGE plpgsql
AS $$
BEGIN

RETURN QUERY
SELECT 1 AS "Id", "ClientId", "TradeDay", "TransactionDateTime"
UNION
SELECT 2 AS "Id", "ClientId", "TradeDay", "TransactionDateTime"
UNION
SELECT 3 AS "Id", "ClientId", "TradeDay", "TransactionDateTime";
END
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('013_DW_OMARNewData_Create_Scripts');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN


    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
		),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"--,
                 --"ChannelAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";
END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('014_DW_MisoData_Create_Scripts');--DimMeter RECREATE INDEXES
DROP INDEX dw.DimMeter_MeterAlternateKey_Name_Current_index;
CREATE INDEX DimMeter_MeterAlternateKey_AppCode_Name_Current_index ON dw."DimMeter" ("MeterAlternateKey","ApplicationCode","Name","Current");
REINDEX TABLE dw."DimMeter";


--DimChannel Rearange alternatekey value

--TRUNCATE DATA 
TRUNCATE TABLE dw."FactIntervals";
TRUNCATE TABLE dw."DimChannel";

--DROP TABLE 
DROP TABLE dw."DimChannel";

-- RECREATE CHANNEL TABLE 
CREATE TABLE dw."DimChannel"
(
    "ChannelKey" BIGSERIAL PRIMARY KEY NOT NULL,
    "ChannelAlternateKey" VARCHAR(100) NOT NULL,
	"ApplicationCode" varchar(4) NOT NULL,
    "ChannelNumber" SMALLINT NOT NULL,
    "SetNumber" SMALLINT,
    "NumberOfDials" SMALLINT NOT NULL,
    "MeterMultiplier" DECIMAL(12,5) NOT NULL,
    "PulseMultiplier" DECIMAL(12,5) NOT NULL,
    "PulseOffset" DECIMAL(12,5) NOT NULL,
    "BillingMultiplier" DECIMAL(12,5) NOT NULL,
    "EnglishChannelTypeDescription" VARCHAR(20) NOT NULL,
    "SpanishChannelTypeDescription" VARCHAR(20) NOT NULL,
    "IntervalsPerHour" SMALLINT NOT NULL,
    "IsDelivered" boolean,
    "IsVirtual" boolean NOT NULL,
    "UomKey" SMALLINT NOT NULL,
	"PowerFctConfigKey" INT,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimChannel" IS 'Channel and Channel Type Dimension';
CREATE INDEX DimChan_AlternateKey_AppCode_ChanNumber_Current_index ON dw."DimChannel" ("ChannelAlternateKey","ApplicationCode","ChannelNumber","Current");
CREATE INDEX DimChan_AlternateKey_AppCode_IntPerHour_Uom_Current_index ON dw."DimChannel" ("ChannelAlternateKey","ApplicationCode","IntervalsPerHour","UomKey","Current");
ALTER TABLE dw."DimChannel" ADD CONSTRAINT FK_Channel_UOM FOREIGN KEY ("UomKey") REFERENCES dw."DimUOM"("UomKey");
ALTER TABLE dw."DimChannel" ADD CONSTRAINT FK_Channel_PowerFctConfig   FOREIGN KEY ("PowerFctConfigKey") REFERENCES dw."DimPowerFctConfig"("PowerFctConfigKey");


--REBUILD INDEX
REINDEX TABLE dw."DimChannel";


-- DROP STAGING TABLE 
DROP TABLE stg."Channel";

--RECREATE STAGING TABLE 
CREATE TABLE stg."Channel"
(
    "ChannelId" VARCHAR(100) ,
	"ApplicationCode" varchar(4),
    "ChannelNumber" integer,
    "UnitOfMeasureId" integer,
    "ChannelTypeId" integer,
    "RTPId" integer,
    "IntervalsPerHour" integer,
    "NumberOfDials" integer,
    "IsDelivered" boolean,
    "SetNumber" integer,
    "MeterMultiplier" numeric(12,5),
    "PulseMultiplier" numeric(12,5),
    "PulseOffset" numeric(12,5),
    "BillingMultiplier" numeric(12,5),
    "IsVirtual" boolean,
    "IsSum" boolean,
	"ChannelTypeDescription" character varying(20),
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."Channel" IS 'Channel Staging Table';


ALTER TABLE stg."FactIntervals"
ALTER COLUMN "ChannelId" SET DATA TYPE VARCHAR(100);


INSERT INTO public."DatabaseVersionHistory" VALUES ('015_DW_DimChannel_AlternateKey_Update_Script');


--Clured Dimension table on their primary key

--DimAccount
CLUSTER dw."DimAccount" USING "DimAccount_pkey";

--DimChannel
CLUSTER dw."DimChannel" USING "DimChannel_pkey";

--DimClient
CLUSTER dw."DimClient" USING "DimClient_pkey";

--DimControlArea
CLUSTER dw."DimControlArea" USING "DimControlArea_pkey";

--DimCustomer
CLUSTER dw."DimCustomer" USING "DimCustomer_pkey";

--DimDate
CLUSTER dw."DimDate" USING "DimDate_pkey";

--DimEnergyPowerType
CLUSTER dw."DimEnergyPowerType" USING "DimEnergyPowerType_pkey";

--DimFactStatus
CLUSTER dw."DimFactStatus" USING "DimFactStatus_pkey";

--DimFactValueGoal
CLUSTER dw."DimFactValueGoal" USING "DimFactValueGoal_pkey";

--DimISO
CLUSTER dw."DimISO" USING "DimISO_pkey";

--DimLocation
CLUSTER dw."DimLocation" USING "DimLocation_pkey";

--DimMeter
CLUSTER dw."DimMeter" USING "DimMeter_pkey";

--DimOriginFactValue
CLUSTER dw."DimOriginFactValue" USING "DimOriginFactValue_pkey";

--DimPowerFctConfig
CLUSTER dw."DimPowerFctConfig" USING "DimPowerFctConfig_pkey";

--DimPriceCurrency
CLUSTER dw."DimPriceCurrency" USING "DimPriceCurrency_pkey";

--DimSDP
CLUSTER dw."DimSDP" USING "DimSDP_pkey";

--DimServiceType
CLUSTER dw."DimServiceType" USING "DimServiceType_pkey";

--DimTime
CLUSTER dw."DimTime" USING "DimTime_pkey";

--DimTimeZone
CLUSTER dw."DimTimeZone" USING "DimTimeZone_pkey";

--DimUom
CLUSTER dw."DimUOM" USING "DimUOM_pkey";

--DimWeatherStation
CLUSTER dw."DimWeatherStation" USING "DimWeatherStation_pkey";

INSERT INTO public."DatabaseVersionHistory" VALUES ('016_DW_DimClustered_Create_Script');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN


    RETURN  QUERY
    with intervalsData_CTE  as
	(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr"
		
        FROM dw."FactIntervals" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
	          AND chan."IsDelivered" = TRUE
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
	),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('017_DW_MisoData_Create_Scripts');DROP FUNCTION IF EXISTS ct."stpGetLastLoadStreamInfo";

CREATE or REPLACE FUNCTION ct."stpGetLastLoadStreamInfo" ()
RETURNS
  TABLE
      (
        "StreamId" bigint,
		"FromSyncDateUTC" timestamp,
		"ToSyncDateUTC" timestamp,
		"ProcessStartDateTime" timestamp,
		"ProcessEndDateTime" timestamp,
		"Status" character varying(10)		  
      ) AS $$      
BEGIN

    RETURN  QUERY
    SELECT  
		str."StreamId",
		str."FromSyncDateUTC",
		str."ToSyncDateUTC",
		str."ProcessStartDateTime",
		str."ProcessEndDateTime",
		str."Status"		  
    FROM ct."LoadStream" str
	ORDER BY "StreamId" DESC
	LIMIT 1;

END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('018_DW_EtlGetLastLoadStream_Create_Scripts');
DROP TABLE dw."FactIntervals";
-- FactIntervals
CREATE TABLE dw."FactIntervals_SETT"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"MontlhyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,	
	"UsageDLF" NUMERIC(28,4),	
    "Demand" NUMERIC(28,4) ,    
	"DemandDLF" NUMERIC(28,4) ,        
    "DLP" NUMERIC(18,6),	
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),	
    "DLF" NUMERIC(18,7),    
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
    "AccountKey" INT,
    "SDPKey" INT ,
    "MeterKey" INT,
    "ChannelKey" INT,    
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
	"ServiceTypeKey" SMALLINT,
	"ParentIntervalKey" BIGINT,
	"FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactIntervals_SETT" IS 'Intervals Fact Table';

--2015
CREATE TABLE dw.intervals_y2015m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2015m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateTimeUTC", "StartDateTimeUTC");


CREATE TABLE dw.intervals_y2015m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2015m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2015m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2015m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2015m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateTimeUTC", "StartDateTimeUTC");


--2016
CREATE TABLE dw.intervals_y2016m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateTimeUTC", "StartDateTimeUTC");

--2017
CREATE TABLE dw.intervals_y2017m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateTimeUTC", "StartDateTimeUTC");

--2018
CREATE TABLE dw.intervals_y2018m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateTimeUTC", "StartDateTimeUTC");

--2019
CREATE TABLE dw.intervals_y2019m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateTimeUTC", "StartDateTimeUTC");

INSERT INTO public."DatabaseVersionHistory" VALUES ('019_DW_FactIntervals_Remove_Unused_Create_Scripts');DROP TABLE stg."FactIntervals";

-- FactIntervals
CREATE TABLE stg."FactIntervals_SETT"
(
	"MontlhyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,
	"UsageDLF" NUMERIC(28,4),
    "Demand" NUMERIC(28,4) ,
	"DemandDLF" NUMERIC(28,4),        
    "DLP" NUMERIC(18,6),
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),
    "DLF" NUMERIC(18,7),
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
	"ClientId" INT,
    "AccountId" INT,
    "SDPId" INT ,
    "DeviceCode" character varying(50),
    "ChannelId" VARCHAR(100),
	"OriginConsumptionCode" VARCHAR(8),
	"ApplicationCode" varchar(4),
    "EndDateLocal" TIMESTAMP,
    "EndTimeLocal" VARCHAR(10),
    "EndDateUTC" TIMESTAMP,
    "EndTimeUTC" VARCHAR(10),
	"RecordedDateUTC" TIMESTAMP
);
COMMENT ON TABLE stg."FactIntervals_SETT" IS 'Intervals Staging Fact Table for Settlement';
CREATE INDEX ON stg."FactIntervals_SETT" ("EndDateTimeUTC", "ApplicationCode");



DROP TABLE public.facts_temp;

CREATE TABLE public.facts_temp_sett
(
    "dw_IntervalKey" bigint,
    "dw_InsertionDateTime" timestamp without time zone,
    "dw_MontlhyRead" numeric(28,4),
    "dw_Usage" numeric(28,4),
    "dw_UsageDLF" numeric(28,4),
    "dw_Demand" numeric(28,4),
    "dw_DemandDLF" numeric(28,4),
    "dw_DLP" numeric(18,6),
    "dw_DLPSum" numeric(18,6),
    "dw_DLPRation" numeric(18,6),
    "dw_DLF" numeric(18,7),
    "dw_StartDateTimeUTC" timestamp without time zone,
    "dw_EndDateTimeUTC" timestamp without time zone,
    "dw_StartDateTimeLocal" timestamp without time zone,
    "dw_EndDateTimeLocal" timestamp without time zone,
    "dw_AccountKey" integer,
    "dw_SDPKey" integer,
    "dw_MeterKey" integer,
    "dw_ChannelKey" integer,
    "dw_OriginConsumptionKey" smallint,
    "dw_FactValueGoalKey" smallint,
    "dw_ServiceTypeKey" smallint,
    "dw_ParentIntervalKey" bigint,
    "dw_FactStatusKey" smallint,
    "dw_EndDateLocalKey" integer,
    "dw_EndTimeLocalKey" smallint,
    "dw_EndDateUTCKey" integer,
    "dw_EndTimeUTCKey" smallint,
    "dw_RecordedDateUTCKey" integer,
    "dw_ClientKey" integer,
    "stg_MontlhyRead" numeric(28,4),
    "stg_Usage" numeric(28,4),
    "stg_UsageDLF" numeric(28,4),
    "stg_Demand" numeric(28,4),
    "stg_DemandDLF" numeric(28,4),
    "stg_DLP" numeric(18,6),
    "stg_DLPSum" numeric(18,6),
    "stg_DLPRation" numeric(18,6),
    "stg_DLF" numeric(18,7),
    "stg_StartDateTimeUTC" timestamp without time zone,
    "stg_EndDateTimeUTC" timestamp without time zone,
    "stg_StartDateTimeLocal" timestamp without time zone,
    "stg_EndDateTimeLocal" timestamp without time zone,
    "stg_ClientKey" integer,
    "stg_AccountKey" integer,
    "stg_SDPKey" integer,
    "stg_MeterKey" integer,
    "stg_ChannelKey" integer,
    "stg_OriginConsumptionKey" smallint,
    "stg_OriginConsumptionCode" character varying(8) COLLATE pg_catalog."default",
    "stg_ServiceTypeKey" smallint,
    "stg_EndDateLocalKey" integer,
    "stg_EndDateUTCKey" integer,
    "stg_EndTimeLocalKey" smallint,
    "stg_EndTimeUTCKey" smallint,
    "stg_RecordedDateKey" integer
) ;
CREATE INDEX ON public.facts_temp_sett ("stg_EndDateUTCKey","dw_IntervalKey");



INSERT INTO public."DatabaseVersionHistory" VALUES ('020_DW_StagingTables_Remove_Unused_Create_Scripts');DROP FUNCTION IF EXISTS dw."stpGetSettlementInfos";
CREATE or REPLACE FUNCTION dw."stpGetSettlementInfos" ( "clientIdParam"      INTEGER,
                                                        "isoIdParam"         INTEGER,
                                                        "startTradeDayUTC"   TIMESTAMP,
                                                        "transactionDate"    TIMESTAMP)
RETURNS
  TABLE
      (
          "TotalAccounts"        BIGINT ,
          "TotalIntervals"       BIGINT ,
          "CompletedIntervals"   BIGINT ,
          "EstimatedIntervals"   BIGINT ,
          "ExtraneousMeterReads" BIGINT ,
          "TotalKWH"             NUMERIC(28,4),
          "TotalMeters"          BIGINT,
          "TotalChannels"        BIGINT
      ) AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN

    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                orig."Code" as "OriginConsumptionCode",
                act."AccountAlternateKey",
                meter."MeterAlternateKey",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateUTCKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimOriginFactValue" orig
          ON orig."OriginConsumptionKey" = fct."OriginConsumptionKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND status."Code" = 'CURRENT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND fct."InsertionDateTime" <= "transactionDate"
              AND act."ApplicationCode"    = 'SETT'
              AND meter."ApplicationCode"  = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
		),
    totals_CTE as
    (
        SELECT
              COUNT(DISTINCT "AccountAlternateKey") AS "Accounts",
              COUNT(*) AS "Intervals",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('REAL','CALC') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsCompleted",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('ESTI') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsEstimated",
              0::BIGINT AS "ExtraneousReads",
              sum("UsageDLF") AS "KWH",
              COUNT(DISTINCT "MeterAlternateKey") AS "Meters",
              COUNT(DISTINCT "ChannelAlternateKey") AS "Channels"
        FROM intervalsData_CTE
    )
    SELECT  *
    FROM totals_CTE;
END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('021_DW_SettlementInfos_Create_Scripts');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN


    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
		),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"--,
                 --"ChannelAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";
END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('022_DW_MisoData_Create_Scripts');DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals";
CREATE OR REPLACE FUNCTION public."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MontlhyRead"        as "dw_MontlhyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MontlhyRead"           as "stg_MontlhyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals_SETT" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO public.facts_temp_sett
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"      = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
            );

  -- CANCEL UNEXISTANTS FACTS
  UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;

   INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
   SELECT
           now()::timestamp,
	   now()::timestamp,
           "dw_MontlhyRead",
           "dw_Usage",
           "dw_UsageDLF",
           "dw_Demand",
           "dw_DemandDLF",
           "dw_DLP",
           "dw_DLPSum",
           "dw_DLPRation",
           "dw_DLF",
           "dw_StartDateTimeUTC",
           "dw_EndDateTimeUTC",
           "dw_StartDateTimeLocal",
           "dw_EndDateTimeLocal",
           "dw_AccountKey",
           "dw_SDPKey",
           "dw_MeterKey",
           "dw_ChannelKey",
           "dw_OriginConsumptionKey",
           3,
           "dw_ServiceTypeKey",
           "dw_ParentIntervalKey",
           2,
           "dw_EndDateLocalKey",
           "dw_EndTimeLocalKey",
           "dw_EndDateUTCKey",
           "dw_EndTimeUTCKey",
           "dw_RecordedDateUTCKey"
   FROM public.facts_temp_sett fct
   WHERE    fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;




  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('023_DW_MergeDailyFacts_SETT_Create_Scripts');
-- FactIntervals
CREATE TABLE dw."FactIntervals_OMDA"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"IntervalTimeId" BIGINT,
    "Usage" NUMERIC(28,4) ,		
    "Demand" NUMERIC(28,4) ,    	   
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
	"Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
    "MarginalUsage" NUMERIC(28,4),
    "MarginalCost" NUMERIC(28,4),
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
    "AccountKey" INT,
    "SDPKey" INT ,
    "MeterKey" INT,
    "ChannelKey" INT,
    "CurrencyKey" SMALLINT,
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
	"ServiceTypeKey" SMALLINT,
	"ParentIntervalKey" BIGINT,
	"FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT
)PARTITION BY RANGE ("EndDateLocalKey");
COMMENT ON TABLE dw."FactIntervals_OMDA" IS 'Intervals Fact Table';

--2015
CREATE TABLE dw.intervals_omda_y2015m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_omda_y2015m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2015m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_omda_y2015m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2015m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_omda_y2015m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2015m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_omda_y2015m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2015m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_omda_y2015m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2015m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_omda_y2015m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2015m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_omda_y2015m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("SDPKey", "MeterKey", "AccountKey");





--2016
CREATE TABLE dw.intervals_omda_y2016m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_omda_y2016m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2016m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_omda_y2016m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2016m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_omda_y2016m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2016m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_omda_y2016m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2016m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_omda_y2016m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2016m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_omda_y2016m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2016m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_omda_y2016m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2016m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_omda_y2016m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2016m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_omda_y2016m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2016m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_omda_y2016m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2016m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_omda_y2016m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2016m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_omda_y2016m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("SDPKey", "MeterKey", "AccountKey");





--2017
CREATE TABLE dw.intervals_omda_y2017m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_omda_y2017m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2017m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_omda_y2017m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_omda_y2017m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2017m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_omda_y2017m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2017m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_omda_y2017m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2017m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_omda_y2017m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_omda_y2017m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_omda_y2017m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_omda_y2017m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_omda_y2017m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_omda_y2017m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_omda_y2017m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("SDPKey", "MeterKey", "AccountKey");






--2018
CREATE TABLE dw.intervals_omda_y2018m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_omda_y2018m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_omda_y2018m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2018m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_omda_y2018m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_omda_y2018m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_omda_y2018m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_omda_y2018m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_omda_y2018m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2018m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_omda_y2018m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_omda_y2018m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_omda_y2018m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_omda_y2018m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2018m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_omda_y2018m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("SDPKey", "MeterKey", "AccountKey");




--2019
CREATE TABLE dw.intervals_omda_y2019m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_omda_y2019m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_omda_y2019m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_omda_y2019m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_omda_y2019m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_omda_y2019m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_omda_y2019m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_omda_y2019m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_omda_y2019m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_omda_y2019m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_omda_y2019m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_omda_y2019m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_omda_y2019m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("SDPKey", "MeterKey", "AccountKey");






INSERT INTO public."DatabaseVersionHistory" VALUES ('024_DW_FactIntervals_OMDA_Create_Scripts');DROP TABLE dw."FactWeather";

-- FactWeather
CREATE TABLE dw."FactWeather"
(
    "WeatherKey" BIGSERIAL,
    "InsertionDateTime" TIMESTAMP,
    "AgingDateTime" TIMESTAMP,	
	"WeatherObservationId" BIGINT,
    "StationKey" INT,
	"FactValueGoalKey" SMALLINT,	
	"FactStatusKey" SMALLINT,
	"ParentWeatherKey" BIGINT,	
	"EndDateTimeUTC" TIMESTAMP ,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT,
    "oC" INT,
    "oF" INT,
    "Humidity" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactWeather" IS 'Weather Fact Table';


--2015
CREATE TABLE dw.weather_y2015m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.weather_y2015m06 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2015m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.weather_y2015m07 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2015m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.weather_y2015m08 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2015m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.weather_y2015m09 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2015m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.weather_y2015m10 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2015m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.weather_y2015m11 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");







CREATE TABLE dw.weather_y2015m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.weather_y2015m12 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");






--2016
CREATE TABLE dw.weather_y2016m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.weather_y2016m01 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.weather_y2016m02 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2016m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.weather_y2016m03 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.weather_y2016m04 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.weather_y2016m05 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.weather_y2016m06 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.weather_y2016m07 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.weather_y2016m08 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.weather_y2016m09 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.weather_y2016m10 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");






CREATE TABLE dw.weather_y2016m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.weather_y2016m11 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");






CREATE TABLE dw.weather_y2016m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.weather_y2016m12 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





--2017
CREATE TABLE dw.weather_y2017m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.weather_y2017m01 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");






CREATE TABLE dw.weather_y2017m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.weather_y2017m02 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.weather_y2017m03 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.weather_y2017m04 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.weather_y2017m05 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.weather_y2017m06 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.weather_y2017m07 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.weather_y2017m08 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.weather_y2017m09 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.weather_y2017m10 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.weather_y2017m11 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.weather_y2017m12 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





--2018
CREATE TABLE dw.weather_y2018m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.weather_y2018m01 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2018m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.weather_y2018m02 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");



CREATE TABLE dw.weather_y2018m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.weather_y2018m03 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2018m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.weather_y2018m04 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.weather_y2018m05 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.weather_y2018m06 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.weather_y2018m07 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.weather_y2018m08 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.weather_y2018m09 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.weather_y2018m10 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.weather_y2018m11 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.weather_y2018m12 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





--2019
CREATE TABLE dw.weather_y2019m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.weather_y2019m01 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2019m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.weather_y2019m02 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.weather_y2019m03 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.weather_y2019m04 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.weather_y2019m05 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.weather_y2019m06 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.weather_y2019m07 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.weather_y2019m08 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2019m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.weather_y2019m09 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.weather_y2019m10 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.weather_y2019m11 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.weather_y2019m12 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");



INSERT INTO public."DatabaseVersionHistory" VALUES ('025_DW_FactWeather_Create_Scripts');DROP TABLE stg."FactIntervals_SETT";

-- FactIntervals
CREATE TABLE stg."FactIntervals"
(
    "Omda_IntervalTimeId" BIGINT,
	"MonthlyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,
	"UsageDLF" NUMERIC(28,4),
    "Demand" NUMERIC(28,4) ,
	"DemandDLF" NUMERIC(28,4) ,
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
    "DLP" NUMERIC(18,6),
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),
    "DLF" NUMERIC(18,7),
	"Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
    "MarginalUsage" NUMERIC(28,4),
    "MarginalCost" NUMERIC(28,4),
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
	"ClientId" INT,
    "AccountId" INT,
    "SDPId" INT ,
    "DeviceCode" character varying(50),
    "ChannelId" VARCHAR(100),
    "CurrencyCode" VARCHAR(3),
	"OriginConsumptionCode" VARCHAR(8),
	"ApplicationCode" varchar(4),
    "EndDateLocal" TIMESTAMP,
    "EndTimeLocal" VARCHAR(10),
    "EndDateUTC" TIMESTAMP,
    "EndTimeUTC" VARCHAR(10),
	"RecordedDateUTC" TIMESTAMP
);
COMMENT ON TABLE stg."FactIntervals" IS 'Intervals Staging Fact Table';
CREATE INDEX ON stg."FactIntervals" ("EndDateTimeUTC", "ApplicationCode");
CREATE INDEX ON stg."FactIntervals" ("Omda_IntervalTimeId","EndDateTimeUTC", "ApplicationCode");


-- FactWeather 
CREATE TABLE stg."FactWeather"
(
	"WeatherObservationId" BIGINT,
    "ObservationStationId" INT,	
	"EndDateTimeUTC" TIMESTAMP ,
    "EndDateUTC" TIMESTAMP,
    "EndTimeUTC" VARCHAR(10),
	"RecordedDateUTC" TIMESTAMP,
    "oC" INT,
    "oF" INT,
    "Humidity" INT
);
COMMENT ON TABLE stg."FactWeather" IS 'Weather Fact Table';
CREATE INDEX ON  stg."FactWeather" ("EndDateTimeUTC");
CREATE INDEX ON  stg."FactWeather" ("WeatherObservationId","ObservationStationId","EndDateTimeUTC");



-- Meter
DROP TABLE stg."Meter";
CREATE TABLE stg."Meter"
(
    "MeterId" integer,
    "MeterTypeId" integer,
    "Name" character varying(50) ,
    "DeviceCode" character varying(50) ,
    "IntervalsPerHour" integer,
    "IsDSTEnabled" boolean,
    "TimeZoneId" integer,
    "IsVirtual" boolean,
    "DSTRegionId" integer,
    "FirstEndDateTimeUTC" timestamp,
    "LastEndDateTimeUTC" timestamp,
    "Manufacturer" character varying(50) ,
    "Type" character varying(50) ,
    "ApplicationCode" character varying(4),
	"MeterSDP" character varying(100),
	"MeterSDPStartDateTime" timestamp,
	"MeterSDPStopDateTime" timestamp,
    "StartDateTime" timestamp without time zone
);
COMMENT ON TABLE stg."Meter" IS 'Staging Meter';


DROP TABLE dw."DimMeter";
CREATE TABLE dw."DimMeter"
(
    "MeterKey" SERIAL PRIMARY KEY NOT NULL,
    "MeterAlternateKey" VARCHAR(50) NOT NULL,
    "ApplicationCode" varchar(4) NOT NULL,
    "Name" VARCHAR(50) NOT NULL,
    "IntervalsPerHour" SMALLINT NOT NULL,
    "IsDSTEnabled" boolean NOT NULL,
    "IsVirtual" boolean NOT NULL,
    "MeterType" VARCHAR(50) NULL,
    "Manufacturer" VARCHAR(50) NULL,
	"FirstEndDateTimeUTC" TIMESTAMP,
    "LastEndDateTimeUTC" TIMESTAMP,
	"MeterSDP" character varying(100) NULL,
	"MeterSDPStartDateTime" timestamp NULL,
	"MeterSDPStopDateTime" timestamp NULL,
    "TimeZoneKey" SMALLINT NULL,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimMeter" IS 'Meter, MeterType and MeterManufacturer Dimension';
CREATE INDEX DimMeter_MeterAlternateKey_AppCode_Name_Current_index ON dw."DimMeter" ("MeterAlternateKey","ApplicationCode","Name","Current");
ALTER TABLE dw."DimMeter" ADD CONSTRAINT FK_Meter_TimeZone FOREIGN KEY ("TimeZoneKey") REFERENCES dw."DimTimeZone" ("TimeZoneKey");





-- TEMPORARY TABLE USED DURING  MERGE OPERATION
DROP TABLE public.meter_temp ;
CREATE TABLE public.meter_temp
(
    "MeterId" integer,
    "MeterTypeId" integer,
    "Name" character varying(50) COLLATE pg_catalog."default",
    "DeviceCode" character varying(50) COLLATE pg_catalog."default",
    "IntervalsPerHour" integer,
    "IsDSTEnabled" boolean,
    "TimeZoneId" integer,
    "InsertionTimeZoneKey" smallint,
    "IsVirtual" boolean,
    "DSTRegionId" integer,
    "FirstEndDateTimeUTC" timestamp,
    "LastEndDateTimeUTC" timestamp,
    "Manufacturer" character varying(50) COLLATE pg_catalog."default",
    "Type" character varying(50) COLLATE pg_catalog."default",
    "ApplicationCode" character varying(4) COLLATE pg_catalog."default",
	"MeterSDP" character varying(100) NULL,
	"MeterSDPStartDateTime" timestamp NULL,
	"MeterSDPStopDateTime" timestamp NULL,
    "StartDateTime" timestamp without time zone,
    "MeterKey" integer,
    "Current" boolean,
    "TimeZoneKey" smallint
);




DROP TABLE public.facts_temp_sett;

CREATE TABLE public.facts_temp_sett
(
    "dw_IntervalKey" bigint,
    "dw_InsertionDateTime" timestamp without time zone,
    "dw_MonthlyRead" numeric(28,4),
    "dw_Usage" numeric(28,4),
    "dw_UsageDLF" numeric(28,4),
    "dw_Demand" numeric(28,4),
    "dw_DemandDLF" numeric(28,4),
    "dw_DLP" numeric(18,6),
    "dw_DLPSum" numeric(18,6),
    "dw_DLPRation" numeric(18,6),
    "dw_DLF" numeric(18,7),
    "dw_StartDateTimeUTC" timestamp without time zone,
    "dw_EndDateTimeUTC" timestamp without time zone,
    "dw_StartDateTimeLocal" timestamp without time zone,
    "dw_EndDateTimeLocal" timestamp without time zone,
    "dw_AccountKey" integer,
    "dw_SDPKey" integer,
    "dw_MeterKey" integer,
    "dw_ChannelKey" integer,
    "dw_OriginConsumptionKey" smallint,
    "dw_FactValueGoalKey" smallint,
    "dw_ServiceTypeKey" smallint,
    "dw_ParentIntervalKey" bigint,
    "dw_FactStatusKey" smallint,
    "dw_EndDateLocalKey" integer,
    "dw_EndTimeLocalKey" smallint,
    "dw_EndDateUTCKey" integer,
    "dw_EndTimeUTCKey" smallint,
    "dw_RecordedDateUTCKey" integer,
    "dw_ClientKey" integer,
    "stg_MonthlyRead" numeric(28,4),
    "stg_Usage" numeric(28,4),
    "stg_UsageDLF" numeric(28,4),
    "stg_Demand" numeric(28,4),
    "stg_DemandDLF" numeric(28,4),
    "stg_DLP" numeric(18,6),
    "stg_DLPSum" numeric(18,6),
    "stg_DLPRation" numeric(18,6),
    "stg_DLF" numeric(18,7),
    "stg_StartDateTimeUTC" timestamp without time zone,
    "stg_EndDateTimeUTC" timestamp without time zone,
    "stg_StartDateTimeLocal" timestamp without time zone,
    "stg_EndDateTimeLocal" timestamp without time zone,
    "stg_ClientKey" integer,
    "stg_AccountKey" integer,
    "stg_SDPKey" integer,
    "stg_MeterKey" integer,
    "stg_ChannelKey" integer,
    "stg_OriginConsumptionKey" smallint,
    "stg_OriginConsumptionCode" character varying(8) COLLATE pg_catalog."default",
    "stg_ServiceTypeKey" smallint,
    "stg_EndDateLocalKey" integer,
    "stg_EndDateUTCKey" integer,
    "stg_EndTimeLocalKey" smallint,
    "stg_EndTimeUTCKey" smallint,
    "stg_RecordedDateKey" integer
) ;
CREATE INDEX ON public.facts_temp_sett ("stg_EndDateUTCKey","dw_IntervalKey");




CREATE TABLE public.facts_temp_weather
(
   "dw_WeatherKey" BIGINT,
   "dw_InsertionDateTime" TIMESTAMP ,
   "dw_AgingDateTime" TIMESTAMP,
   "dw_WeatherObservationId" BIGINT,
   "dw_StationKey" INTEGER,
   "dw_FactValueGoalKey" SMALLINT,
   "dw_FactStatusKey" SMALLINT,
   "dw_ParentWeatherkey" BIGINT,
   "dw_EndDateTimeUTC" TIMESTAMP,
   "dw_EndDateUTCKey" INTEGER,
   "dw_EndTimeUTCKey" SMALLINT,
   "dw_RecorderdDateUTCKey" INTEGER,
   "dw_oC" INTEGER,
   "dw_oF" INTEGER,
   "dw_Humidity" INTEGER,
   "stg_WeatherObservationId" BIGINT,
   "stg_EndDateTimeUTC" TIMESTAMP,
   "stg_oC" INTEGER,
   "stg_oF" INTEGER,
   "stg_Humidity" INTEGER,
   "stg_StationKey" INTEGER,           
   "stg_EndDateUTCKey" INTEGER,         
   "stg_EndTimeUTCKey" SMALLINT,
   "stg_RecordedDateKey" INTEGER
) ;
CREATE INDEX ON public.facts_temp_weather ("stg_EndDateUTCKey","dw_WeatherKey");





INSERT INTO public."DatabaseVersionHistory" VALUES ('026_DW_StagingTables_Create_Scripts');ALTER TABLE dw."FactIntervals_SETT" 
RENAME COLUMN "MontlhyRead" TO "MonthlyRead";



DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals_SETT";

CREATE OR REPLACE FUNCTION public."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO public.facts_temp_sett
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

  -- CANCEL UNEXISTANTS FACTS
  UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;

   INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
   SELECT
           now()::timestamp,
	   now()::timestamp,
           "dw_MonthlyRead",
           "dw_Usage",
           "dw_UsageDLF",
           "dw_Demand",
           "dw_DemandDLF",
           "dw_DLP",
           "dw_DLPSum",
           "dw_DLPRation",
           "dw_DLF",
           "dw_StartDateTimeUTC",
           "dw_EndDateTimeUTC",
           "dw_StartDateTimeLocal",
           "dw_EndDateTimeLocal",
           "dw_AccountKey",
           "dw_SDPKey",
           "dw_MeterKey",
           "dw_ChannelKey",
           "dw_OriginConsumptionKey",
           3,
           "dw_ServiceTypeKey",
           "dw_ParentIntervalKey",
           2,
           "dw_EndDateLocalKey",
           "dw_EndTimeLocalKey",
           "dw_EndDateUTCKey",
           "dw_EndTimeUTCKey",
           "dw_RecordedDateUTCKey"
   FROM public.facts_temp_sett fct
   WHERE    fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;




  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('027_DW_MergeDailyFacts_SETT_Create_Scripts');CREATE SCHEMA IF NOT EXISTS etl ;

CREATE OR REPLACE FUNCTION etl."GetNextStreamId"()
RETURNS TABLE
(
  "_StreamId" BIGINT
)
LANGUAGE plpgsql
AS $$
BEGIN
	
	RETURN QUERY
	SELECT 
		"StreamId"
	FROM ct."LoadStream"
	WHERE  "ProcessStartDateTime" IS NULL AND "ProcessEndDateTime" IS NULL 
	ORDER  BY  "StreamId" DESC
	LIMIT 1;

END 
$$;



CREATE OR REPLACE FUNCTION etl."CreateNewStream" () 
RETURNS void AS $$
BEGIN
   
   INSERT INTO ct."LoadStream"("FromSyncDateUTC","ToSyncDateUTC","ProcessStartDateTime","ProcessEndDateTime","Status") 
   VALUES (date_trunc('day', now())::timestamp without time zone, date_trunc('day', now())::timestamp without time zone  ,NULL, NULL, NULL);

END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."GetStreamToProcess"()
RETURNS TABLE
(
  "StreamId" BIGINT,
  "FromSyncDateUTC" TIMESTAMP,
  "ToSyncDateUTC" TIMESTAMP
)
LANGUAGE plpgsql
AS $$
BEGIN	
	RETURN QUERY
	(
	  SELECT 
		ct."LoadStream"."StreamId",
        ct."LoadStream"."FromSyncDateUTC",
        ct."LoadStream"."ToSyncDateUTC"
	  FROM ct."LoadStream"
	  ORDER BY "StreamId" DESC
	  LIMIT 1
	);
END 
$$;

CREATE OR REPLACE FUNCTION etl."UpdateStreamStartProcess" ("streamId" integer) 
RETURNS void AS $$
BEGIN
   
   UPDATE 
   	 ct."LoadStream"
   SET "ProcessStartDateTime"= now()::timestamp
   WHERE "StreamId" = "streamId";

END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION etl."UpdateStreamFinalStatus" ("streamId" integer, "statusETL" text) 
RETURNS void AS $$
BEGIN   
    UPDATE ct."LoadStream"
	SET "ProcessEndDateTime"= now()::timestamp,
		"Status"= "statusETL"
	WHERE "StreamId" = "streamId" ;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."GetStagingTableListToTruncate"()
RETURNS TABLE
(
  "table_name" text
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
	SELECT T.table_name::text
	FROM  information_schema.tables T
	WHERE table_schema= 'stg'
	   AND table_type='BASE TABLE';
END 
$$;



CREATE OR REPLACE FUNCTION etl."InsertNewLoadCycle" ("_streamId" integer, "_envCode" text , "_sourceSchema" text , "_destSchema" text, "_loadType" text) 
RETURNS void AS $$
BEGIN
   
 INSERT INTO ct."LoadCycle"
 (
	 "EnvCode",
	 "SourceSchema",
	 "DestinationSchema",
	 "LoadType",
	 "StartingDateTime",
	 "EndDateTime",
	 "Status",
	 "StreamId"
 )
 VALUES ("_envCode","_sourceSchema", "_destSchema", "_loadType", now()::timestamp, NULL, NULL,"_streamId" );

END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."GetCurrentLoadCycleIdByStreamId"("currentStreamId" integer)
RETURNS TABLE
(
  "LoadCycleId" bigint
)
LANGUAGE plpgsql
AS $$
BEGIN
	
	RETURN QUERY
	(
		SELECT 
				L."LoadCycleId"
		FROM ct."LoadCycle" L
		WHERE "StreamId" = "currentStreamId"
		ORDER BY  "StartingDateTime" DESC
		LIMIT 1
	);

END 
$$;



CREATE OR REPLACE FUNCTION etl."UpdateLoadCycleStatus" ("_LoadCycleId" BIGINT, "_LoadCycleStatus" text) 
RETURNS void AS $$
BEGIN

	UPDATE ct."LoadCycle"
	SET 
	 "EndDateTime"= now()::timestamp,
	 "Status" = "_LoadCycleStatus"
	WHERE "LoadCycleId" = "_LoadCycleId" ;

END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION etl."GetDateData"()
RETURNS TABLE
(
	date_dim_id INTEGER,
	date_actual DATE,
	date_actual_Timestamp TIMESTAMP,
	day_of_week DOUBLE PRECISION,
	day_name TEXT,
	day_name1 TEXT,
	day_of_month DOUBLE PRECISION,
	day_of_year DOUBLE PRECISION,
	week_of_year DOUBLE PRECISION,
	month_name TEXT,
	month_name1 TEXT,
	month_actual DOUBLE PRECISION,
	quarter_actual DOUBLE PRECISION,
	year_actual DOUBLE PRECISION,
	semester INTEGER,
	style101 TEXT,
	style103 TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
		SELECT TO_CHAR(datum,'yyyymmdd')::INT AS date_dim_id,
		   datum AS date_actual,
		   TO_CHAR(datum,'yyyymmdd')::TIMESTAMP AS date_actual_Timestamp,
		   EXTRACT(isodow FROM datum) AS day_of_week,
		   TO_CHAR(datum,'Day') AS day_name,
		   TO_CHAR(datum,'Day') AS day_name,
		   EXTRACT(DAY FROM datum) AS day_of_month,
		   EXTRACT(doy FROM datum) AS day_of_year,
		   EXTRACT(week FROM datum) AS week_of_year,
		   TO_CHAR(datum,'Month') AS month_name,
		   TO_CHAR(datum,'Month') AS month_name,
		   EXTRACT(MONTH FROM datum) AS month_actual,
		   EXTRACT(quarter FROM datum) AS quarter_actual,
		   EXTRACT(isoyear FROM datum) AS year_actual,
		   CASE
			 WHEN EXTRACT(MONTH FROM datum) <= 6 THEN 1
			   ELSE 2
		   END AS semester,
		   TO_CHAR(datum,'mm/dd/yyyy') AS style101,
		   TO_CHAR(datum,'dd/mm/yyyy') AS style103
	FROM (SELECT '2015-01-01'::DATE+ SEQUENCE.DAY AS datum
		  FROM GENERATE_SERIES (0,3287) AS SEQUENCE (DAY)
		  GROUP BY SEQUENCE.DAY
		  order by datum) DQ
	ORDER BY 1
;
	
END 
$$;


CREATE OR REPLACE FUNCTION etl."GetTimeData"()
RETURNS TABLE
(
	time_value text,
	hour_12 text,
	hour_24 text ,
	am_pm text,
	day_minutes double precision,
	time05min double precision,
	time10min integer,
	time15min integer ,
    time30min integer ,
	time60min double precision,
	time_value1 text
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
	SELECT
        to_char(minute, 'hh24mi') AS time_value,
        to_char(minute, 'hh12') hour_12,
        to_char(minute, 'hh24') AS hour_24,
        case
            when to_char(minute, 'hh24:mi') BETWEEN '00:00' AND '11:59' then 'AM'
            else 'PM'
        end AS am_pm,
        extract(minute FROM minute) day_minutes,
        case
            when extract(minute FROM minute) in(0) then 11
            else (extract(minute FROM minute) / 5) -1
        end AS time05Min,
        case
            when extract(minute FROM minute) in(5,10) then 0
            when extract(minute FROM minute) in(15,20) then 1
            when extract(minute FROM minute) in(25,30) then 2
            when extract(minute FROM minute) in(35,40) then 3
            when extract(minute FROM minute) in(45,50) then 4
            else 5
        end AS time10Min,
        case
            when extract(minute FROM minute) in(5,10,15) then 0
            when extract(minute FROM minute) in(20,25,30) then 1
            when extract(minute FROM minute) in(35,40,45) then 2
            else 3
        end AS time15Min,
        case
            when extract(minute FROM minute) in(5,10,15,20,25,30) then 0
            else 1
        end AS time30Min,
        case
            when extract(minute FROM minute) in(0) and to_char(minute, 'hh12') in ('12')  then 23
            when extract(minute FROM minute) in(0) then extract(HOUR FROM minute) - 1
            else extract(HOUR FROM minute)
        end AS time60Min,
        to_char(minute, 'hh24:mi') AS time_value
	FROM
	  (
			SELECT '0:00'::time + 5*(sequence.minute || ' minutes')::interval AS minute
			FROM generate_series(0,287) AS sequence(minute)
	  ) DQ;	

	
END 
$$;





CREATE OR REPLACE FUNCTION etl."GetServiceTypeData"()
RETURNS TABLE
(
  serviceTypeId INTEGER,
  code TEXT,
  description TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
	SELECT 
		1 as serviceTypeId,
		'OMDA' as code,
		'Olameter Meter Data Analyser' as description

	UNION 

	 SELECT 
		2 as serviceTypeId,
		'SETT' as code,
		'Settlement' as description
				
				;

END 
$$;



CREATE OR REPLACE FUNCTION etl."GetOriginFactData"()
RETURNS TABLE
(
  orignFactId INTEGER,
  code TEXT,
  englishDescription TEXT,
  spanishDescription TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
	SELECT 
		1 as orignFactId,
		'CALC' as code,
		'Calculated' as englishDescription,
		'Calculado' as spanishDescription

	UNION 

	 SELECT 
		2 as orignFactId,
		'ESTI' as code,
		'Estimated' as englishDescription,
		'Estimado' as spanishDescription

	UNION 

	SELECT 
		3 as orignFactId,
		'REAL' as code,
		'Real' as englishDescription,
		'Real' as spanishDescription

    ;
END 
$$;



CREATE OR REPLACE FUNCTION etl."GetFactValueGoalData"()
RETURNS TABLE
(
  factValueGoalId INTEGER,
  code TEXT,
  englishDescription TEXT,
  spanishDescription TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
	SELECT 
		1 as factValueGoalId,
		'INIT' as code,
		'Initial' as englishDescription,
		'Inicial' as spanishDescription

	UNION 

	 SELECT 
		2 as factValueGoalId,
		'NEW' as code,
		'New' as englishDescription,
		'Nuevo' as spanishDescription

	UNION 

	 SELECT 
		3 as factValueGoalId,
		'CANCEL' as code,
		'Cancelled' as englishDescription,
		'Cancelado' as spanishDescription

	UNION

	 SELECT 
		4 as factValueGoalId,
		'CORR' as code,
		'Correction' as englishDescription,
		'Correccion' as spanishDescription

    ;
END 
$$;



CREATE OR REPLACE FUNCTION etl."GetFactStatusData"()
RETURNS TABLE
(
  factStatusKey INTEGER,
  code TEXT,
  englishDescription TEXT,
  spanishDescription TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
	
	SELECT 
		1 as FactStatusKey,
		'CURRENT' as code,
		'Current value' as EnglishFactStatusDescription,
		'Valor actual' as SpanishFactStatusDescription

	UNION 

	SELECT 
		2 as FactStatusKey,
		'OLD' as code,
		'Old value' as EnglishFactStatusDescription,
		'Valor antiguo' as SpanishFactStatusDescription

    ;
END 
$$;



CREATE OR REPLACE FUNCTION etl."MergeLocationData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimLocation"("LocationAlternateKey", "City", "StateProvinceAbbr", "StateProvinceName", "CountryAbbr", "EnglishCountryName", "SpanishCountryName")
	SELECT "CityId", "CityName", "StateAbbreviation", "StateName", "CountryAbbreviation", "CountryName","CountryName"
	FROM stg."Location"
	ON CONFLICT ("LocationAlternateKey") 
	DO UPDATE SET  
	"City"               =  EXCLUDED."City",
	"StateProvinceAbbr"  =  EXCLUDED."StateProvinceAbbr",
	"StateProvinceName"  =  EXCLUDED."StateProvinceName",
	"CountryAbbr"        =  EXCLUDED."CountryAbbr",
	"EnglishCountryName" =  EXCLUDED."EnglishCountryName",
	"SpanishCountryName" =  EXCLUDED."EnglishCountryName";

END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION etl."MergeStationData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimWeatherStation"("StationAlternateKey", "Name")
	SELECT "ObservationStationId", "Name"
	FROM stg."ObservationStation"
	ON CONFLICT ("StationAlternateKey") 
	DO UPDATE SET  
	"Name" =  EXCLUDED."Name" ;

END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION etl."MergeTimezoneData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimTimeZone"("TimeZoneAlternateKey", "Abbreviation", "EnglishName", "SpanishName", "OffsetToGMT")
	SELECT "TimeZoneId","Abbreviation", "Name", "Name","OffsetToGMT"
	FROM stg."TimeZone"
	ON CONFLICT ("TimeZoneAlternateKey") 
	DO UPDATE SET  
	"Abbreviation"       =  EXCLUDED."Abbreviation",
	"EnglishName"  		 =  EXCLUDED."EnglishName",
	"SpanishName"  		 =  EXCLUDED."EnglishName",
	"OffsetToGMT"        =  EXCLUDED."OffsetToGMT" ;

END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION etl."MergeISOData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimISO"("ISOAlternateKey", "ISOName", "ISOEnglishDescription", "ISOSpanishDescription", "ISODefaultFormat")	
	SELECT "IndSysOperatorId", "Name", "Description","Description", 'N/A'
	FROM stg."IndSysOperator"   
	ON CONFLICT ("ISOAlternateKey") 
	DO UPDATE SET  
	"ISOName"                =  EXCLUDED."ISOName",
	"ISOEnglishDescription"  =  EXCLUDED."ISOEnglishDescription",
	"ISOSpanishDescription"  =  EXCLUDED."ISOEnglishDescription",
	"ISODefaultFormat"      =  'N/A' ;

END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION etl."MergePowerTypeData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimEnergyPowerType"("EnergyPowerTypeAlternateKey", "EnglishEnergyPowerTypeDescription", "SpanishPowerTypeDescription")
	SELECT "EnergyPowerTypeId", "Description", "Description"
	FROM stg."EnergyPowerType"
	ON CONFLICT ("EnergyPowerTypeAlternateKey") 
	DO UPDATE SET  
	"EnglishEnergyPowerTypeDescription"     =  EXCLUDED."EnglishEnergyPowerTypeDescription",
	"SpanishPowerTypeDescription"           =  EXCLUDED."EnglishEnergyPowerTypeDescription" ;

END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION etl."MergeSDPData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimSDP"("SDPAlternateKey", "Address", "Address1", "PostalCode", "Longitude", "Latitude", "Name", "IsVirtual", "LoadReductionPriceCode", "CustomerBaseLineAdjLoadReduction", "CustomerBaseLineAdjType", "LocationKey", "StationKey", "StartDateTime", "EndDateTime", "Current")
	SELECT "SDPId", "Address", "Address1", "PostalCode", "Longitude", "Latitude", S."Name",  "IsVirtual", "LoadReductionPriceCode", "CustomerBaseLineAdjustmentLoadReduction", "CustomerBaseLineAdjustmentType",  "LocationKey",  "StationKey", "StartDateTime", NULL, True 
	FROM stg."SDP" S
	LEFT JOIN dw."DimLocation" L 
	ON S."CityId" = L."LocationAlternateKey"
	LEFT JOIN  dw."DimWeatherStation" W
	ON W."StationAlternateKey" = S."ObservationStationId"
	ON CONFLICT ("SDPAlternateKey") 
	DO UPDATE SET  
	"Address"                				=  EXCLUDED."Address",
	"Address1"               			=  EXCLUDED."Address1",
	"PostalCode"             			=  EXCLUDED."PostalCode",
	"Longitude"              				=  EXCLUDED."Longitude",
	"Latitude"               				=  EXCLUDED."Latitude",
	"Name"                   				=  EXCLUDED."Name",
	"IsVirtual"              				    =  EXCLUDED."IsVirtual",
	"LoadReductionPriceCode" 				=  EXCLUDED."LoadReductionPriceCode",
	"CustomerBaseLineAdjLoadReduction" 	=  EXCLUDED."CustomerBaseLineAdjLoadReduction",
	"CustomerBaseLineAdjType" 			=  EXCLUDED."CustomerBaseLineAdjType",
	"LocationKey"             			=  EXCLUDED."LocationKey",
	"StationKey"              			=  EXCLUDED."StationKey" ;

END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION etl."MergeClientData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimClient"("ClientAlternateKey", "ClientName", "LogoFileName", "LogoFileBinaryContent", "ClientUrl", "MonthsToRetain","Duns" , "StartDateTime", "EndDateTime", "Current")
	SELECT  "ClientId", "Name","LogoFileName",NULL , "ClientUrl", "MonthsToRetain", "Duns" ,"StartDateTime", NULL, True
	FROM stg."Client"
	ON CONFLICT ("ClientAlternateKey") 
	DO UPDATE SET  
	"ClientName"        =  EXCLUDED."ClientName",
	"LogoFileName"      =  EXCLUDED."LogoFileName",
	"ClientUrl"         =  EXCLUDED."ClientUrl",
	"MonthsToRetain"    =  EXCLUDED."MonthsToRetain",
	"Duns"    =  EXCLUDED."Duns";

END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."MergeCustomerData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimCustomer"("CustomerAlternateKey", "ApplicationCode", "Name", "StartDateTime", "EndDateTime", "Current")
	SELECT 
		CASE 
			WHEN "ApplicationCode" = 'OMDA' THEN "CustomerId"::text 
			WHEN "ApplicationCode" = 'SETT' THEN "Name"
		END AS "CustomerAlternateKey",
		"ApplicationCode",
		"Name",
		"StartDateTime",
		NULL as "EndDateTime" ,
		TRUE as "Current"
	FROM stg."Customer"
	ON CONFLICT ("CustomerAlternateKey","ApplicationCode") 
	DO UPDATE SET  
	"Name"  =  EXCLUDED."Name" ;

END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."MergeControlAreaData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimControlArea"("ControlAreaAlternateKey", "Name", "Abbreviation", "Duns", "ISOKey")
	SELECT "ControlAreaId", "Name", "Abbreviation", "Duns", "ISOKey"
	FROM stg."ControlArea" C
	LEFT JOIN dw."DimISO" I
	ON I."ISOAlternateKey" = C."IndSysOperatorId"

	ON CONFLICT ("ControlAreaAlternateKey") 
	DO UPDATE SET  
	"Name"          =  EXCLUDED."Name",
	"Abbreviation"  =  EXCLUDED."Abbreviation",
	"Duns"          =  EXCLUDED."Duns",
	"ISOKey"        =  EXCLUDED."ISOKey";

END;
$$ LANGUAGE plpgsql;






CREATE OR REPLACE FUNCTION etl."MergeUomData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimUOM"("UomAlternateKey", "EnglishDescription", "SpanishDescription", "Code", "UomFromMV90", "ConversionKey", "EnglishUomTypeDescription", "SpanishUomTypeDescription", "EnergyPowerTypeKey","EDI867Code")
	SELECT "UnitOfMeasureId", "Description","Description","Code", "UomFromMV90","UnitOfMeasureConversionId","UomTypeDescription","UomTypeDescription", "EnergyPowerTypeKey","EDI867Code"
	FROM stg."UnitOfMeasure" U
	LEFT JOIN dw."DimEnergyPowerType" E
	ON E."EnergyPowerTypeAlternateKey" = U."EnergyPowerTypeId"

	ON CONFLICT ("UomAlternateKey") 
	DO UPDATE SET  
	"EnglishDescription"               =  EXCLUDED."EnglishDescription",
	"SpanishDescription"               =  EXCLUDED."EnglishDescription",
	"Code"                             =  EXCLUDED."Code",
	"UomFromMV90"                      =  EXCLUDED."UomFromMV90",
	"ConversionKey"                    =  EXCLUDED."ConversionKey",
	"EnglishUomTypeDescription"        =  EXCLUDED."EnglishUomTypeDescription",
	"SpanishUomTypeDescription"        =  EXCLUDED."EnglishUomTypeDescription",
	"EnergyPowerTypeKey"               =  EXCLUDED."EnergyPowerTypeKey",
	"EDI867Code"                                   =  EXCLUDED."EDI867Code" ;
	
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."MergeChannelData" () 
RETURNS void AS $$
BEGIN

	-- INSERT NEW CHANNELS
	INSERT INTO dw."DimChannel"("ChannelAlternateKey","ApplicationCode", "ChannelNumber", "SetNumber", "NumberOfDials", "MeterMultiplier", "PulseMultiplier", "PulseOffset", "BillingMultiplier", "EnglishChannelTypeDescription", "SpanishChannelTypeDescription", "IntervalsPerHour", "IsDelivered", "IsVirtual", "UomKey", "PowerFctConfigKey", "StartDateTime", "EndDateTime", "Current")
	SELECT 
			"ChannelId",
			C."ApplicationCode",
			C."ChannelNumber",
			C."SetNumber",
			C."NumberOfDials",
			C."MeterMultiplier",
			C."PulseMultiplier",
			C."PulseOffset",
			C."BillingMultiplier",
			C."ChannelTypeDescription",
			C."ChannelTypeDescription",
			C."IntervalsPerHour",
			C."IsDelivered",
			C."IsVirtual",
			M."UomKey",
			NULL,
			C."StartDateTime",
			NULL,
			True

	FROM stg."Channel" C
	LEFT JOIN dw."DimUOM" M 
	ON M."UomAlternateKey" = C."UnitOfMeasureId"
	LEFT JOIN dw."DimChannel" dimChan
	ON dimChan."ChannelAlternateKey" = C."ChannelId"  AND dimChan."ApplicationCode" = C."ApplicationCode" AND dimChan."Current" = True
	WHERE dimChan."ChannelKey" IS NULL ;

	-- UPDATE EXISTING CHANNELS
	UPDATE dw."DimChannel"
	SET 
		"ChannelNumber"        		   =  C."ChannelNumber",
		"SetNumber"             		   =  C."SetNumber",
		"NumberOfDials"         		   =  C."NumberOfDials",
		"MeterMultiplier"    			   =  C."MeterMultiplier",
		"PulseMultiplier"      		   =  C."PulseMultiplier",
		"PulseOffset"      			   =  C."PulseOffset",
		"BillingMultiplier"        	   =  C."BillingMultiplier",
		"EnglishChannelTypeDescription"  =  C."ChannelTypeDescription",
		"SpanishChannelTypeDescription"  =  C."ChannelTypeDescription",
		"IntervalsPerHour"      		   =  C."IntervalsPerHour",
		"IsDelivered"				       =  C."IsDelivered",
		"IsVirtual"    				   =  C."IsVirtual",
		"UomKey"         				   =  M."UomKey"

	FROM stg."Channel" C
	LEFT JOIN dw."DimUOM" M 
	ON M."UomAlternateKey" = C."UnitOfMeasureId"
	WHERE 		dw."DimChannel"."ChannelAlternateKey" = C."ChannelId"  
			AND dw."DimChannel"."ApplicationCode" = C."ApplicationCode"
			AND dw."DimChannel"."Current" = True 
			;
	
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."MergeUomConversionData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimUOM"("UomAlternateKey", "EnglishDescription", "SpanishDescription", "Code", "UomFromMV90", "ConversionKey", "EnglishUomTypeDescription", "SpanishUomTypeDescription", "EnergyPowerTypeKey","EDI867Code")
	SELECT  U."UnitOfMeasureId", U."Description",U."Description",U."Code", U."UomFromMV90",U2."UomKey",U."UomTypeDescription",U."UomTypeDescription", E."EnergyPowerTypeKey",U."EDI867Code"
	FROM stg."UnitOfMeasure" U
	LEFT JOIN dw."DimEnergyPowerType" E
	ON E."EnergyPowerTypeAlternateKey" = U."EnergyPowerTypeId"
	LEFT JOIN dw."DimUOM" U2 
	ON U2."UomAlternateKey" = U."UnitOfMeasureConversionId"

	ON CONFLICT ("UomAlternateKey") 
	DO UPDATE SET  
	"EnglishDescription"               =  EXCLUDED."EnglishDescription",
	"SpanishDescription"               =  EXCLUDED."EnglishDescription",
	"Code"                             =  EXCLUDED."Code",
	"UomFromMV90"                      =  EXCLUDED."UomFromMV90",
	"ConversionKey"                    =  EXCLUDED."ConversionKey",
	"EnglishUomTypeDescription"        =  EXCLUDED."EnglishUomTypeDescription",
	"SpanishUomTypeDescription"        =  EXCLUDED."EnglishUomTypeDescription",
	"EnergyPowerTypeKey"               =  EXCLUDED."EnergyPowerTypeKey",
	"EDI867Code"                                   =  EXCLUDED."EDI867Code";
	
END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION etl."MergeMeterData" () 
RETURNS void AS $$
BEGIN


	INSERT INTO METER_TEMP  
	SELECT 
				"MeterId",
				"MeterTypeId",
				MS."Name",
				"DeviceCode",
				MS."IntervalsPerHour",
				MS."IsDSTEnabled",
				MS."TimeZoneId",
				TZ."TimeZoneKey" as "InsertionTimeZoneKey",
				MS."IsVirtual",
				"DSTRegionId",
				MS."FirstEndDateTimeUTC",
				MS."LastEndDateTimeUTC",
				MS."Manufacturer",
				"Type",
				MS."ApplicationCode",
				MS."MeterSDP",
				MS."MeterSDPStartDateTime",
				MS."MeterSDPStopDateTime",								
				MS."StartDateTime",
				MD."MeterKey",
				MD."Current",
				MD."TimeZoneKey"
	FROM  stg."Meter" MS
	LEFT JOIN dw."DimTimeZone" TZ
	ON TZ."TimeZoneAlternateKey" = MS."TimeZoneId"
	LEFT JOIN dw."DimMeter" MD
	ON MD."MeterAlternateKey" = MS."DeviceCode" AND  MD."ApplicationCode" = MS."ApplicationCode" AND MD."Current" = TRUE ;

	-- INSERT NEW ROWS
	INSERT INTO 
		 dw."DimMeter"(
		"MeterAlternateKey",
		"ApplicationCode",
		"Name",
		"IntervalsPerHour",
		"IsDSTEnabled",
		"IsVirtual",
		"MeterType",
		"Manufacturer",
		"FirstEndDateTimeUTC",
		"LastEndDateTimeUTC",
		"MeterSDP",
		"MeterSDPStartDateTime",
		"MeterSDPStopDateTime",	
		"TimeZoneKey",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
		"DeviceCode",
		"ApplicationCode",
		"Name",
		"IntervalsPerHour",
		"IsDSTEnabled",
		"IsVirtual",
		"Type",
		"Manufacturer",
		"FirstEndDateTimeUTC",
		"LastEndDateTimeUTC",
		"MeterSDP",
		"MeterSDPStartDateTime",
		"MeterSDPStopDateTime",	
		"InsertionTimeZoneKey",
		"StartDateTime",
		NULL,
		TRUE 
	FROM METER_TEMP
	WHERE "MeterKey" IS NULL ;

	-- UPDATE ROWS WITH NO HISTORICAL
	UPDATE dw."DimMeter" 
	SET 
		"Name" = METER_TEMP."Name",
		"IntervalsPerHour" = METER_TEMP."IntervalsPerHour",
		"IsDSTEnabled" = METER_TEMP."IsDSTEnabled",
		"IsVirtual" = METER_TEMP."IsVirtual",
		"MeterType" = METER_TEMP."Type",
		"Manufacturer" = METER_TEMP."Manufacturer",
		"FirstEndDateTimeUTC" = METER_TEMP."FirstEndDateTimeUTC",
		"LastEndDateTimeUTC" = METER_TEMP."LastEndDateTimeUTC",
		"MeterSDP" = METER_TEMP."MeterSDP",
		"MeterSDPStartDateTime" = METER_TEMP."MeterSDPStartDateTime",
		"MeterSDPStopDateTime" = METER_TEMP."MeterSDPStopDateTime"		
	FROM METER_TEMP 
	WHERE     METER_TEMP."MeterKey" IS NOT NULL 
	     AND  METER_TEMP."MeterKey" =  dw."DimMeter"."MeterKey"
		 AND  COALESCE(METER_TEMP."InsertionTimeZoneKey",0) = COALESCE(dw."DimMeter"."TimeZoneKey",0)
		 AND  COALESCE(METER_TEMP."MeterSDP",'-1') = COALESCE(dw."DimMeter"."MeterSDP",'-1')		 
		 AND  METER_TEMP."Current" = TRUE;


	-- UPDATE ROWS WITH HISTORICAL (ENDDATETIME UPDATE)
	UPDATE dw."DimMeter" 
	SET 
		"EndDateTime" = now()::timestamp,
		"Current" = FALSE                  
	FROM METER_TEMP 
	WHERE     METER_TEMP."MeterKey" IS NOT NULL 
		 AND  METER_TEMP."MeterKey" = dw."DimMeter"."MeterKey"
		 AND  (
			 	COALESCE(METER_TEMP."InsertionTimeZoneKey",0) != COALESCE(dw."DimMeter"."TimeZoneKey",0)
			    OR 
			    COALESCE(METER_TEMP."MeterSDP",'-1')          != COALESCE(dw."DimMeter"."MeterSDP",'-1')
			   )
		 AND  METER_TEMP."Current" = TRUE;

	-- INSERT HISTORICAL ROWS
	INSERT INTO 
		dw."DimMeter"(
		"MeterAlternateKey",
		"ApplicationCode",
		"Name",
		"IntervalsPerHour",
		"IsDSTEnabled",
		"IsVirtual",
		"MeterType",
		"Manufacturer",
		"FirstEndDateTimeUTC",
		"LastEndDateTimeUTC",
		"MeterSDP",
		"MeterSDPStartDateTime",
		"MeterSDPStopDateTime",	
		"TimeZoneKey",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
		MTemp."DeviceCode",
		MTemp."ApplicationCode",
		MTemp."Name",
		MTemp."IntervalsPerHour",
		MTemp."IsDSTEnabled",
		MTemp."IsVirtual",
		MTemp."Type",
		MTemp."Manufacturer",
		MTemp."FirstEndDateTimeUTC",
		MTemp."LastEndDateTimeUTC",
		MTemp."MeterSDP",
		MTemp."MeterSDPStartDateTime",
		MTemp."MeterSDPStopDateTime",	
		MTemp."InsertionTimeZoneKey",
		now()::timestamp as "StartDateTime",
		NULL,
		TRUE 
	FROM      METER_TEMP MTemp
	JOIN  dw."DimMeter" MSrc 
	ON MSrc."MeterKey" = MTemp."MeterKey"
	WHERE     MTemp."MeterKey" IS NOT NULL 
		  AND  (
			 	COALESCE(MTemp."InsertionTimeZoneKey",0) != COALESCE(MSrc."TimeZoneKey",0)
			    OR 
			    COALESCE(MTemp."MeterSDP",'-1')          != COALESCE(MSrc."MeterSDP",'-1')
			   )
		 AND  MTemp."Current" = TRUE;    

  
  	
END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION etl."MergeAccountData" () 
RETURNS void AS $$
BEGIN

INSERT INTO  ACCOUNT_TEMP  
	SELECT ACC_TEMP.*, Cust."CustomerKey" as "InsertionCustomerKey"
	FROM 
	(
			SELECT 
				"AccountId",
				"CustomerId",
				"CustomerName",
				CASE 
					WHEN  ASrc."ApplicationCode"= 'OMDA'  THEN "CustomerId"::text
					ELSE "CustomerName"
				END AS "CustomerAlternateId",
				"ClientId",
				CL."ClientKey" as "InsertionClientKey",
				ASrc."AccountNumber",
				ASrc."PremiseNumber",
				"ControlAreaId",
				CA."ControlAreaKey" as "InsertionControlAreaKey",
				"TimeZoneId",
				TZ."TimeZoneKey" as "InsertionTimeZoneKey",
				ASrc."ClientAccountKey",
				ASrc."ApplicationCode",
				ASrc."StartActiveDateTimeUTC",
				ASrc."EndActiveDateTimeUTC",
				ASrc."StartActiveDateTimeLocal",
				ASrc."EndActiveDateTimeLocal",
				ASrc."StartDateTime",
				ADes."AccountKey",
				ADes."ClientKey"      

		FROM stg."Account" ASrc
		LEFT JOIN dw."DimAccount" ADes
		ON ASrc."AccountId" = ADes."AccountAlternateKey"  AND ASrc."ApplicationCode" = ADes."ApplicationCode" AND ADes."Current" = TRUE
		LEFT JOIN dw."DimClient" CL
		ON CL."ClientAlternateKey" = ASrc."ClientId" AND CL."Current" =  TRUE
		LEFT JOIN dw."DimControlArea" CA
		ON CA."ControlAreaAlternateKey" = ASrc."ControlAreaId"
		LEFT JOIN dw."DimTimeZone" TZ
		ON TZ."TimeZoneAlternateKey" =  ASrc."TimeZoneId"
	) ACC_TEMP
	LEFT JOIN dw."DimCustomer" Cust
	ON  Cust."CustomerAlternateKey" = ACC_TEMP."CustomerAlternateId" AND Cust."Current" =  TRUE ;

	-- INSERT NEW ROWS
	INSERT INTO dw."DimAccount"(
		"AccountAlternateKey",
		"ApplicationCode",
		"AccountNumber",
		"PremiseNumber",
		"TimeZoneKey",
		"ClientAccountKey",
		"ClientKey",
		"CustomerKey",
		"ControlAreaKey",
		"StartActiveDateTimeUTC",
		"EndActiveDateTimeUTC",
		"StartActiveDateTimeLocal",
		"EndActiveDateTimeLocal",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
			"AccountId",
			"ApplicationCode",
			"AccountNumber",
			"PremiseNumber",
			"InsertionTimeZoneKey",
			"ClientAccountKey",
			"InsertionClientKey",
			"InsertionCustomerKey",
			"InsertionControlAreaKey",
			"StartActiveDateTimeUTC",
			"EndActiveDateTimeUTC",
			"StartActiveDateTimeLocal",
			"EndActiveDateTimeLocal",
			"StartDateTime",
			NULL,
			TRUE
	FROM ACCOUNT_TEMP
	WHERE "AccountKey" IS NULL ;

	-- UPDATE ROWS WITH NO HISTORICAL
	UPDATE dw."DimAccount"

		SET     	
			"ApplicationCode"= ACCOUNT_TEMP."ApplicationCode",
			"AccountNumber"= ACCOUNT_TEMP."AccountNumber",
			"PremiseNumber"= ACCOUNT_TEMP."PremiseNumber",
			"TimeZoneKey"= ACCOUNT_TEMP."InsertionTimeZoneKey",
			"ClientAccountKey"= ACCOUNT_TEMP."ClientAccountKey",
			"ClientKey"= ACCOUNT_TEMP."InsertionClientKey",
			"CustomerKey"= ACCOUNT_TEMP."InsertionCustomerKey",
			"ControlAreaKey"= ACCOUNT_TEMP."InsertionControlAreaKey",
			"StartActiveDateTimeUTC"= ACCOUNT_TEMP."StartActiveDateTimeUTC",
			"EndActiveDateTimeUTC"= ACCOUNT_TEMP."EndActiveDateTimeUTC",
			"StartActiveDateTimeLocal"= ACCOUNT_TEMP."StartActiveDateTimeLocal",
			"EndActiveDateTimeLocal"= ACCOUNT_TEMP."EndActiveDateTimeLocal"

	FROM     ACCOUNT_TEMP
	WHERE    ACCOUNT_TEMP."AccountKey" IS NOT NULL  
	      AND     ACCOUNT_TEMP."AccountKey"              = dw."DimAccount"."AccountKey"
		  AND    COALESCE(ACCOUNT_TEMP."InsertionClientKey",0)      = COALESCE(dw."DimAccount"."ClientKey",0)
		  AND    COALESCE(ACCOUNT_TEMP."InsertionCustomerKey",0)    = COALESCE(dw."DimAccount"."CustomerKey",0)
		  AND    COALESCE(ACCOUNT_TEMP."InsertionControlAreaKey",0) = COALESCE(dw."DimAccount"."ControlAreaKey",0) ;


	-- UPDATE ROWS WITH HISTORICAL (ENDDATETIME UPDATE)
	UPDATE dw."DimAccount"
	SET 
		"EndDateTime" = now()::timestamp,
		"Current" = FALSE                  
	FROM  ACCOUNT_TEMP 
	WHERE    ACCOUNT_TEMP."AccountKey" IS NOT NULL 
	      AND  ACCOUNT_TEMP."AccountKey" = dw."DimAccount"."AccountKey"
		  AND  (
			  	COALESCE (ACCOUNT_TEMP."InsertionClientKey",-1)      != COALESCE (dw."DimAccount"."ClientKey",-1) 
			    OR 
				COALESCE (ACCOUNT_TEMP."InsertionCustomerKey",-1)    != COALESCE (dw."DimAccount"."CustomerKey",-1)
			    OR
			    COALESCE (ACCOUNT_TEMP."InsertionControlAreaKey",-1) != COALESCE (dw."DimAccount"."ControlAreaKey",-1)
		       );

	-- INSERT HISTORICAL ROWS
	INSERT INTO dw."DimAccount"(
		"AccountAlternateKey",
		"ApplicationCode",
		"AccountNumber",
		"PremiseNumber",
		"TimeZoneKey",
		"ClientAccountKey",
		"ClientKey",
		"CustomerKey",
		"ControlAreaKey",
		"StartActiveDateTimeUTC",
		"EndActiveDateTimeUTC",
		"StartActiveDateTimeLocal",
		"EndActiveDateTimeLocal",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
			ATemp."AccountId",
			ATemp."ApplicationCode",
			ATemp."AccountNumber",
			ATemp."PremiseNumber",
			ATemp."InsertionTimeZoneKey",
			ATemp."ClientAccountKey",
			ATemp."InsertionClientKey",
			ATemp."InsertionCustomerKey",
			ATemp."InsertionControlAreaKey",
			ATemp."StartActiveDateTimeUTC",
			ATemp."EndActiveDateTimeUTC",
			ATemp."StartActiveDateTimeLocal",
			ATemp."EndActiveDateTimeLocal",
			now()::timestamp as "StartDateTime",
			NULL,
			TRUE
	FROM ACCOUNT_TEMP ATemp
	JOIN dw."DimAccount" ASrc 
	ON ASrc."AccountKey" = ATemp."AccountKey"
	WHERE         ATemp."AccountKey" IS NOT NULL  
			 AND  (
					COALESCE (ATemp."InsertionClientKey",-1)      != COALESCE (ASrc."ClientKey",-1) 
					OR 
					COALESCE (ATemp."InsertionCustomerKey",-1)    != COALESCE (ASrc."CustomerKey",-1)
				    OR
				    COALESCE (ATemp."InsertionControlAreaKey",-1) != COALESCE (ASrc."ControlAreaKey",-1)
				   );
	
END;
$$ LANGUAGE plpgsql;
































INSERT INTO public."DatabaseVersionHistory" VALUES ('028_DW_ETL_Create_Scripts');drop function dw."stpGetOMARNewData"(integer, timestamp, timestamp);

create or REPLACE function dw."stpGetOMARNewData"("ClientId" integer, "TradeDayUTC" timestamp without time zone, "TransactionDateTimeUTC" timestamp without time zone, "IsoId" integer)
  returns TABLE("CONTROLAREA" int, "CHANNEL" text, "DATE" text, "TIME" text, "VALUE" numeric, "UOM" text, "INTERVAL" text, "STATUS" text, "DSTFLAG" text)
language plpgsql
as $$
DECLARE
    "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("TradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("TradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTC"        TIMESTAMP := "TradeDayUTC" + interval '1' day;
BEGIN

   RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "TradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "ClientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "IsoId"
              AND
                (
                  ("TransactionDateTimeUTC" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("TransactionDateTimeUTC" IS NOT NULL AND (fct."InsertionDateTime" <= "TransactionDateTimeUTC" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "TransactionDateTimeUTC")))
                )
		),
    omar_CTE as
    (
        SELECT
             fct."ControlAreaAlternateKey",
             '1' AS "Channel",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             '1' AS "UOM",
             '60' AS "_INTERVAL",
             'A' as "STATUS",
             'N' AS "DSTFLAG"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM omar_CTE;
END
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('029_DW_Update_OMARNewData_Scripts');

DROP FUNCTION IF EXISTS public."stpMergeDailyFactWeather";

CREATE OR REPLACE FUNCTION public."stpMergeDailyFactWeather"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN



  WITH dw_facts_CTE as
  (
      SELECT
                 "WeatherKey"                    as "dw_WeatherKey",
                 "InsertionDateTime"             as "dw_InsertionDateTime" ,
                 "AgingDateTime"                 as "dw_AgingDateTime",
                 "WeatherObservationId"          as "dw_WeatherObservationId",
                 "StationKey"                    as "dw_StationKey",
                 "FactValueGoalKey"              as "dw_FactValueGoalKey",
                 fct."FactStatusKey"             as "dw_FactStatusKey",
                 "ParentWeatherKey"              as "dw_ParentWeatherkey",
                 "EndDateTimeUTC"                as "dw_EndDateTimeUTC",
                 "EndDateUTCKey"                 as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"                 as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey"            as "dw_RecorderdDateUTCKey",
	             "oC"                            as "dw_oC",
	             "oF"                            as "dw_oF",
	             "Humidity"                      as "dw_Humidity"
	  
      FROM dw."FactWeather" fct
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
	  
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "WeatherObservationId"           as "stg_WeatherObservationId",
            "EndDateTimeUTC"                 as "stg_EndDateTimeUTC",
            "oC"                             as "stg_oC",
            "oF"                             as "stg_oF",
	        "Humidity"                       as "stg_Humidity",
            "StationKey"                     as "stg_StationKey",           
            dateUTC."DateKey"                as "stg_EndDateUTCKey",         
            timeUTC."TimeKey"                as "stg_EndTimeUTCKey",
            recordedDate."DateKey"           as "stg_RecordedDateKey"

      FROM stg."FactWeather" fct      
      JOIN dw."DimWeatherStation" station
        ON station."StationAlternateKey" = fct."ObservationStationId"     
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"     
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" 
  )
  
  INSERT INTO public.facts_temp_weather
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON     dw_fact."dw_WeatherObservationId"       = stg_fact."stg_WeatherObservationId"          
        AND dw_fact."dw_StationKey"                 = stg_fact."stg_StationKey"
        AND dw_fact."dw_EndDateUTCKey"              = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"              = stg_fact."stg_EndTimeUTCKey"
    ;
	
    -- INSERT NEW FACTS
	INSERT INTO dw."FactWeather"(
		"InsertionDateTime",
		"AgingDateTime",
		"WeatherObservationId",
		"StationKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentWeatherKey",
		"EndDateTimeUTC",
		"EndDateUTCKey",
		"EndTimeUTCKey",
		"RecordedDateUTCKey",
		"oC",
		"oF",
		"Humidity"
	)		
    SELECT
           now()::timestamp,
           NULL,
           "stg_WeatherObservationId",
           "stg_StationKey",
           1, --INIT
           1, --CURRENT
           NULL, -- PARENT WEATHER KEY
           "stg_EndDateTimeUTC",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_oC",
           "stg_oF",
	       "stg_Humidity"
		   
    FROM public.facts_temp_weather fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_WeatherKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactWeather" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp_weather fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."WeatherKey" = fct."dw_WeatherKey"
        AND fct."dw_WeatherKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_oC",-1)        != COALESCE (fct."dw_oC",-1)
               OR COALESCE (fct."stg_oF",-1)        != COALESCE (fct."dw_oF",-1)
               OR COALESCE (fct."stg_Humidity",-1)  != COALESCE (fct."dw_Humidity",-1)
            );

    -- INSERT NEW FACTS
	INSERT INTO dw."FactWeather"(
		"InsertionDateTime",
		"AgingDateTime",
		"WeatherObservationId",
		"StationKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentWeatherKey",
		"EndDateTimeUTC",
		"EndDateUTCKey",
		"EndTimeUTCKey",
		"RecordedDateUTCKey",
		"oC",
		"oF",
		"Humidity"
	)
        SELECT
           now()::timestamp,
           NULL,
           "stg_WeatherObservationId",
           "stg_StationKey",
           2, --INIT
           1, --CURRENT
           fct."dw_WeatherKey", -- PARENT WEATHER KEY
           "stg_EndDateTimeUTC",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_oC",
           "stg_oF",
	       "stg_Humidity"

    FROM public.facts_temp_weather fct
    WHERE   fct."dw_WeatherKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
         AND (
                  COALESCE (fct."stg_oC",-1)        != COALESCE (fct."dw_oC",-1)
               OR COALESCE (fct."stg_oF",-1)        != COALESCE (fct."dw_oF",-1)
               OR COALESCE (fct."stg_Humidity",-1)  != COALESCE (fct."dw_Humidity",-1)
            );

  

  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;



INSERT INTO public."DatabaseVersionHistory" VALUES ('030_DW_MergeDailyFactWeather_Create_Script');


create or REPLACE function dw."stpGetOMARNewData"("ClientId" integer, "TradeDayUTC" timestamp without time zone, "TransactionDateTimeUTC" timestamp without time zone, "IsoId" integer)
  returns TABLE("CONTROLAREA" int, "CHANNEL" text, "DATE" text, "TIME" text, "VALUE" numeric, "UOM" text, "INTERVAL" text, "STATUS" text, "DSTFLAG" text)
language plpgsql
as $$
DECLARE
    "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("TradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("TradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTC"        TIMESTAMP := "TradeDayUTC" + interval '1' day;
BEGIN

   RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "TradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "ClientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "IsoId"
              AND
                (
                  ("TransactionDateTimeUTC" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("TransactionDateTimeUTC" IS NOT NULL AND (fct."InsertionDateTime" <= "TransactionDateTimeUTC" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "TransactionDateTimeUTC")))
                )
		),
    omar_CTE as
    (
        SELECT
             fct."ControlAreaAlternateKey",
             '1' AS "Channel",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF"),0) AS "_UsageDLF",
             '1' AS "UOM",
             '60' AS "_INTERVAL",
             'A' as "STATUS",
             'N' AS "DSTFLAG"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM omar_CTE;
END
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('031_DW_Update_OMARNew_Script');

CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	)
    RETURNS TABLE("IntervalId" bigint, 
				  "InsertionDateTime" timestamp without time zone, 
				  "MonthlyRead" numeric, 
				  "Usage" numeric, 
				  "UsageDLF" numeric, 
				  "Demand" numeric, 
				  "DemandDLF" numeric, 
				  "DLP" numeric, 
				  "DLPSum" numeric, 
				  "DLPRation" numeric, 
				  "DLF" numeric, 
				  "StartDateTimeUTC" timestamp without time zone, 
				  "TradeDay" timestamp without time zone, 
				  "StartDateTimeLocal" timestamp without time zone, 
				  "EndDateTimeLocal" timestamp without time zone, 
				  "AccountNumber" integer, 
				  "MeterName" character varying, 
				  "ClientName" character varying,
				  "CustomerName" character varying,
				  "ControlAreaName" character varying,
				  "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
		FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"()
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('032_DW_AddFunction_GetSettlementIntervals');CREATE SCHEMA IF NOT EXISTS etl ;

CREATE OR REPLACE FUNCTION etl."MergeAccountSDPData" () 
RETURNS void AS $$
BEGIN


	INSERT INTO etl.ACCOUNTSDP_TEMP  
	SELECT 
	     ASDPSource."AccountSDPId",
		 AccDest."AccountKey",
		 SDPDest."SDPKey",
		 ASDPSource."StatusDateTime",
		 ASDPSource."StatusId",
		 ASDPSource."StartDateTime",
		 "AccountSDPKey"
		 				
	FROM  stg."AccountSDP" ASDPSource
	LEFT JOIN dw."DimAccount" AccDest
	ON AccDest."AccountAlternateKey" = ASDPSource."AccountId" AND AccDest."ApplicationCode" = 'OMDA' AND AccDest."Current" = TRUE
	LEFT JOIN dw."DimSDP" SDPDest 
	ON SDPDest."SDPAlternateKey" = ASDPSource."SDPId" AND SDPDest."Current" = TRUE		
	LEFT JOIN dw."DimAccountSDPBridge" ASDPDest
	ON ASDPDest."AccountSDPAlternateKey" = ASDPSource."AccountSDPId"  AND ASDPDest."Current" = TRUE ;

   -- INSERT NEW ROWS
	INSERT INTO 
	dw."DimAccountSDPBridge"
	(
		"AccountSDPAlternateKey",
		"StatusDateTime",
		"StatusId",
		"AccountKey",
		"SDPKey",
		"StartDateTime",
		"EndDateTime",
		"Current"
	)
	SELECT 
        "AccountSDPId",
		"StatusDateTime",
		"StatusId",
		"AccountKey",
		"SDPKey",
		"StartDateTime",
		NULL,
		TRUE 
	FROM etl.ACCOUNTSDP_TEMP
	WHERE "AccountSDPKey" IS NULL ;


	-- UPDATE ROWS WITH NO HISTORICAL (NO NEED FOR NOW SINCE WE NEED TO SCD2 ALL CHANGING FIELD)


    -- UPDATE ROWS WITH HISTORICAL (ENDDATETIME UPDATE)
	UPDATE dw."DimAccountSDPBridge" 
	SET 
		"EndDateTime" = now()::timestamp,
		"Current" = FALSE                  
	FROM      etl.ACCOUNTSDP_TEMP 
	WHERE     etl.ACCOUNTSDP_TEMP."AccountSDPKey" IS NOT NULL 
		 AND  etl.ACCOUNTSDP_TEMP."AccountSDPKey" = dw."DimAccountSDPBridge"."AccountSDPKey"
		 AND  (
			 	etl.ACCOUNTSDP_TEMP."StatusDateTime" != dw."DimAccountSDPBridge"."StatusDateTime"
			    OR 
			    etl.ACCOUNTSDP_TEMP."StatusId"       != dw."DimAccountSDPBridge"."StatusId"
			    OR 
			    etl.ACCOUNTSDP_TEMP."AccountKey"     != dw."DimAccountSDPBridge"."AccountKey"
			    OR 
			    etl.ACCOUNTSDP_TEMP."SDPKey"         != dw."DimAccountSDPBridge"."SDPKey"
			   );


	-- INSERT HISTORICAL ROWS
	INSERT INTO 
	dw."DimAccountSDPBridge"
	(
		"AccountSDPAlternateKey",
		"StatusDateTime",
		"StatusId",
		"AccountKey",
		"SDPKey",
		"StartDateTime",
		"EndDateTime",
		"Current"
	)
	SELECT 
	    ASDPTemp."AccountSDPId",
		ASDPTemp."StatusDateTime",
		ASDPTemp."StatusId",
		ASDPTemp."AccountKey",
		ASDPTemp."SDPKey",
		now()::timestamp as "StartDateTime",
		NULL,
		TRUE 
	FROM  etl.ACCOUNTSDP_TEMP ASDPTemp
	JOIN  dw."DimAccountSDPBridge" ASDPSrc 
	ON ASDPSrc."AccountSDPKey" = ASDPTemp."AccountSDPKey"
	WHERE     ASDPTemp."AccountSDPKey" IS NOT NULL 
		  AND  (
			 	ASDPTemp."StatusDateTime" != ASDPSrc."StatusDateTime"
			    OR 
			    ASDPTemp."StatusId"       != ASDPSrc."StatusId"
			    OR
			    ASDPTemp."AccountKey"     != ASDPSrc."AccountKey"
			    OR 
			    ASDPTemp."SDPKey"         != ASDPSrc."SDPKey"
			   );  

END;
$$ LANGUAGE plpgsql;








-- DW TABLES

-- DimAccountSDPBridge
CREATE TABLE dw."DimAccountSDPBridge"
(
    "AccountSDPKey" BIGSERIAL ,
	"AccountSDPAlternateKey" INTEGER NOT NULL,
	"StatusDateTime" TIMESTAMP NOT NULL,
	"StatusId" INTEGER NOT NULL,	
	"AccountKey" INTEGER NOT NULL,
    "SDPKey" INTEGER NOT NULL,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL	
);
COMMENT ON TABLE dw."DimAccountSDPBridge" IS 'AccountSDP Bridge Dimension Table';
CREATE INDEX DimAccountSDPBridge_SDP_Account_1_index ON dw."DimAccountSDPBridge"("SDPKey", "AccountKey", "StatusId", "Current");
CREATE INDEX DimAccountSDPBridge_SDP_Account_2_index ON dw."DimAccountSDPBridge"("AccountSDPAlternateKey", "Current");
CREATE INDEX DimAccountSDPBridge_SDP_Account_3_index ON dw."DimAccountSDPBridge"("AccountSDPAlternateKey", "SDPKey", "AccountKey", "Current");
ALTER TABLE dw."DimAccountSDPBridge" ADD CONSTRAINT FK_AccountSDPBridge_Account FOREIGN KEY ("AccountKey") REFERENCES dw."DimAccount" ("AccountKey");
ALTER TABLE dw."DimAccountSDPBridge" ADD CONSTRAINT FK_AccountSDPBridge_SDP     FOREIGN KEY ("SDPKey")     REFERENCES dw."DimSDP" ("SDPKey");



-- FactVirtualEntities
CREATE TABLE dw."FactVirtualEntities"
(
    "VirtualEntityKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"VirtualEntityConfigId" INT ,
    "VirtualSDPKey" INT ,
    "VirtualMeterKey" INT,
    "SourceChannelKey" INT,
	"VirtualChannelKey" INT,
    "FactValueGoalKey" SMALLINT,
	"FactStatusKey" SMALLINT,
	"ParentVirtualEntityKey" BIGINT,		
    "IsNegative" BOOLEAN,
    "Factor" NUMERIC(18,2)
);
COMMENT ON TABLE dw."FactVirtualEntities" IS 'VirtualEntities Fact Table';
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_SDP           FOREIGN KEY ("VirtualSDPKey")       REFERENCES dw."DimSDP" ("SDPKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_METER         FOREIGN KEY ("VirtualMeterKey")     REFERENCES dw."DimMeter" ("MeterKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_ChanSource    FOREIGN KEY ("SourceChannelKey")    REFERENCES dw."DimChannel" ("ChannelKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_ChanVirtual   FOREIGN KEY ("VirtualChannelKey")   REFERENCES dw."DimChannel" ("ChannelKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_FactValueGoal FOREIGN KEY ("FactValueGoalKey")    REFERENCES dw."DimFactValueGoal" ("FactValueGoalKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_FactStatus    FOREIGN KEY ("FactStatusKey")       REFERENCES dw."DimFactStatus" ("FactStatusKey");

CREATE INDEX VirtualEntities_1_index ON dw."FactVirtualEntities"("VirtualEntityConfigId", "FactStatusKey");
CREATE INDEX VirtualEntities_2_index ON dw."FactVirtualEntities"("VirtualSDPKey", "VirtualMeterKey", "SourceChannelKey", "VirtualChannelKey", "FactStatusKey");
CREATE INDEX VirtualEntities_3_index ON dw."FactVirtualEntities"("VirtualEntityConfigId", "VirtualSDPKey", "VirtualMeterKey", "FactStatusKey");



-- STAGING TABLES

-- Stg_AccountSDP
CREATE TABLE stg."AccountSDP"
(    
	"AccountSDPId" INTEGER,
	"AccountId" INTEGER,
    "SDPId" INTEGER,
	"StatusDateTime" TIMESTAMP,
	"StatusId" INTEGER,		
    "StartDateTime" TIMESTAMP       
);

-- FactVirtualEntities
CREATE TABLE stg."FactVirtualEntities"
(    
	"VirtualEntityConfigId" INT ,
    "VirtualSDPId" INT ,
    "VirtualMeterId" TEXT,
    "SourceChannelId" TEXT,
	"VirtualChannelId" TEXT,    		
    "IsNegative" BOOLEAN,
    "Factor" NUMERIC(18,2)
);



-- TEMPORARY TABLES 

CREATE TABLE etl.ACCOUNTSDP_TEMP
(
    "AccountSDPId" INTEGER,
    "AccountKey" INTEGER,
    "SDPKey" INTEGER,
    "StatusDateTime" TIMESTAMP,
    "StatusId" INTEGER,
    "StartDateTime" TIMESTAMP,
    "AccountSDPKey" BIGINT    
);
CREATE INDEX ON etl.ACCOUNTSDP_TEMP ("AccountSDPKey");
CREATE INDEX ON etl.ACCOUNTSDP_TEMP ("AccountSDPKey","StatusDateTime","StatusId","AccountKey","SDPKey");





CREATE TABLE etl.facts_temp_virtual
(
    "dw_VirtualEntityKey" bigint,
    "dw_VirtualEntityConfigId" INTEGER,
    "stg_VirtualEntityConfigId" INTEGER,
    "stg_SDPKey" INTEGER,
    "stg_MeterKey" INTEGER,
    "stg_SourceChannelKey" BIGINT,
    "stg_VirtualChannelKey" BIGINT,
    "stg_IsNegative" BOOLEAN,
    "stg_Factor" numeric(18,2)     
) ;
CREATE INDEX ON etl.facts_temp_virtual ("stg_VirtualEntityConfigId","dw_VirtualEntityKey","dw_VirtualEntityConfigId");



CREATE OR REPLACE FUNCTION etl."stpMergeVirtualFactEntities"()
RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
BEGIN
   
  WITH dw_facts_CTE as
  (
      SELECT 
			"VirtualEntityKey"       as "dw_VirtualEntityKey",
			"VirtualEntityConfigId"  as "dw_VirtualEntityConfigId"
		FROM dw."FactVirtualEntities" fct
	    JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'	  
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "VirtualEntityConfigId"  as "stg_VirtualEntityConfigId",
            "SDPKey"                 as "stg_SDPKey",
            "MeterKey"               as "stg_MeterKey",
            chanSource."ChannelKey"  as "stg_SourceChannelKey",
	        chanVirtual."ChannelKey" as "stg_VirtualChannelKey",
            "IsNegative"             as "stg_IsNegative",           
            "Factor"                 as "stg_Factor"     
          

      FROM stg."FactVirtualEntities" fct      
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey"     = fct."VirtualSDPId"    AND sdp."Current" = True   -- AND sdp."IsVirtual" =  True    
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."VirtualMeterId"  AND meter."ApplicationCode" = 'OMDA' AND meter."Current" = True -- AND meter."IsVirtual" = True     
      JOIN dw."DimChannel" chanSource
        ON chanSource."ChannelAlternateKey" = fct."SourceChannelId" AND chanSource."ApplicationCode" = 'OMDA'  AND chanSource."Current" = True -- AND chanSource."IsVirtual" = False
      JOIN dw."DimChannel" chanVirtual
        ON chanVirtual."ChannelAlternateKey" = fct."VirtualChannelId" AND chanVirtual."ApplicationCode" = 'OMDA'  AND chanVirtual."Current" = True -- AND chanVirtual."IsVirtual" = True	  
  )
  INSERT INTO etl.facts_temp_virtual
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON  dw_fact."dw_VirtualEntityConfigId"  = stg_fact."stg_VirtualEntityConfigId" ;



   -- INSERT NEW FACTS
    INSERT INTO dw."FactVirtualEntities"(
		"InsertionDateTime",
		"AgingDateTime",
		"VirtualEntityConfigId",
		"VirtualSDPKey",
		"VirtualMeterKey",
		"SourceChannelKey",
		"VirtualChannelKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentVirtualEntityKey",
		"IsNegative",
		"Factor"
	)
    SELECT
           now()::timestamp,
           NULL,
           "stg_VirtualEntityConfigId",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_SourceChannelKey",
           "stg_VirtualChannelKey",
           1, -- INIT
		   1, -- STATUS,
		   NULL,
		   "stg_IsNegative",
		   "stg_Factor"

    FROM etl.facts_temp_virtual fct
    WHERE     fct."stg_VirtualEntityConfigId"  IS NOT NULL
          AND fct."dw_VirtualEntityKey"   IS NULL ;


 -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactVirtualEntities" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_virtual fct
   WHERE    dw_fct."VirtualEntityKey"   = fct."dw_VirtualEntityKey"
        AND fct."stg_VirtualEntityConfigId" IS NOT NULL
        AND fct."dw_VirtualEntityKey"       IS NOT NULL
        AND (
                             fct."stg_SDPKey"              !=  dw_fct."VirtualSDPKey"
               OR            fct."stg_MeterKey"            !=  dw_fct."VirtualMeterKey"
               OR            fct."stg_SourceChannelKey"    !=  dw_fct."SourceChannelKey"			
               OR            fct."stg_VirtualChannelKey"   !=  dw_fct."VirtualChannelKey"
               OR  COALESCE (fct."stg_IsNegative",FALSE)   != COALESCE (dw_fct."IsNegative",FALSE)
               OR  COALESCE (fct."stg_Factor",0)           != COALESCE (dw_fct."Factor",0)
            );


    -- INSERT NEW FACTS
    INSERT INTO dw."FactVirtualEntities"(
		"InsertionDateTime",
		"AgingDateTime",
		"VirtualEntityConfigId",
		"VirtualSDPKey",
		"VirtualMeterKey",
		"SourceChannelKey",
		"VirtualChannelKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentVirtualEntityKey",
		"IsNegative",
		"Factor"
	)
    SELECT
           now()::timestamp,
           NULL,
           "stg_VirtualEntityConfigId",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_SourceChannelKey",
           "stg_VirtualChannelKey",
           2, -- NEW
		   1, -- STATUS,
		   dw_fct."VirtualEntityKey",
		   "stg_IsNegative",
		   "stg_Factor"

    FROM etl.facts_temp_virtual fct
    JOIN dw."FactVirtualEntities" dw_fct
	ON dw_fct."VirtualEntityKey"   = fct."dw_VirtualEntityKey"
	WHERE fct."stg_VirtualEntityConfigId" IS NOT NULL
	  AND fct."dw_VirtualEntityKey"       IS NOT NULL
      AND (
                             fct."stg_SDPKey"              !=  dw_fct."VirtualSDPKey"
               OR            fct."stg_MeterKey"            !=  dw_fct."VirtualMeterKey"
               OR            fct."stg_SourceChannelKey"    !=  dw_fct."SourceChannelKey"			
               OR            fct."stg_VirtualChannelKey"   !=  dw_fct."VirtualChannelKey"
               OR  COALESCE (fct."stg_IsNegative",FALSE)   != COALESCE (dw_fct."IsNegative",FALSE)
               OR  COALESCE (fct."stg_Factor",0)           != COALESCE (dw_fct."Factor",0)
            );
    

    -- CANCEL NOT FOUND VIRTUAL ENTITIES
	UPDATE dw."FactVirtualEntities" dw_fct
	      SET "FactStatusKey" = 2,
		      "AgingDateTime" = now()::timestamp			  
	FROM   etl.facts_temp_virtual fct
	WHERE    dw_fct."VirtualEntityKey"   = fct."dw_VirtualEntityKey"
        AND fct."dw_VirtualEntityKey"        IS NOT NULL
		AND fct."dw_VirtualEntityConfigId"   IS NOT NULL
        AND fct."stg_VirtualEntityConfigId"  IS  NULL;

    -- INSERT CANCELLED NEW FACTS
    INSERT INTO dw."FactVirtualEntities"(
		"InsertionDateTime",
		"AgingDateTime",
		"VirtualEntityConfigId",
		"VirtualSDPKey",
		"VirtualMeterKey",
		"SourceChannelKey",
		"VirtualChannelKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentVirtualEntityKey",
		"IsNegative",
		"Factor"
	)
    SELECT
           now()::timestamp,
           NULL,
           "VirtualEntityConfigId",
           "VirtualSDPKey",
           "VirtualMeterKey",
           "SourceChannelKey",
           "VirtualChannelKey",
           3, -- CANCEL
		   2, -- OLD,
		   "VirtualEntityKey",
		   "IsNegative",
		   "Factor"
    FROM etl.facts_temp_virtual fct
    JOIN dw."FactVirtualEntities" dw_fct
	  ON dw_fct."VirtualEntityKey"   = fct."dw_VirtualEntityKey"
	WHERE   fct."dw_VirtualEntityKey"        IS NOT NULL
		AND fct."dw_VirtualEntityConfigId"   IS NOT NULL
        AND fct."stg_VirtualEntityConfigId"  IS  NULL;
	

  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;











INSERT INTO public."DatabaseVersionHistory" VALUES ('033_DW_ETL_Virtuals_Entities_Create_Scripts');CREATE SCHEMA IF NOT EXISTS etl ;


-- TEMPORARY TABLES

DROP TABLE IF EXISTS public.account_temp;
DROP TABLE IF EXISTS public.facts_temp_sett;
DROP TABLE IF EXISTS public.facts_temp_weather;
DROP TABLE IF EXISTS public.meter_temp;


CREATE TABLE etl.account_temp
(
    "AccountId" integer,
    "CustomerId" integer,
    "CustomerName" character varying(256) COLLATE pg_catalog."default",
    "CustomerAlternateId" character varying COLLATE pg_catalog."default",
    "ClientId" integer,
    "InsertionClientKey" integer,
    "AccountNumber" character varying(50) COLLATE pg_catalog."default",
    "PremiseNumber" character varying(5) COLLATE pg_catalog."default",
    "ControlAreaId" integer,
    "InsertionControlAreaKey" smallint,
    "TimeZoneId" integer,
    "InsertionTimeZoneKey" smallint,
    "ClientAccountKey" character varying(100) COLLATE pg_catalog."default",
    "ApplicationCode" character varying(4) COLLATE pg_catalog."default",
    "StartActiveDateTimeUTC" timestamp without time zone,
    "EndActiveDateTimeUTC" timestamp without time zone,
    "StartActiveDateTimeLocal" timestamp without time zone,
    "EndActiveDateTimeLocal" timestamp without time zone,
    "StartDateTime" timestamp without time zone,
    "AccountKey" integer,
    "ClientKey" integer,
    "InsertionCustomerKey" integer
)
WITH (
    OIDS = FALSE
)
TABLESPACE pg_default;

ALTER TABLE etl.account_temp
    OWNER to postgres;

CREATE INDEX ON etl.account_temp ("AccountKey","InsertionClientKey","InsertionCustomerKey","InsertionControlAreaKey");



CREATE TABLE etl.meter_temp
(
    "MeterId" integer,
    "MeterTypeId" integer,
    "Name" character varying(50) COLLATE pg_catalog."default",
    "DeviceCode" character varying(50) COLLATE pg_catalog."default",
	"MeterAlternateKey" character varying(50) COLLATE pg_catalog."default",
    "IntervalsPerHour" integer,
    "IsDSTEnabled" boolean,
    "TimeZoneId" integer,    
    "IsVirtual" boolean,
    "DSTRegionId" integer,
    "FirstEndDateTimeUTC" timestamp without time zone,
    "LastEndDateTimeUTC" timestamp without time zone,
    "Manufacturer" character varying(50) COLLATE pg_catalog."default",
    "Type" character varying(50) COLLATE pg_catalog."default",
    "ApplicationCode" character varying(4) COLLATE pg_catalog."default",
    "MeterSDP" character varying(100) COLLATE pg_catalog."default",
    "MeterSDPStartDateTime" timestamp without time zone,
    "MeterSDPStopDateTime" timestamp without time zone,
    "StartDateTime" timestamp without time zone,    
	"InsertionTimeZoneKey" smallint,
	"MeterKey" integer,
    "Current" boolean,
    "TimeZoneKey" smallint
)
WITH (
    OIDS = FALSE
)
TABLESPACE pg_default;

ALTER TABLE etl.meter_temp
    OWNER to postgres;


CREATE INDEX ON etl.meter_temp ("MeterKey","InsertionTimeZoneKey","MeterSDP");





CREATE TABLE etl.facts_temp_sett
(
    "dw_IntervalKey" bigint,
    "dw_InsertionDateTime" timestamp without time zone,
    "dw_MonthlyRead" numeric(28,4),
    "dw_Usage" numeric(28,4),
    "dw_UsageDLF" numeric(28,4),
    "dw_Demand" numeric(28,4),
    "dw_DemandDLF" numeric(28,4),
    "dw_DLP" numeric(18,6),
    "dw_DLPSum" numeric(18,6),
    "dw_DLPRation" numeric(18,6),
    "dw_DLF" numeric(18,7),
    "dw_StartDateTimeUTC" timestamp without time zone,
    "dw_EndDateTimeUTC" timestamp without time zone,
    "dw_StartDateTimeLocal" timestamp without time zone,
    "dw_EndDateTimeLocal" timestamp without time zone,
    "dw_AccountKey" integer,
    "dw_SDPKey" integer,
    "dw_MeterKey" integer,
    "dw_ChannelKey" integer,
    "dw_OriginConsumptionKey" smallint,
    "dw_FactValueGoalKey" smallint,
    "dw_ServiceTypeKey" smallint,
    "dw_ParentIntervalKey" bigint,
    "dw_FactStatusKey" smallint,
    "dw_EndDateLocalKey" integer,
    "dw_EndTimeLocalKey" smallint,
    "dw_EndDateUTCKey" integer,
    "dw_EndTimeUTCKey" smallint,
    "dw_RecordedDateUTCKey" integer,
    "dw_ClientKey" integer,
    "stg_MonthlyRead" numeric(28,4),
    "stg_Usage" numeric(28,4),
    "stg_UsageDLF" numeric(28,4),
    "stg_Demand" numeric(28,4),
    "stg_DemandDLF" numeric(28,4),
    "stg_DLP" numeric(18,6),
    "stg_DLPSum" numeric(18,6),
    "stg_DLPRation" numeric(18,6),
    "stg_DLF" numeric(18,7),
    "stg_StartDateTimeUTC" timestamp without time zone,
    "stg_EndDateTimeUTC" timestamp without time zone,
    "stg_StartDateTimeLocal" timestamp without time zone,
    "stg_EndDateTimeLocal" timestamp without time zone,
    "stg_ClientKey" integer,
    "stg_AccountKey" integer,
    "stg_SDPKey" integer,
    "stg_MeterKey" integer,
    "stg_ChannelKey" integer,
    "stg_OriginConsumptionKey" smallint,
    "stg_OriginConsumptionCode" character varying(8) COLLATE pg_catalog."default",
    "stg_ServiceTypeKey" smallint,
    "stg_EndDateLocalKey" integer,
    "stg_EndDateUTCKey" integer,
    "stg_EndTimeLocalKey" smallint,
    "stg_EndTimeUTCKey" smallint,
    "stg_RecordedDateKey" integer
)
WITH (
    OIDS = FALSE
)
TABLESPACE pg_default;

ALTER TABLE etl.facts_temp_sett
    OWNER to postgres;


CREATE INDEX "facts_temp_sett_stg_EndDateUTCKey_dw_IntervalKey_idx"
    ON etl.facts_temp_sett USING btree
    ("stg_EndDateUTCKey", "dw_IntervalKey")
    TABLESPACE pg_default;




CREATE TABLE etl.facts_temp_weather
(
    "dw_WeatherKey" bigint,
    "dw_InsertionDateTime" timestamp without time zone,
    "dw_AgingDateTime" timestamp without time zone,
    "dw_WeatherObservationId" bigint,
    "dw_StationKey" integer,
    "dw_FactValueGoalKey" smallint,
    "dw_FactStatusKey" smallint,
    "dw_ParentWeatherkey" bigint,
    "dw_EndDateTimeUTC" timestamp without time zone,
    "dw_EndDateUTCKey" integer,
    "dw_EndTimeUTCKey" smallint,
    "dw_RecorderdDateUTCKey" integer,
    "dw_oC" integer,
    "dw_oF" integer,
    "dw_Humidity" integer,
    "stg_WeatherObservationId" bigint,
    "stg_EndDateTimeUTC" timestamp without time zone,
    "stg_oC" integer,
    "stg_oF" integer,
    "stg_Humidity" integer,
    "stg_StationKey" integer,
    "stg_EndDateUTCKey" integer,
    "stg_EndTimeUTCKey" smallint,
    "stg_RecordedDateKey" integer
)
WITH (
    OIDS = FALSE
)
TABLESPACE pg_default;

ALTER TABLE etl.facts_temp_weather
    OWNER to postgres;


CREATE INDEX "facts_temp_weather_stg_EndDateUTCKey_dw_WeatherKey_idx"
    ON etl.facts_temp_weather USING btree
    ("stg_EndDateUTCKey", "dw_WeatherKey")
    TABLESPACE pg_default;







---------------------------------------------------------------------------------------------------------------------------------
DROP FUNCTION IF EXISTS public."stpMergeDailyFactWeather";
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactWeather";

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactWeather"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN



  WITH dw_facts_CTE as
  (
      SELECT
                 "WeatherKey"                    as "dw_WeatherKey",
                 "InsertionDateTime"             as "dw_InsertionDateTime" ,
                 "AgingDateTime"                 as "dw_AgingDateTime",
                 "WeatherObservationId"          as "dw_WeatherObservationId",
                 "StationKey"                    as "dw_StationKey",
                 "FactValueGoalKey"              as "dw_FactValueGoalKey",
                 fct."FactStatusKey"             as "dw_FactStatusKey",
                 "ParentWeatherKey"              as "dw_ParentWeatherkey",
                 "EndDateTimeUTC"                as "dw_EndDateTimeUTC",
                 "EndDateUTCKey"                 as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"                 as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey"            as "dw_RecorderdDateUTCKey",
	             "oC"                            as "dw_oC",
	             "oF"                            as "dw_oF",
	             "Humidity"                      as "dw_Humidity"
	  
      FROM dw."FactWeather" fct
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
	  
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "WeatherObservationId"           as "stg_WeatherObservationId",
            "EndDateTimeUTC"                 as "stg_EndDateTimeUTC",
            "oC"                             as "stg_oC",
            "oF"                             as "stg_oF",
	        "Humidity"                       as "stg_Humidity",
            "StationKey"                     as "stg_StationKey",           
            dateUTC."DateKey"                as "stg_EndDateUTCKey",         
            timeUTC."TimeKey"                as "stg_EndTimeUTCKey",
            recordedDate."DateKey"           as "stg_RecordedDateKey"

      FROM stg."FactWeather" fct      
      JOIN dw."DimWeatherStation" station
        ON station."StationAlternateKey" = fct."ObservationStationId"     
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"     
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" 
  )
  
  INSERT INTO etl.facts_temp_weather
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON     dw_fact."dw_WeatherObservationId"       = stg_fact."stg_WeatherObservationId"          
        AND dw_fact."dw_StationKey"                 = stg_fact."stg_StationKey"
        AND dw_fact."dw_EndDateUTCKey"              = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"              = stg_fact."stg_EndTimeUTCKey"
    ;
	
    -- INSERT NEW FACTS
	INSERT INTO dw."FactWeather"(
		"InsertionDateTime",
		"AgingDateTime",
		"WeatherObservationId",
		"StationKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentWeatherKey",
		"EndDateTimeUTC",
		"EndDateUTCKey",
		"EndTimeUTCKey",
		"RecordedDateUTCKey",
		"oC",
		"oF",
		"Humidity"
	)		
    SELECT
           now()::timestamp,
           NULL,
           "stg_WeatherObservationId",
           "stg_StationKey",
           1, --INIT
           1, --CURRENT
           NULL, -- PARENT WEATHER KEY
           "stg_EndDateTimeUTC",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_oC",
           "stg_oF",
	       "stg_Humidity"
		   
    FROM etl.facts_temp_weather fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_WeatherKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactWeather" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_weather fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."WeatherKey" = fct."dw_WeatherKey"
        AND fct."dw_WeatherKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_oC",-1)        != COALESCE (fct."dw_oC",-1)
               OR COALESCE (fct."stg_oF",-1)        != COALESCE (fct."dw_oF",-1)
               OR COALESCE (fct."stg_Humidity",-1)  != COALESCE (fct."dw_Humidity",-1)
            );

    -- INSERT NEW FACTS
	INSERT INTO dw."FactWeather"(
		"InsertionDateTime",
		"AgingDateTime",
		"WeatherObservationId",
		"StationKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentWeatherKey",
		"EndDateTimeUTC",
		"EndDateUTCKey",
		"EndTimeUTCKey",
		"RecordedDateUTCKey",
		"oC",
		"oF",
		"Humidity"
	)
        SELECT
           now()::timestamp,
           NULL,
           "stg_WeatherObservationId",
           "stg_StationKey",
           2, --INIT
           1, --CURRENT
           fct."dw_WeatherKey", -- PARENT WEATHER KEY
           "stg_EndDateTimeUTC",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_oC",
           "stg_oF",
	       "stg_Humidity"

    FROM etl.facts_temp_weather fct
    WHERE   fct."dw_WeatherKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
         AND (
                  COALESCE (fct."stg_oC",-1)        != COALESCE (fct."dw_oC",-1)
               OR COALESCE (fct."stg_oF",-1)        != COALESCE (fct."dw_oF",-1)
               OR COALESCE (fct."stg_Humidity",-1)  != COALESCE (fct."dw_Humidity",-1)
            );

  

  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;


-----------------------------------------------------------------------

DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals_SETT";
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT";


CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

  -- CANCEL UNEXISTANTS FACTS
  UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;

   INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
   SELECT
           now()::timestamp,
	   now()::timestamp,
           "dw_MonthlyRead",
           "dw_Usage",
           "dw_UsageDLF",
           "dw_Demand",
           "dw_DemandDLF",
           "dw_DLP",
           "dw_DLPSum",
           "dw_DLPRation",
           "dw_DLF",
           "dw_StartDateTimeUTC",
           "dw_EndDateTimeUTC",
           "dw_StartDateTimeLocal",
           "dw_EndDateTimeLocal",
           "dw_AccountKey",
           "dw_SDPKey",
           "dw_MeterKey",
           "dw_ChannelKey",
           "dw_OriginConsumptionKey",
           3,
           "dw_ServiceTypeKey",
           "dw_ParentIntervalKey",
           2,
           "dw_EndDateLocalKey",
           "dw_EndTimeLocalKey",
           "dw_EndDateUTCKey",
           "dw_EndTimeUTCKey",
           "dw_RecordedDateUTCKey"
   FROM etl.facts_temp_sett fct
   WHERE    fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;




  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

---------------------------------------------------------------

CREATE OR REPLACE FUNCTION etl."MergeAccountData"()
RETURNS void
LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
AS $BODY$

BEGIN

INSERT INTO  etl.ACCOUNT_TEMP  
	SELECT ACC_TEMP.*, Cust."CustomerKey" as "InsertionCustomerKey"
	FROM 
	(
			SELECT 
				"AccountId",
				"CustomerId",
				"CustomerName",
				CASE 
					WHEN  ASrc."ApplicationCode"= 'OMDA'  THEN "CustomerId"::text
					ELSE "CustomerName"
				END AS "CustomerAlternateId",
				"ClientId",
				CL."ClientKey" as "InsertionClientKey",
				ASrc."AccountNumber",
				ASrc."PremiseNumber",
				"ControlAreaId",
				CA."ControlAreaKey" as "InsertionControlAreaKey",
				"TimeZoneId",
				TZ."TimeZoneKey" as "InsertionTimeZoneKey",
				ASrc."ClientAccountKey",
				ASrc."ApplicationCode",
				ASrc."StartActiveDateTimeUTC",
				ASrc."EndActiveDateTimeUTC",
				ASrc."StartActiveDateTimeLocal",
				ASrc."EndActiveDateTimeLocal",
				ASrc."StartDateTime",
				ADes."AccountKey",
				ADes."ClientKey"      

		FROM stg."Account" ASrc
		LEFT JOIN dw."DimAccount" ADes
		ON ASrc."AccountId" = ADes."AccountAlternateKey"  AND ASrc."ApplicationCode" = ADes."ApplicationCode" AND ADes."Current" = TRUE
		LEFT JOIN dw."DimClient" CL
		ON CL."ClientAlternateKey" = ASrc."ClientId" AND CL."Current" =  TRUE
		LEFT JOIN dw."DimControlArea" CA
		ON CA."ControlAreaAlternateKey" = ASrc."ControlAreaId"
		LEFT JOIN dw."DimTimeZone" TZ
		ON TZ."TimeZoneAlternateKey" =  ASrc."TimeZoneId"
	) ACC_TEMP
	LEFT JOIN dw."DimCustomer" Cust
	ON  Cust."CustomerAlternateKey" = ACC_TEMP."CustomerAlternateId" AND Cust."Current" =  TRUE ;

	-- INSERT NEW ROWS
	INSERT INTO dw."DimAccount"(
		"AccountAlternateKey",
		"ApplicationCode",
		"AccountNumber",
		"PremiseNumber",
		"TimeZoneKey",
		"ClientAccountKey",
		"ClientKey",
		"CustomerKey",
		"ControlAreaKey",
		"StartActiveDateTimeUTC",
		"EndActiveDateTimeUTC",
		"StartActiveDateTimeLocal",
		"EndActiveDateTimeLocal",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
			"AccountId",
			"ApplicationCode",
			"AccountNumber",
			"PremiseNumber",
			"InsertionTimeZoneKey",
			"ClientAccountKey",
			"InsertionClientKey",
			"InsertionCustomerKey",
			"InsertionControlAreaKey",
			"StartActiveDateTimeUTC",
			"EndActiveDateTimeUTC",
			"StartActiveDateTimeLocal",
			"EndActiveDateTimeLocal",
			"StartDateTime",
			NULL,
			TRUE
	FROM etl.ACCOUNT_TEMP
	WHERE "AccountKey" IS NULL ;

	-- UPDATE ROWS WITH NO HISTORICAL
	UPDATE dw."DimAccount"

		SET     	
			"ApplicationCode"= etl.ACCOUNT_TEMP."ApplicationCode",
			"AccountNumber"= etl.ACCOUNT_TEMP."AccountNumber",
			"PremiseNumber"= etl.ACCOUNT_TEMP."PremiseNumber",
			"TimeZoneKey"= etl.ACCOUNT_TEMP."InsertionTimeZoneKey",
			"ClientAccountKey"= etl.ACCOUNT_TEMP."ClientAccountKey",
			"ClientKey"= etl.ACCOUNT_TEMP."InsertionClientKey",
			"CustomerKey"= etl.ACCOUNT_TEMP."InsertionCustomerKey",
			"ControlAreaKey"= etl.ACCOUNT_TEMP."InsertionControlAreaKey",
			"StartActiveDateTimeUTC"= etl.ACCOUNT_TEMP."StartActiveDateTimeUTC",
			"EndActiveDateTimeUTC"= etl.ACCOUNT_TEMP."EndActiveDateTimeUTC",
			"StartActiveDateTimeLocal"= etl.ACCOUNT_TEMP."StartActiveDateTimeLocal",
			"EndActiveDateTimeLocal"= etl.ACCOUNT_TEMP."EndActiveDateTimeLocal"

	FROM     etl.ACCOUNT_TEMP
	WHERE    etl.ACCOUNT_TEMP."AccountKey" IS NOT NULL  
	      AND     etl.ACCOUNT_TEMP."AccountKey"              = dw."DimAccount"."AccountKey"
		  AND    COALESCE(etl.ACCOUNT_TEMP."InsertionClientKey",0)      = COALESCE(dw."DimAccount"."ClientKey",0)
		  AND    COALESCE(etl.ACCOUNT_TEMP."InsertionCustomerKey",0)    = COALESCE(dw."DimAccount"."CustomerKey",0)
		  AND    COALESCE(etl.ACCOUNT_TEMP."InsertionControlAreaKey",0) = COALESCE(dw."DimAccount"."ControlAreaKey",0) ;

	-- UPDATE ROWS WITH HISTORICAL (ENDDATETIME UPDATE)
	UPDATE dw."DimAccount"
	SET 
		"EndDateTime" = now()::timestamp,
		"Current" = FALSE                  
	FROM  etl.ACCOUNT_TEMP 
	WHERE    etl.ACCOUNT_TEMP."AccountKey" IS NOT NULL 
	      AND  etl.ACCOUNT_TEMP."AccountKey" = dw."DimAccount"."AccountKey"
		  AND  (
			  	COALESCE (etl.ACCOUNT_TEMP."InsertionClientKey",-1)      != COALESCE (dw."DimAccount"."ClientKey",-1) 
			    OR 
				COALESCE (etl.ACCOUNT_TEMP."InsertionCustomerKey",-1)    != COALESCE (dw."DimAccount"."CustomerKey",-1)
			    OR
			    COALESCE (etl.ACCOUNT_TEMP."InsertionControlAreaKey",-1) != COALESCE (dw."DimAccount"."ControlAreaKey",-1)
		       );

	-- INSERT HISTORICAL ROWS
	INSERT INTO dw."DimAccount"(
		"AccountAlternateKey",
		"ApplicationCode",
		"AccountNumber",
		"PremiseNumber",
		"TimeZoneKey",
		"ClientAccountKey",
		"ClientKey",
		"CustomerKey",
		"ControlAreaKey",
		"StartActiveDateTimeUTC",
		"EndActiveDateTimeUTC",
		"StartActiveDateTimeLocal",
		"EndActiveDateTimeLocal",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
			ATemp."AccountId",
			ATemp."ApplicationCode",
			ATemp."AccountNumber",
			ATemp."PremiseNumber",
			ATemp."InsertionTimeZoneKey",
			ATemp."ClientAccountKey",
			ATemp."InsertionClientKey",
			ATemp."InsertionCustomerKey",
			ATemp."InsertionControlAreaKey",
			ATemp."StartActiveDateTimeUTC",
			ATemp."EndActiveDateTimeUTC",
			ATemp."StartActiveDateTimeLocal",
			ATemp."EndActiveDateTimeLocal",
			now()::timestamp as "StartDateTime",
			NULL,
			TRUE
	FROM etl.ACCOUNT_TEMP ATemp
	JOIN dw."DimAccount" ASrc 
	ON ASrc."AccountKey" = ATemp."AccountKey"
	WHERE         ATemp."AccountKey" IS NOT NULL  
			 AND  (
					COALESCE (ATemp."InsertionClientKey",-1)      != COALESCE (ASrc."ClientKey",-1) 
					OR 
					COALESCE (ATemp."InsertionCustomerKey",-1)    != COALESCE (ASrc."CustomerKey",-1)
				    OR
				    COALESCE (ATemp."InsertionControlAreaKey",-1) != COALESCE (ASrc."ControlAreaKey",-1)
				   );
	
END;
$BODY$;

ALTER FUNCTION etl."MergeAccountData"()
    OWNER TO postgres;




CREATE OR REPLACE FUNCTION etl."MergeMeterData"()
    RETURNS void
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
AS $BODY$

BEGIN
	    INSERT INTO etl.METER_TEMP  	
	    SELECT MS.*, TZ."TimeZoneKey" as "InsertionTimeZoneKey", MD."MeterKey", MD."Current",MD."TimeZoneKey"
		FROM 
	    (
			 SELECT 
						"MeterId",
						"MeterTypeId",
						MS."Name",
						MS."DeviceCode",
						CASE 
							WHEN MS."ApplicationCode" = 'OMDA' THEN MS."MeterId"::text 
							WHEN MS."ApplicationCode" = 'SETT' THEN MS."DeviceCode"
						END AS "MeterAlternateKey",
						MS."IntervalsPerHour",
						MS."IsDSTEnabled",
						MS."TimeZoneId",
						MS."IsVirtual",
						"DSTRegionId",
						MS."FirstEndDateTimeUTC",
						MS."LastEndDateTimeUTC",
						MS."Manufacturer",
						"Type",
						MS."ApplicationCode",
						MS."MeterSDP",
						MS."MeterSDPStartDateTime",
						MS."MeterSDPStopDateTime",								
						MS."StartDateTime"
			FROM  stg."Meter" MS
		) AS  MS
		LEFT JOIN dw."DimTimeZone" TZ
		ON TZ."TimeZoneAlternateKey" = MS."TimeZoneId"
		LEFT JOIN dw."DimMeter" MD
		ON MD."MeterAlternateKey" = MS."MeterAlternateKey" AND  MD."ApplicationCode" = MS."ApplicationCode" AND MD."Current" = TRUE ;


	-- INSERT NEW ROWS
	INSERT INTO 
	
	dw."DimMeter"(
		"MeterAlternateKey",
		"ApplicationCode",
		"Name",
		"DeviceCode",
		"IntervalsPerHour",
		"IsDSTEnabled",
		"IsVirtual",
		"MeterType",
		"Manufacturer",
		"FirstEndDateTimeUTC",
		"LastEndDateTimeUTC",
		"MeterSDP",
		"MeterSDPStartDateTime",
		"MeterSDPStopDateTime",	
		"TimeZoneKey",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
		"MeterAlternateKey",
		"ApplicationCode",
		"Name",
		"DeviceCode",
		"IntervalsPerHour",
		"IsDSTEnabled",
		"IsVirtual",
		"Type",
		"Manufacturer",
		"FirstEndDateTimeUTC",
		"LastEndDateTimeUTC",
		"MeterSDP",
		"MeterSDPStartDateTime",
		"MeterSDPStopDateTime",	
		"InsertionTimeZoneKey",
		"StartDateTime",
		NULL,
		TRUE 
	FROM etl.METER_TEMP
	WHERE "MeterKey" IS NULL ;

	-- UPDATE ROWS WITH NO HISTORICAL
	UPDATE dw."DimMeter" 
	SET 
		"Name" = etl.METER_TEMP."Name",
		"DeviceCode" = etl.METER_TEMP."DeviceCode",
		"IntervalsPerHour" = etl.METER_TEMP."IntervalsPerHour",
		"IsDSTEnabled" = etl.METER_TEMP."IsDSTEnabled",
		"IsVirtual" = etl.METER_TEMP."IsVirtual",
		"MeterType" = etl.METER_TEMP."Type",
		"Manufacturer" = etl.METER_TEMP."Manufacturer",
		"FirstEndDateTimeUTC" = etl.METER_TEMP."FirstEndDateTimeUTC",
		"LastEndDateTimeUTC" = etl.METER_TEMP."LastEndDateTimeUTC",
		"MeterSDP" = etl.METER_TEMP."MeterSDP",
		"MeterSDPStartDateTime" = etl.METER_TEMP."MeterSDPStartDateTime",
		"MeterSDPStopDateTime" = etl.METER_TEMP."MeterSDPStopDateTime"		
	FROM etl.METER_TEMP 
	WHERE     etl.METER_TEMP."MeterKey" IS NOT NULL 
	     AND  etl.METER_TEMP."MeterKey" =  dw."DimMeter"."MeterKey"
		 AND  COALESCE(etl.METER_TEMP."InsertionTimeZoneKey",0) = COALESCE(dw."DimMeter"."TimeZoneKey",0)
		 AND  COALESCE(etl.METER_TEMP."MeterSDP",'-1') = COALESCE(dw."DimMeter"."MeterSDP",'-1')		 
		 AND  etl.METER_TEMP."Current" = TRUE;

	-- UPDATE ROWS WITH HISTORICAL (ENDDATETIME UPDATE)
	UPDATE dw."DimMeter" 
	SET 
		"EndDateTime" = now()::timestamp,
		"Current" = FALSE                  
	FROM etl.METER_TEMP 
	WHERE     etl.METER_TEMP."MeterKey" IS NOT NULL 
		 AND  etl.METER_TEMP."MeterKey" = dw."DimMeter"."MeterKey"
		 AND  (
			 	COALESCE(etl.METER_TEMP."InsertionTimeZoneKey",0) != COALESCE(dw."DimMeter"."TimeZoneKey",0)
			    OR 
			    COALESCE(etl.METER_TEMP."MeterSDP",'-1')          != COALESCE(dw."DimMeter"."MeterSDP",'-1')
			   )
		 AND  etl.METER_TEMP."Current" = TRUE;

	-- INSERT HISTORICAL ROWS
	INSERT INTO 
		dw."DimMeter"(
		"MeterAlternateKey",
		"ApplicationCode",
		"Name",
	    "DeviceCode",
		"IntervalsPerHour",
		"IsDSTEnabled",
		"IsVirtual",
		"MeterType",
		"Manufacturer",
		"FirstEndDateTimeUTC",
		"LastEndDateTimeUTC",
		"MeterSDP",
		"MeterSDPStartDateTime",
		"MeterSDPStopDateTime",	
		"TimeZoneKey",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
		MTemp."MeterAlternateKey",
		MTemp."ApplicationCode",
		MTemp."Name",
		MTemp."DeviceCode",
		MTemp."IntervalsPerHour",
		MTemp."IsDSTEnabled",
		MTemp."IsVirtual",
		MTemp."Type",
		MTemp."Manufacturer",
		MTemp."FirstEndDateTimeUTC",
		MTemp."LastEndDateTimeUTC",
		MTemp."MeterSDP",
		MTemp."MeterSDPStartDateTime",
		MTemp."MeterSDPStopDateTime",	
		MTemp."InsertionTimeZoneKey",
		now()::timestamp as "StartDateTime",
		NULL,
		TRUE 
	FROM      etl.METER_TEMP MTemp
	JOIN  dw."DimMeter" MSrc 
	ON MSrc."MeterKey" = MTemp."MeterKey"
	WHERE     MTemp."MeterKey" IS NOT NULL 
		  AND  (
			 	COALESCE(MTemp."InsertionTimeZoneKey",0) != COALESCE(MSrc."TimeZoneKey",0)
			    OR 
			    COALESCE(MTemp."MeterSDP",'-1')          != COALESCE(MSrc."MeterSDP",'-1')
			   )
		 AND  MTemp."Current" = TRUE;     
	
END;

$BODY$;

ALTER FUNCTION etl."MergeMeterData"()
    OWNER TO postgres;








-----------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('034_DW_ETL_SchemaChange_Create_Scripts');CREATE SCHEMA IF NOT EXISTS etl ;

--DROP TABLE
DROP TABLE dw."FactIntervals_SETT";
DROP TABLE dw."DimMeter" CASCADE ;


-- DimMeter
CREATE TABLE dw."DimMeter"
(
    "MeterKey" SERIAL PRIMARY KEY NOT NULL,
    "MeterAlternateKey" character varying(50) COLLATE pg_catalog."default" NOT NULL,
    "ApplicationCode" character varying(4) COLLATE pg_catalog."default" NOT NULL,
    "Name" character varying(50) COLLATE pg_catalog."default" NOT NULL,
	"DeviceCode" character varying(50) COLLATE pg_catalog."default" NOT NULL,
    "IntervalsPerHour" smallint NOT NULL,
    "IsDSTEnabled" boolean NOT NULL,
    "IsVirtual" boolean NOT NULL,
    "MeterType" character varying(50) COLLATE pg_catalog."default",
    "Manufacturer" character varying(50) COLLATE pg_catalog."default",
    "FirstEndDateTimeUTC" timestamp without time zone,
    "LastEndDateTimeUTC" timestamp without time zone,
    "MeterSDP" character varying(100) COLLATE pg_catalog."default",
    "MeterSDPStartDateTime" timestamp without time zone,
    "MeterSDPStopDateTime" timestamp without time zone,
    "TimeZoneKey" smallint,
    "StartDateTime" timestamp without time zone NOT NULL,
    "EndDateTime" timestamp without time zone,
    "Current" boolean NOT NULL,
    CONSTRAINT fk_meter_timezone FOREIGN KEY ("TimeZoneKey")
        REFERENCES dw."DimTimeZone" ("TimeZoneKey") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)
WITH (
    OIDS = FALSE
)
TABLESPACE pg_default;

ALTER TABLE dw."DimMeter"
    OWNER to postgres;
COMMENT ON TABLE dw."DimMeter"
    IS 'Meter, MeterType and MeterManufacturer Dimension';


CREATE INDEX dimmeter_alternatekey_appcode_device_name_current_index
    ON dw."DimMeter" USING btree
    ("MeterAlternateKey" COLLATE pg_catalog."default", "ApplicationCode" COLLATE pg_catalog."default", "DeviceCode" COLLATE pg_catalog."default", "Name" COLLATE pg_catalog."default", "Current")
    TABLESPACE pg_default;





-- FactIntervals
CREATE TABLE dw."FactIntervals_SETT"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"MonthlyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,	
	"UsageDLF" NUMERIC(28,4),	
    "Demand" NUMERIC(28,4) ,    
	"DemandDLF" NUMERIC(28,4) ,        
    "DLP" NUMERIC(18,6),	
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),	
    "DLF" NUMERIC(18,7),    
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
    "AccountKey" INT,
    "SDPKey" INT ,
    "MeterKey" INT,
    "ChannelKey" INT,    
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
	"ServiceTypeKey" SMALLINT,
	"ParentIntervalKey" BIGINT,
	"FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactIntervals_SETT" IS 'Intervals Fact Table';

--2015
CREATE TABLE dw.intervals_y2015m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2015m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2015m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2015m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2015m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2015m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2015m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey");



--2016
CREATE TABLE dw.intervals_y2016m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


--2017
CREATE TABLE dw.intervals_y2017m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


--2018
CREATE TABLE dw.intervals_y2018m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


--2019
CREATE TABLE dw.intervals_y2019m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey");































-----------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('035_DW_FactSETT_Indexes_Create_Scripts');DROP TABLE dw."FactWeather";

-- FactWeather
CREATE TABLE dw."FactWeather"
(
    "WeatherKey" BIGSERIAL,
    "InsertionDateTime" TIMESTAMP,
    "AgingDateTime" TIMESTAMP,	
	"WeatherObservationId" BIGINT,
    "StationKey" INT,
	"FactValueGoalKey" SMALLINT,	
	"FactStatusKey" SMALLINT,
	"ParentWeatherKey" BIGINT,	
	"EndDateTimeUTC" TIMESTAMP ,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT,
    "oC" INT,
    "oF" INT,
    "Humidity" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactWeather" IS 'Weather Fact Table';


--2015
CREATE TABLE dw.weather_y2015m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.weather_y2015m06 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2015m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.weather_y2015m07 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2015m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.weather_y2015m08 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2015m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.weather_y2015m09 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2015m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.weather_y2015m10 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2015m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.weather_y2015m11 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");







CREATE TABLE dw.weather_y2015m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.weather_y2015m12 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");






--2016
CREATE TABLE dw.weather_y2016m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.weather_y2016m01 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.weather_y2016m02 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2016m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.weather_y2016m03 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.weather_y2016m04 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.weather_y2016m05 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.weather_y2016m06 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.weather_y2016m07 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.weather_y2016m08 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.weather_y2016m09 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.weather_y2016m10 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");






CREATE TABLE dw.weather_y2016m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.weather_y2016m11 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");






CREATE TABLE dw.weather_y2016m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.weather_y2016m12 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





--2017
CREATE TABLE dw.weather_y2017m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.weather_y2017m01 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");






CREATE TABLE dw.weather_y2017m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.weather_y2017m02 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.weather_y2017m03 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.weather_y2017m04 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.weather_y2017m05 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.weather_y2017m06 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.weather_y2017m07 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.weather_y2017m08 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.weather_y2017m09 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.weather_y2017m10 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.weather_y2017m11 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.weather_y2017m12 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





--2018
CREATE TABLE dw.weather_y2018m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.weather_y2018m01 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2018m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.weather_y2018m02 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");



CREATE TABLE dw.weather_y2018m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.weather_y2018m03 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2018m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.weather_y2018m04 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.weather_y2018m05 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.weather_y2018m06 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.weather_y2018m07 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.weather_y2018m08 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.weather_y2018m09 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.weather_y2018m10 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.weather_y2018m11 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.weather_y2018m12 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





--2019
CREATE TABLE dw.weather_y2019m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.weather_y2019m01 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2019m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.weather_y2019m02 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.weather_y2019m03 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.weather_y2019m04 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.weather_y2019m05 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.weather_y2019m06 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.weather_y2019m07 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.weather_y2019m08 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2019m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.weather_y2019m09 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.weather_y2019m10 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.weather_y2019m11 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.weather_y2019m12 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





INSERT INTO public."DatabaseVersionHistory" VALUES ('036_DW_FactWeather_Create_Scripts');ALTER TABLE ct."LoadStream" ADD ClientId INTEGER;
ALTER TABLE ct."LoadStream" ADD LoadStreamETLConfigId INTEGER;

INSERT INTO public."DatabaseVersionHistory" VALUES ('037_DW_AddClientId_LoadStream_Table_Script');DROP FUNCTION IF EXISTS ct."stpGetLastLoadStreamInfo";

CREATE or REPLACE FUNCTION ct."stpGetLastLoadStreamInfo" ()
RETURNS
  TABLE
      (
        "StreamId" bigint,
		"ClientId" INTEGER,
		"LoadStreamETLConfigId" INTEGER,
		"FromSyncDateUTC" timestamp,
		"ToSyncDateUTC" timestamp,
		"ProcessStartDateTime" timestamp,
		"ProcessEndDateTime" timestamp,
		"Status" character varying(10)		  
      ) AS $$      
BEGIN

    RETURN  QUERY
    SELECT  
		str."StreamId",
		str."ClientId",
		str."LoadStreamETLConfigId",
		str."FromSyncDateUTC",
		str."ToSyncDateUTC",
		str."ProcessStartDateTime",
		str."ProcessEndDateTime",
		str."Status"		  
    FROM ct."LoadStream" str
	ORDER BY "StreamId" DESC
	LIMIT 1;

END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('038_DW_AddClientId_Func_stpGetLastLoadStreamInfo_Script');
ALTER TABLE ct."LoadStream"
DROP COLUMN IF EXISTS ClientId;

ALTER TABLE ct."LoadStream"
DROP COLUMN IF EXISTS LoadStreamETLConfigId;


ALTER TABLE ct."LoadStream" ADD "ClientId" INTEGER;
ALTER TABLE ct."LoadStream" ADD "LoadStreamETLConfigId" INTEGER;

INSERT INTO public."DatabaseVersionHistory" VALUES ('039_DW_AddClientId_LoadStream_Table_Script');CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	)
    RETURNS TABLE("IntervalId" bigint, 
				  "InsertionDateTime" timestamp without time zone, 
				  "MonthlyRead" numeric, 
				  "Usage" numeric, 
				  "UsageDLF" numeric, 
				  "Demand" numeric, 
				  "DemandDLF" numeric, 
				  "DLP" numeric, 
				  "DLPSum" numeric, 
				  "DLPRation" numeric, 
				  "DLF" numeric, 
				  "StartDateTimeUTC" timestamp without time zone, 
				  "TradeDay" timestamp without time zone, 
				  "StartDateTimeLocal" timestamp without time zone, 
				  "EndDateTimeLocal" timestamp without time zone, 
				  "AccountNumber" integer, 
				  "MeterName" character varying, 
				  "ClientName" character varying,
				  "CustomerName" character varying,
				  "ControlAreaName" character varying,
				  "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
		FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		LEFT JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"()
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('040_DW_FixGetSettlementIntervalsWithoutCustomer_Script');-- FACTS WEATHER
DROP TABLE dw."FactWeather";


CREATE TABLE dw."FactWeather"
(
    "WeatherKey" BIGSERIAL,
    "InsertionDateTime" TIMESTAMP,
    "AgingDateTime" TIMESTAMP,	
	"WeatherObservationId" BIGINT,
    "StationKey" INT,
	"FactValueGoalKey" SMALLINT,	
	"FactStatusKey" SMALLINT,
	"ParentWeatherKey" BIGINT,	
	"EndDateTimeUTC" TIMESTAMP ,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT,
    "oC" INT,
    "oF" INT,
    "Humidity" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactWeather" IS 'Weather Fact Table';


--2015
CREATE TABLE dw.weather_y2015m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.weather_y2015m06 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m06 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m06 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2015m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.weather_y2015m07 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m07 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m07 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2015m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.weather_y2015m08 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m08 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m08 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2015m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.weather_y2015m09 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m09 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m09 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2015m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.weather_y2015m10 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m10 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m10 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2015m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.weather_y2015m11 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m11 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m11 ("EndDateUTCKey");






CREATE TABLE dw.weather_y2015m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.weather_y2015m12 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m12 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m12 ("EndDateUTCKey");





--2016
CREATE TABLE dw.weather_y2016m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.weather_y2016m01 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m01 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m01 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.weather_y2016m02 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m02 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m02 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2016m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.weather_y2016m03 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m03 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m03 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.weather_y2016m04 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m04 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m04 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.weather_y2016m05 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m05 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m05 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.weather_y2016m06 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m06 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m06 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.weather_y2016m07 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m07 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m07 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.weather_y2016m08 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m08 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m08 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.weather_y2016m09 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m09 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m09 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.weather_y2016m10 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m10 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m10 ("EndDateUTCKey");





CREATE TABLE dw.weather_y2016m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.weather_y2016m11 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m11 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m11 ("EndDateUTCKey");





CREATE TABLE dw.weather_y2016m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.weather_y2016m12 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m12 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m12 ("EndDateUTCKey");




--2017
CREATE TABLE dw.weather_y2017m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.weather_y2017m01 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m01 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m01 ("EndDateUTCKey");





CREATE TABLE dw.weather_y2017m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.weather_y2017m02 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m02 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m02 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.weather_y2017m03 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m03 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m03 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.weather_y2017m04 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m04 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m04 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.weather_y2017m05 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m05 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m05 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.weather_y2017m06 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m06 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m06 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.weather_y2017m07 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m07 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m07 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.weather_y2017m08 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m08 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m08 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.weather_y2017m09 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m09 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m09 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.weather_y2017m10 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m10 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m10 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.weather_y2017m11 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m11 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m11 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.weather_y2017m12 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m12 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m12 ("EndDateUTCKey");




--2018
CREATE TABLE dw.weather_y2018m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.weather_y2018m01 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m01 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m01 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2018m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.weather_y2018m02 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m02 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m02 ("EndDateUTCKey");


CREATE TABLE dw.weather_y2018m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.weather_y2018m03 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m03 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m03 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2018m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.weather_y2018m04 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m04 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m04 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.weather_y2018m05 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m05 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m05 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.weather_y2018m06 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m06 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m06 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.weather_y2018m07 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m07 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m07 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.weather_y2018m08 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m08 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m08 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.weather_y2018m09 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m09 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m09 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.weather_y2018m10 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m10 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m10 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.weather_y2018m11 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m11 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m11 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.weather_y2018m12 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m12 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m12 ("EndDateUTCKey");




--2019
CREATE TABLE dw.weather_y2019m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.weather_y2019m01 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m01 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m01 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2019m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.weather_y2019m02 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m02 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m02 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.weather_y2019m03 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m03 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m03 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.weather_y2019m04 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m04 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m04 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.weather_y2019m05 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m05 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m05 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.weather_y2019m06 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m06 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m06 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.weather_y2019m07 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m07 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m07 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.weather_y2019m08 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m08 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m08 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2019m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.weather_y2019m09 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m09 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m09 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.weather_y2019m10 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m10 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m10 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.weather_y2019m11 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m11 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m11 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.weather_y2019m12 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m12 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m12 ("EndDateUTCKey");



---------------------------------------------------------------------------------------------------------------------------------------------

-- FACT SETTLEMENT
DROP TABLE dw."FactIntervals_SETT";

CREATE TABLE dw."FactIntervals_SETT"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"MonthlyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,	
	"UsageDLF" NUMERIC(28,4),	
    "Demand" NUMERIC(28,4) ,    
	"DemandDLF" NUMERIC(28,4) ,        
    "DLP" NUMERIC(18,6),	
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),	
    "DLF" NUMERIC(18,7),    
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
    "AccountKey" INT,
    "SDPKey" INT ,
    "MeterKey" INT,
    "ChannelKey" INT,    
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
	"ServiceTypeKey" SMALLINT,
	"ParentIntervalKey" BIGINT,
	"FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactIntervals_SETT" IS 'Intervals Fact Table';


--2015
CREATE TABLE dw.intervals_y2015m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2015m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2015m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2015m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2015m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2015m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2015m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




--2016
CREATE TABLE dw.intervals_y2016m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



--2017
CREATE TABLE dw.intervals_y2017m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2017m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2017m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2017m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2017m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2017m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2017m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2017m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2017m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2017m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2017m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2017m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


--2018
CREATE TABLE dw.intervals_y2018m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2018m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2018m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



--2019
CREATE TABLE dw.intervals_y2019m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2019m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2019m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2019m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2019m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



---------------------------------------------------------------------------------------------------------------------------------------------

-- FACT OMDA
DROP TABLE dw."FactIntervals_OMDA";


-- FactIntervals
CREATE TABLE dw."FactIntervals_OMDA"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"IntervalTimeId" BIGINT,
    "Usage" NUMERIC(28,4) ,		
    "Demand" NUMERIC(28,4) ,    	   
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
	"Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
	"IsFirm" BOOLEAN,	
    "MarginalUsage" NUMERIC(28,4),
    "MarginalUsageCost" NUMERIC(28,4),	
	"MarginalDemand" NUMERIC(28,4),
    "MarginalDemandCost" NUMERIC(28,4),
	"ShowTotal" BOOLEAN,
	"StartAvail" TIMESTAMP,
    "LastAvail" TIMESTAMP,
	"IsDSTEnabled" BOOLEAN,
	"Back" TIMESTAMP,
    "Forward" TIMESTAMP,	
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,    
    "SDPKey" INT ,
    "MeterKey" INT,
	"MeterSDPId" INT,
    "ChannelKey" INT,
    "CurrencyKey" SMALLINT,
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
	"ServiceTypeKey" SMALLINT,
	"ParentIntervalKey" BIGINT,
	"FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateLocalKey" INT
	
)PARTITION BY RANGE ("EndDateLocalKey");
COMMENT ON TABLE dw."FactIntervals_OMDA" IS 'Intervals Fact Table';




--2015
CREATE TABLE dw.intervals_omda_y2015m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_omda_y2015m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2015m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_omda_y2015m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2015m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_omda_y2015m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2015m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_omda_y2015m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2015m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_omda_y2015m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2015m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_omda_y2015m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2015m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_omda_y2015m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("EndDateLocalKey");





--2016
CREATE TABLE dw.intervals_omda_y2016m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_omda_y2016m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2016m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_omda_y2016m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2016m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_omda_y2016m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2016m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_omda_y2016m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2016m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_omda_y2016m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2016m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_omda_y2016m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2016m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_omda_y2016m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2016m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_omda_y2016m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2016m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_omda_y2016m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2016m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_omda_y2016m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2016m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_omda_y2016m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2016m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_omda_y2016m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("EndDateLocalKey");





--2017
CREATE TABLE dw.intervals_omda_y2017m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_omda_y2017m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2017m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_omda_y2017m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2017m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_omda_y2017m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2017m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_omda_y2017m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2017m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_omda_y2017m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2017m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_omda_y2017m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2017m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_omda_y2017m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2017m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_omda_y2017m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2017m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_omda_y2017m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2017m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_omda_y2017m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2017m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_omda_y2017m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2017m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_omda_y2017m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("EndDateLocalKey");






--2018
CREATE TABLE dw.intervals_omda_y2018m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_omda_y2018m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_omda_y2018m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2018m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_omda_y2018m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_omda_y2018m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_omda_y2018m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_omda_y2018m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_omda_y2018m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2018m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_omda_y2018m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_omda_y2018m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2018m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_omda_y2018m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_omda_y2018m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2018m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_omda_y2018m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("EndDateLocalKey");




--2019
CREATE TABLE dw.intervals_omda_y2019m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_omda_y2019m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2019m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_omda_y2019m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_omda_y2019m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_omda_y2019m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2019m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_omda_y2019m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_omda_y2019m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_omda_y2019m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_omda_y2019m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_omda_y2019m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_omda_y2019m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2019m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_omda_y2019m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_omda_y2019m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("EndDateLocalKey");


INSERT INTO public."DatabaseVersionHistory" VALUES ('041_DW_FactsTables_Indexes_Updated_Script');-- FactIntervals
DROP TABLE stg."FactIntervals";
CREATE TABLE stg."FactIntervals"
(
    "Omda_IntervalTimeId" BIGINT,
	"MonthlyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,
	"UsageDLF" NUMERIC(28,4),
    "Demand" NUMERIC(28,4) ,
	"DemandDLF" NUMERIC(28,4) ,
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
    "DLP" NUMERIC(18,6),
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),
    "DLF" NUMERIC(18,7),
	"Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
    "MarginalUsage" NUMERIC(28,4),
    "MarginalUsageCost" NUMERIC(28,4),

	"MarginalDemand" NUMERIC(28,4),
    "MarginalDemandCost" NUMERIC(28,4),

	"IsFirm" BOOLEAN ,
	"ShowTotal" BOOLEAN,
	"StartAvail" TIMESTAMP,
    "LastAvail" TIMESTAMP,
	"IsDSTEnabled" BOOLEAN,
	"Back" TIMESTAMP,
    "Forward" TIMESTAMP,	
    "MeterSDPId" INT,


    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
	"ClientId" INT,
    "AccountId" INT,
    "SDPId" INT ,
    "DeviceCode" character varying(50),

	"MeterId"  character varying(50),

    "ChannelId" VARCHAR(100),
    "CurrencyCode" VARCHAR(3),
	"OriginConsumptionCode" VARCHAR(8),
	"ApplicationCode" varchar(4),
    "EndDateLocal" TIMESTAMP,
    "EndTimeLocal" VARCHAR(10),
    "EndDateUTC" TIMESTAMP,
    "EndTimeUTC" VARCHAR(10),
	"RecordedDateUTC" TIMESTAMP,
	"RecordedDateLocal" TIMESTAMP
);
COMMENT ON TABLE stg."FactIntervals" IS 'Intervals Staging Fact Table';
CREATE INDEX ON stg."FactIntervals" ("EndDateTimeUTC", "ApplicationCode");
CREATE INDEX ON stg."FactIntervals" ("EndDateTimeLocal", "ApplicationCode");
CREATE INDEX ON stg."FactIntervals" ("Omda_IntervalTimeId","EndDateTimeUTC", "ApplicationCode");
CREATE INDEX ON stg."FactIntervals" ("EndDateTimeUTC","SDPId","MeterId", "ChannelId","ApplicationCode");
CREATE INDEX ON stg."FactIntervals" ("EndDateTimeLocal","SDPId","MeterId", "ChannelId","ApplicationCode");




-- STP MERGE FACT OMDA - INITIAL LOADING ONLY
CREATE OR REPLACE FUNCTION etl."stpInitialLoadMergeFactIntervals"(
	"dailyStartDateLocal" timestamp without time zone,
	"dailyEndDateLocal" timestamp without time zone)
    RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
   dailyStartDateLocalKey INTEGER   := CAST (TO_CHAR("dailyStartDateLocal"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateLocalKey   INTEGER   := CAST (TO_CHAR("dailyEndDateLocal"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT     "IntervalKey"            as "dw_IntervalKey",
	  			 "SDPKey"                 as "dw_SDPKey",
                 "MeterKey"               as "dw_MeterKey",
                 "ChannelKey"             as "dw_ChannelKey",                 
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",                 
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"        as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"        as "dw_EndTimeLocalKey"                 
      FROM dw."FactIntervals_OMDA" fct     
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'	  
      WHERE     fct."EndDateLocalKey"   >= dailyStartDateLocalKey
            AND fct."EndDateLocalKey"   <= dailyEndDateLocalKey
            AND fct."EndDateTimeLocal"  >  "dailyStartDateLocal"
            AND fct."EndDateTimeLocal"  <= "dailyEndDateLocal"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
	        "Omda_IntervalTimeId"  as "stg_Omda_IntervalTimeId",
            "Usage"                as "stg_Usage",            
            "Demand"               as "stg_Demand",
            "TCC"                  as "stg_TCC",
            "CBL"                  as "stg_CBL",
            "Price"                as "stg_Price",
            "PriceReduction"       as "stg_PriceReduction",
            "IsFirm"      		   as "stg_IsFirm",
	  
            "MarginalUsage"        as "stg_MarginalUsage",
            "MarginalUsageCost"    as "stg_MarginalUsageCost",
            "MarginalDemand"       as "stg_MarginalDemand",
            "MarginalDemandCost"   as "stg_MarginalDemandCost",
            "ShowTotal"            as "stg_ShowTotal",
            "StartAvail"           as "stg_StartAvail",
            "LastAvail"            as "stg_LastAvail",
            fct."IsDSTEnabled"         as "stg_IsDSTEnabled",
            "Back"                 as "stg_Back",
            "Forward"              as "stg_Forward",
	  
	  
	  		"StartDateTimeUTC"     as "stg_StartDateTimeUTC",
	  	  	"EndDateTimeUTC"       as "stg_EndDateTimeUTC",
	  	  	"StartDateTimeLocal"   as "stg_StartDateTimeLocal",	  
	  	  	"EndDateTimeLocal"     as "stg_EndDateTimeLocal",
	  
	  	  	"SDPKey"               as "stg_SDPKey",
	  	  	"MeterKey"             as "stg_MeterKey",
	  	  	"MeterSDPId"           as "stg_MeterSDPId",
	  		"ChannelKey"           as "stg_ChannelKey",
	  	  	"CurrencyKey"          as "stg_CurrencyKey",	  		
	  	  	"ServiceTypeKey"       as "stg_ServiceTypeKey",	 
	  		"OriginConsumptionKey" as "stg_OriginConsumptionKey",
	  
			dateLocal."DateKey"    as "stg_EndDateLocalKey",
            dateUTC."DateKey"      as "stg_EndDateUTCKey",
            timeLocal."TimeKey"    as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"      as "stg_EndTimeUTCKey",
            recordedDate."DateKey" as "stg_RecordedDateKey"
	  
      FROM stg."FactIntervals" fct
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."MeterId" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE	  
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE           
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
	  JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
	  JOIN dw."DimPriceCurrency" currency
	    ON currency."CurrencyCode" = fct."CurrencyCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateLocal"
	  
      WHERE "EndDateTimeLocal"  > "dailyStartDateLocal" AND "EndDateTimeLocal" <= "dailyEndDateLocal" AND fct."ApplicationCode" = 'OMDA'
  )

    -- INSERT NEW FACTS
	  INSERT INTO dw."FactIntervals_OMDA"(		
		"InsertionDateTime",
		"AgingDateTime",
		"IntervalTimeId",
		"Usage",
		"Demand",
		"TCC",
		"CBL",
		"Price",
		"PriceReduction",
		"IsFirm",
		"MarginalUsage",
		"MarginalUsageCost",
		"MarginalDemand",
		"MarginalDemandCost",
		"ShowTotal",
		"StartAvail",
		"LastAvail",
		"IsDSTEnabled",
		"Back",
		"Forward",
		"StartDateTimeUTC",
		"EndDateTimeUTC",
		"StartDateTimeLocal",
		"EndDateTimeLocal",
		"SDPKey",
		"MeterKey",
		"MeterSDPId",
		"ChannelKey",
		"CurrencyKey",
		"OriginConsumptionKey",
		"FactValueGoalKey",
		"ServiceTypeKey",
		"ParentIntervalKey",
		"FactStatusKey",
		"EndDateLocalKey",
		"EndTimeLocalKey",
		"EndDateUTCKey",
		"EndTimeUTCKey",
		"RecordedDateLocalKey"
	)
    SELECT 
			  now()::timestamp,
			  NULL,
			  "stg_Omda_IntervalTimeId",
			  "stg_Usage",
			  "stg_Demand",
              "stg_TCC",
              "stg_CBL",
              "stg_Price",
              "stg_PriceReduction",
              "stg_IsFirm",	  
              "stg_MarginalUsage",
              "stg_MarginalUsageCost",
              "stg_MarginalDemand",
              "stg_MarginalDemandCost",
              "stg_ShowTotal",
              "stg_StartAvail",
              "stg_LastAvail",
              "stg_IsDSTEnabled",
              "stg_Back",
              "stg_Forward",	 	  
	  		  "stg_StartDateTimeUTC",
	  	  	  "stg_EndDateTimeUTC",
	  	  	  "stg_StartDateTimeLocal",	  
	  	  	  "stg_EndDateTimeLocal",	  
	  	  	  "stg_SDPKey",
	  	  	  "stg_MeterKey",
	  	  	  "stg_MeterSDPId",
	  		  "stg_ChannelKey",
	  	  	  "stg_CurrencyKey",	
			  "stg_OriginConsumptionKey",
			  1, --FACTVALUEGOALKEY(INITIAL),
			  "stg_ServiceTypeKey",
			  NULL, --PARENTINTERVALKEY,
			  1,--FACTSTATUSKEY(CURRENT),
			  "stg_EndDateLocalKey",
			  "stg_EndTimeLocalKey",
			  "stg_EndDateUTCKey",
			  "stg_EndTimeUTCKey",
			  "stg_RecordedDateKey"	  			  
    FROM      stg_facts_CTE fct_new
	LEFT JOIN dw_facts_CTE  fct_old
	ON        fct_new."stg_EndDateLocalKey" = fct_old."dw_EndDateLocalKey"
	      AND fct_new."stg_EndTimeLocalKey" = fct_old."dw_EndTimeLocalKey"
		  AND fct_new."stg_SDPKey"          = fct_old."dw_SDPKey"
		  AND fct_new."stg_MeterKey"        = fct_old."dw_MeterKey"
		  AND fct_new."stg_ChannelKey"      = fct_old."dw_ChannelKey"
    WHERE fct_old."dw_IntervalKey" IS NULL ;
	
	
	

  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$BODY$;
ALTER FUNCTION etl."stpInitialLoadMergeFactIntervals"(timestamp without time zone, timestamp without time zone)
OWNER TO postgres;





INSERT INTO public."DatabaseVersionHistory" VALUES ('042_DW_Staging_Facts_Script');CREATE OR REPLACE FUNCTION etl."MergeLocationData" () 
RETURNS void AS $$
BEGIN

   --UPDATE DATA 
   UPDATE dw."DimLocation" 
   SET 
   "City"  = stg_location."CityName",
   "StateProvinceAbbr" = stg_location."StateAbbreviation", 
   "StateProvinceName" = stg_location."StateName",
   "CountryAbbr" = stg_location."CountryAbbreviation",
   "EnglishCountryName" = stg_location."CountryName",
   "SpanishCountryName" = stg_location."CountryName"
  FROM stg."Location" stg_location
  WHERE stg_location."CityId" = dw."DimLocation"."LocationAlternateKey" ;
  
  
   -- INSERT NEW DATA
   INSERT INTO dw."DimLocation"("LocationAlternateKey", "City", "StateProvinceAbbr", "StateProvinceName", "CountryAbbr", "EnglishCountryName", "SpanishCountryName")
   SELECT "CityId", "CityName", "StateAbbreviation", "StateName", "CountryAbbreviation", "CountryName","CountryName"
   FROM stg."Location" stg_location
   LEFT JOIN dw."DimLocation" dw_location
   ON stg_location."CityId" = dw_location."LocationAlternateKey"
   WHERE dw_location."LocationAlternateKey" IS NULL ;

END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."MergeStationData" () 
RETURNS void AS $$
BEGIN


    -- UPDATE DATA
	UPDATE dw."DimWeatherStation"
	SET 
	"Name" = stg_weather."Name"
	FROM stg."ObservationStation" stg_weather
	WHERE stg_weather."ObservationStationId" = dw."DimWeatherStation"."StationAlternateKey" ;
	
	-- INSERT NEW DATA
	INSERT INTO dw."DimWeatherStation"("StationAlternateKey", "Name")
	SELECT stg_weather."ObservationStationId", stg_weather."Name"
	FROM stg."ObservationStation" stg_weather
	LEFT JOIN dw."DimWeatherStation" dw_weather
	ON stg_weather."ObservationStationId" = dw_weather."StationAlternateKey" 
	WHERE dw_weather."StationAlternateKey" IS NULL ;


END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION etl."MergeTimezoneData" () 
RETURNS void AS $$
BEGIN

	--UPDATE DATA
	UPDATE dw."DimTimeZone"
	SET 
	"Abbreviation" = stg_Tz."Abbreviation", 
	"EnglishName"  = stg_Tz."Name",
	"SpanishName"  = stg_Tz."Name",
	"OffsetToGMT"  = stg_Tz."OffsetToGMT"	
	FROM stg."TimeZone" stg_Tz
	WHERE stg_Tz."TimeZoneId" = dw."DimTimeZone"."TimeZoneAlternateKey" ;
	
	
	
	--INSERT NEW DATA	
	INSERT INTO dw."DimTimeZone"("TimeZoneAlternateKey", "Abbreviation", "EnglishName", "SpanishName", "OffsetToGMT")
	SELECT stg_Tz."TimeZoneId",stg_Tz."Abbreviation", stg_Tz."Name", stg_Tz."Name",stg_Tz."OffsetToGMT"
	FROM stg."TimeZone" stg_Tz
	LEFT JOIN dw."DimTimeZone" dw_Tz
	ON dw_Tz."TimeZoneAlternateKey" = stg_Tz."TimeZoneId"
	WHERE dw_Tz."TimeZoneAlternateKey" IS NULL ;


END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION etl."MergeISOData" () 
RETURNS void AS $$
BEGIN
	
    --UPDATE DATA
	UPDATE dw."DimISO"
	SET  
	"ISOName" = stg_Ind."Name",
	"ISOEnglishDescription" = stg_Ind."Description" ,
	"ISOSpanishDescription" = stg_Ind."Description",
	"ISODefaultFormat" = 'N/A'
	FROM stg."IndSysOperator" stg_Ind 
	WHERE stg_Ind."IndSysOperatorId" = dw."DimISO"."ISOAlternateKey" ;
	
		
	--INSERT NEW DATA
	INSERT INTO dw."DimISO"("ISOAlternateKey", "ISOName", "ISOEnglishDescription", "ISOSpanishDescription", "ISODefaultFormat")	
	SELECT stg_Ind."IndSysOperatorId", stg_Ind."Name", stg_Ind."Description",stg_Ind."Description", 'N/A'
	FROM stg."IndSysOperator"  stg_Ind
	LEFT JOIN dw."DimISO" dw_Ind
	ON stg_Ind."IndSysOperatorId" = dw_Ind."ISOAlternateKey"
	WHERE dw_Ind."ISOAlternateKey" IS NULL ;


END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION etl."MergePowerTypeData" () 
RETURNS void AS $$
BEGIN

   --UPDATE DATA
   UPDATE dw."DimEnergyPowerType"
   SET 
   "EnglishEnergyPowerTypeDescription" = stg_Energ."Description",
   "SpanishPowerTypeDescription" = stg_Energ."Description"
   FROM stg."EnergyPowerType" stg_Energ
   WHERE stg_Energ."EnergyPowerTypeId" = dw."DimEnergyPowerType"."EnergyPowerTypeAlternateKey" ;
   
      
   --INSERT NEW DATA
	INSERT INTO dw."DimEnergyPowerType"("EnergyPowerTypeAlternateKey", "EnglishEnergyPowerTypeDescription", "SpanishPowerTypeDescription")
	SELECT "EnergyPowerTypeId", "Description", "Description"
	FROM stg."EnergyPowerType" stg_Energ
	LEFT JOIN dw."DimEnergyPowerType" dw_Energ
	ON stg_Energ."EnergyPowerTypeId" = dw_Energ."EnergyPowerTypeAlternateKey"
	WHERE dw_Energ."EnergyPowerTypeAlternateKey" IS NULL ;

END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION etl."MergeSDPData" () 
RETURNS void AS $$
BEGIN

	-- UPDATE DATA
	UPDATE dw."DimSDP"
	SET 
	"Address"                              = S."Address" ,
	"Address1"                             = S."Address1",
	"PostalCode"                           = S."PostalCode",
	"Longitude"                            = S."Longitude",
	"Latitude"                             = S."Latitude",
	"Name"                                 = S."Name",
	"IsVirtual"                            = S."IsVirtual",
	"LoadReductionPriceCode"               = S."LoadReductionPriceCode",
	"CustomerBaseLineAdjLoadReduction"     = S."CustomerBaseLineAdjustmentLoadReduction",
	"CustomerBaseLineAdjType"              = S."CustomerBaseLineAdjustmentType",
	"LocationKey"                          = L."LocationKey",
	"StationKey"                           = W."StationKey",
	"StartDateTime"                        = S."StartDateTime",
	"EndDateTime"                          = NULL,
	"Current"                              = TRUE
	FROM stg."SDP" S
	LEFT JOIN dw."DimLocation" L 
	ON S."CityId" = L."LocationAlternateKey"
	LEFT JOIN  dw."DimWeatherStation" W
	ON W."StationAlternateKey" = S."ObservationStationId"
	WHERE S."SDPId" = dw."DimSDP"."SDPAlternateKey" ;
	
	-- INSERT NEW DATA
	INSERT INTO dw."DimSDP"("SDPAlternateKey", "Address", "Address1", "PostalCode", "Longitude", "Latitude", "Name", "IsVirtual", "LoadReductionPriceCode", "CustomerBaseLineAdjLoadReduction", "CustomerBaseLineAdjType", "LocationKey", "StationKey", "StartDateTime", "EndDateTime", "Current")
	SELECT S."SDPId", S."Address", S."Address1", S."PostalCode", S."Longitude", S."Latitude", S."Name",  S."IsVirtual", S."LoadReductionPriceCode", S."CustomerBaseLineAdjustmentLoadReduction", S."CustomerBaseLineAdjustmentType",  L."LocationKey",  W."StationKey", S."StartDateTime", NULL, True 
	FROM stg."SDP" S
	LEFT JOIN dw."DimLocation" L 
	ON S."CityId" = L."LocationAlternateKey"
	LEFT JOIN  dw."DimWeatherStation" W
	ON W."StationAlternateKey" = S."ObservationStationId"
	LEFT JOIN dw."DimSDP" dw_Sdp
	ON S."SDPId" = dw_Sdp."SDPAlternateKey"
	WHERE dw_Sdp."SDPAlternateKey" IS NULL ;

END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION etl."MergeClientData" () 
RETURNS void AS $$
BEGIN

    --UPDATE DATA
	UPDATE dw."DimClient"
    SET 
	"ClientName"            = stg_client."Name",
	"LogoFileName"          = stg_client."LogoFileName",
	"LogoFileBinaryContent" = NULL ,
	"ClientUrl"             = stg_client."ClientUrl" ,
	"MonthsToRetain"        = stg_client."MonthsToRetain" , 
	"Duns"                  = stg_client."Duns"  ,
	"StartDateTime"         = stg_client."StartDateTime" ,
	"EndDateTime"           = NULL ,
	"Current"               = TRUE
	FROM stg."Client" stg_client
	WHERE stg_client."ClientId" = dw."DimClient"."ClientAlternateKey" ;

    --INSERT NEW DATA
	INSERT INTO dw."DimClient"("ClientAlternateKey", "ClientName", "LogoFileName", "LogoFileBinaryContent", "ClientUrl", "MonthsToRetain","Duns" , "StartDateTime", "EndDateTime", "Current")
	SELECT  stg_client."ClientId", stg_client."Name",stg_client."LogoFileName", NULL , stg_client."ClientUrl", stg_client."MonthsToRetain", stg_client."Duns" ,stg_client."StartDateTime", NULL, True
	FROM stg."Client" stg_client
	LEFT JOIN dw."DimClient" dw_client
	ON stg_client."ClientId" = dw_client."ClientAlternateKey"
	WHERE dw_client."ClientAlternateKey" IS NULL  ;

END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION etl."MergeCustomerData" () 
RETURNS void AS $$
BEGIN


	--UPDATE DATA
	UPDATE dw."DimCustomer"
	SET 
	"Name"            = stg_customer."Name",
	"StartDateTime"   = stg_customer."StartDateTime",
	"EndDateTime"     = NULL,
	"Current"         = TRUE
	FROM 
	(
			SELECT 
			CASE 
				WHEN "ApplicationCode" = 'OMDA' THEN "CustomerId"::text 
				WHEN "ApplicationCode" = 'SETT' THEN "Name"
			END AS "CustomerId",
			"ApplicationCode",
			"Name",
			"StartDateTime",
			NULL as "EndDateTime" ,
			TRUE as "Current"
		FROM stg."Customer"
	) stg_customer
	WHERE     stg_customer."CustomerId" = dw."DimCustomer"."CustomerAlternateKey" 
	      AND stg_customer."ApplicationCode" = dw."DimCustomer"."ApplicationCode" ;


   --INSERT NEW DATA
	INSERT INTO dw."DimCustomer"("CustomerAlternateKey", "ApplicationCode", "Name", "StartDateTime", "EndDateTime", "Current")
	SELECT stg_customer.*
	FROM 
	(
		SELECT 
			CASE 
				WHEN "ApplicationCode" = 'OMDA' THEN "CustomerId"::text 
				WHEN "ApplicationCode" = 'SETT' THEN "Name"
			END AS "CustomerId",
			"ApplicationCode",
			"Name",
			"StartDateTime",
			NULL::TIMESTAMP as "EndDateTime" ,
			TRUE as "Current"
		FROM stg."Customer" 
	) stg_customer	
	LEFT JOIN dw."DimCustomer" dw_customer
	ON      stg_customer."CustomerId" = dw_customer."CustomerAlternateKey"  
	    AND stg_customer."ApplicationCode" = dw_customer."ApplicationCode" 
	WHERE dw_customer."CustomerAlternateKey" IS NULL ;	



END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION etl."MergeControlAreaData" () 
RETURNS void AS $$
BEGIN


    -- UPDATE DATA
	UPDATE dw."DimControlArea"
	SET 
	"Name"          = C."Name",
	"Abbreviation"  = C."Abbreviation", 
	"Duns"          = C."Duns",
	"ISOKey"        = I."ISOKey"
	FROM stg."ControlArea" C
	LEFT JOIN dw."DimISO" I
	ON I."ISOAlternateKey" = C."IndSysOperatorId"
	WHERE C."ControlAreaId" = dw."DimControlArea"."ControlAreaAlternateKey" ;
	
			
	-- INSERT NEW DATA
	INSERT INTO dw."DimControlArea"("ControlAreaAlternateKey", "Name", "Abbreviation", "Duns", "ISOKey")
	SELECT C."ControlAreaId", C."Name", C."Abbreviation", C."Duns", I."ISOKey"
	FROM stg."ControlArea" C
	LEFT JOIN dw."DimISO" I
	ON I."ISOAlternateKey" = C."IndSysOperatorId"
	LEFT JOIN dw."DimControlArea" dw_controlArea
	ON C."ControlAreaId" =  dw_controlArea."ControlAreaAlternateKey"
	WHERE dw_controlArea."ControlAreaAlternateKey" IS NULL ;


END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION etl."MergeUomData" () 
RETURNS void AS $$
BEGIN


    -- UPDATE DATA
	UPDATE dw."DimUOM"
	SET 
	"EnglishDescription"        = U."Description",
	"SpanishDescription"        = U."Description",
	"Code"                      = U."Code",
	"UomFromMV90"               = U."UomFromMV90",
	"ConversionKey"             = U."UnitOfMeasureConversionId",
	"EnglishUomTypeDescription" = U."UomTypeDescription", 
	"SpanishUomTypeDescription" = U."UomTypeDescription",
	"EnergyPowerTypeKey"        = E."EnergyPowerTypeKey",
	"EDI867Code"                = U."EDI867Code"
	
	FROM stg."UnitOfMeasure" U
	LEFT JOIN dw."DimEnergyPowerType" E
	ON E."EnergyPowerTypeAlternateKey" = U."EnergyPowerTypeId"
	WHERE U."UnitOfMeasureId"  = dw."DimUOM"."UomAlternateKey" ;
	
	
	-- INSERT NEW DATA
	INSERT INTO dw."DimUOM"("UomAlternateKey", "EnglishDescription", "SpanishDescription", "Code", "UomFromMV90", "ConversionKey", "EnglishUomTypeDescription", "SpanishUomTypeDescription", "EnergyPowerTypeKey","EDI867Code")
	SELECT U."UnitOfMeasureId", U."Description",U."Description",U."Code", U."UomFromMV90",U."UnitOfMeasureConversionId",U."UomTypeDescription",U."UomTypeDescription", E."EnergyPowerTypeKey",U."EDI867Code"
	FROM stg."UnitOfMeasure" U
	LEFT JOIN dw."DimEnergyPowerType" E
	ON E."EnergyPowerTypeAlternateKey" = U."EnergyPowerTypeId"
    LEFT JOIN dw."DimUOM" dw_Uom
	ON U."UnitOfMeasureId" = dw_Uom."UomAlternateKey"
	WHERE dw_Uom."UomAlternateKey" IS NULL ;

	
END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION etl."MergeUomConversionData" () 
RETURNS void AS $$
BEGIN

	-- UPDATE DATA
	UPDATE dw."DimUOM"
	SET 
	"EnglishDescription"           =  U."Description",
	"SpanishDescription"           =  U."Description",
	"Code"                         =  U."Code",
	"UomFromMV90"                  =  U."UomFromMV90",
	"ConversionKey"                =  U2."UomKey",
	"EnglishUomTypeDescription"    =  U."UomTypeDescription",
	"SpanishUomTypeDescription"    =  U."UomTypeDescription",
	"EnergyPowerTypeKey"           =  E."EnergyPowerTypeKey",
	"EDI867Code"                   =  U."EDI867Code"	
	FROM stg."UnitOfMeasure" U
	LEFT JOIN dw."DimEnergyPowerType" E
	ON E."EnergyPowerTypeAlternateKey" = U."EnergyPowerTypeId"
	LEFT JOIN dw."DimUOM" U2 
	ON U2."UomAlternateKey" = U."UnitOfMeasureConversionId"
	WHERE U."UnitOfMeasureId" =  dw."DimUOM"."UomAlternateKey" ;
	
	
	-- INSERT NEW DATA
	INSERT INTO dw."DimUOM"("UomAlternateKey", "EnglishDescription", "SpanishDescription", "Code", "UomFromMV90", "ConversionKey", "EnglishUomTypeDescription", "SpanishUomTypeDescription", "EnergyPowerTypeKey","EDI867Code")
	SELECT  U."UnitOfMeasureId", U."Description",U."Description",U."Code", U."UomFromMV90",U2."UomKey",U."UomTypeDescription",U."UomTypeDescription", E."EnergyPowerTypeKey",U."EDI867Code"
	FROM stg."UnitOfMeasure" U
	LEFT JOIN dw."DimEnergyPowerType" E
	ON E."EnergyPowerTypeAlternateKey" = U."EnergyPowerTypeId"
	LEFT JOIN dw."DimUOM" U2 
	ON U2."UomAlternateKey" = U."UnitOfMeasureConversionId"
    LEFT JOIN dw."DimUOM" dw_Uom
	ON U."UnitOfMeasureId" = dw_Uom."UomAlternateKey"
	WHERE dw_Uom."UomAlternateKey" IS NULL ;

	
END;
$$ LANGUAGE plpgsql;




INSERT INTO public."DatabaseVersionHistory" VALUES ('043_DW_Merge_Dimensions_UpInsert_Script');--TRUNCATE ALL LOAD STREAM ENTITIES
TRUNCATE TABLE ct."Audit" CASCADE;
TRUNCATE TABLE ct."LoadCycle" CASCADE;
TRUNCATE TABLE ct."LoadStream" CASCADE;



-- ADD COLUMN STREAM_TYPE
ALTER TABLE ct."LoadStream"
DROP COLUMN IF EXISTS "StreamType";

ALTER TABLE ct."LoadStream" ADD "StreamType" VARCHAR (50);


ALTER TABLE ct."LoadStream"
DROP COLUMN IF EXISTS "IsInProgress";

ALTER TABLE ct."LoadStream" ADD "IsInProgress" boolean;



CREATE OR REPLACE FUNCTION etl."GetOrCreateDimensionStreamId"()
RETURNS TABLE
(
  "_StreamId" BIGINT
)
LANGUAGE plpgsql
AS $$
DECLARE "_nextDimStreamId" INTEGER  := 0;
BEGIN

	-- set default failedStatusId 
    SELECT  
			COALESCE ("StreamId", 0) into "_nextDimStreamId"  
	FROM ct."LoadStream" 
	where     "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime" IS NULL 
		  AND "StreamType" = 'Dimensions'
	ORDER BY "StreamId" DESC;


   IF "_nextDimStreamId" = 0 OR "_nextDimStreamId" IS NULL  THEN 
     RAISE NOTICE 'CREATE NEW STREAM';
	   INSERT INTO ct."LoadStream"("FromSyncDateUTC", "ToSyncDateUTC", "ProcessStartDateTime", "ProcessEndDateTime", "Status", "ClientId", "LoadStreamETLConfigId", "StreamType")
	   VALUES (date_trunc('day', now())::timestamp without time zone, date_trunc('day', now())::timestamp without time zone, NULL, NULL, NULL, NULL, NULL,'Dimensions'); 	
   ELSE
      RAISE NOTICE 'STREAM ALREADY EXISTS';
   END IF;

   	  	
	RETURN QUERY
	SELECT 
		"StreamId"
	FROM ct."LoadStream"
	where     "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime" IS NULL 
		  AND "StreamType" = 'Dimensions'
	ORDER BY "StreamId" DESC
	LIMIT 1;


END 
$$;






DROP FUNCTION IF EXISTS etl."GetStreamToProcess";

CREATE OR REPLACE FUNCTION etl."GetStreamToProcess"()
RETURNS TABLE("StreamId" bigint, "FromSyncDateUTC" timestamp without time zone, "ToSyncDateUTC" timestamp without time zone) 
LANGUAGE 'plpgsql'
COST 100
VOLATILE 
ROWS 1000
AS $BODY$

BEGIN	
	RETURN QUERY
	(
	  SELECT 
		ct."LoadStream"."StreamId",
        ct."LoadStream"."FromSyncDateUTC",
        ct."LoadStream"."ToSyncDateUTC"
	  FROM ct."LoadStream"
	  where   "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime"   IS NULL 
		  AND "StreamType" = 'Intervals'
		  AND "IsInProgress" = true

	  ORDER BY "StreamId" DESC
	);
END 

$BODY$;

ALTER FUNCTION etl."GetStreamToProcess"()
    OWNER TO postgres;




DROP FUNCTION IF EXISTS etl."UpdateStreamFinalStatusForAll";

CREATE OR REPLACE FUNCTION etl."UpdateStreamFinalStatusForAll"("statusETL" text)
RETURNS void
LANGUAGE 'plpgsql'

COST 100
VOLATILE 
AS $BODY$

BEGIN 

    UPDATE ct."LoadStream"
	SET "ProcessEndDateTime"= now()::timestamp,
		"Status"= "statusETL"
	WHERE 
		    ("Status" IS NULL OR "Status" = '')
		AND "IsInProgress" = true ;
	

END;

$BODY$;

ALTER FUNCTION etl."UpdateStreamFinalStatusForAll"(text)
    OWNER TO postgres;



INSERT INTO public."DatabaseVersionHistory" VALUES ('044_DW_ETL_Script');


DROP FUNCTION IF EXISTS etl."GetOrCreateDimensionStreamId";
CREATE OR REPLACE FUNCTION etl."GetOrCreateDimensionStreamId"()
RETURNS TABLE
(
  "_StreamId" BIGINT
)
LANGUAGE plpgsql
AS $$
DECLARE "_nextDimStreamId" INTEGER  := 0;
BEGIN

	-- set default failedStatusId 
    SELECT  
			COALESCE ("StreamId", 0) into "_nextDimStreamId"  
	FROM ct."LoadStream" 
	where     "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime" IS NULL 
		  AND "StreamType" = 'Dimensions'
	ORDER BY "StreamId" DESC;


   IF "_nextDimStreamId" = 0 OR "_nextDimStreamId" IS NULL  THEN 
     RAISE NOTICE 'CREATE NEW STREAM';
	   INSERT INTO ct."LoadStream"("FromSyncDateUTC", "ToSyncDateUTC", "ProcessStartDateTime", "ProcessEndDateTime", "Status", "ClientId", "LoadStreamETLConfigId", "StreamType", "IsInProgress")
	   VALUES (date_trunc('day', now())::timestamp without time zone, date_trunc('day', now())::timestamp without time zone, NULL, NULL, NULL, NULL, NULL,'Dimensions', true); 	
   ELSE
      RAISE NOTICE 'STREAM ALREADY EXISTS';
   END IF;

   	  	
	RETURN QUERY
	SELECT 
		"StreamId"
	FROM ct."LoadStream"
	where     "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime" IS NULL 
		  AND "StreamType" = 'Dimensions'
	ORDER BY "StreamId" DESC
	LIMIT 1;


END 
$$;






INSERT INTO public."DatabaseVersionHistory" VALUES ('045_DW_ETL_Script');--TRUNCATE ALL LOAD STREAM ENTITIES
TRUNCATE TABLE ct."Audit" CASCADE;
TRUNCATE TABLE ct."LoadCycle" CASCADE;
TRUNCATE TABLE ct."LoadStream" CASCADE;



ALTER TABLE ct."LoadStream"
DROP COLUMN IF EXISTS "ApplicationCode";

ALTER TABLE ct."LoadStream" ADD "ApplicationCode" varchar (4) NOT NULL DEFAULT 'SETT';


-- ADD COLUMN STREAM_TYPE
ALTER TABLE ct."LoadStream"
DROP COLUMN IF EXISTS "StreamType";

ALTER TABLE ct."LoadStream" ADD "StreamType" VARCHAR (50) NOT NULL DEFAULT 'Intervals';





DROP FUNCTION IF EXISTS etl."GetStreamToProcess";

CREATE OR REPLACE FUNCTION etl."GetIntervalsStreamToProcess"("_ApplicationCode" VARCHAR)
RETURNS TABLE
(
	"StreamId" bigint, 
	"FromSyncDateUTC" timestamp without time zone,
	"ToSyncDateUTC" timestamp without time zone,
	"ClientId" integer
) 
LANGUAGE 'plpgsql'
COST 100
VOLATILE 
ROWS 1000
AS $BODY$

BEGIN	
	RETURN QUERY
	(
	  SELECT 
		ct."LoadStream"."StreamId",
        ct."LoadStream"."FromSyncDateUTC",
        ct."LoadStream"."ToSyncDateUTC",
		ct."LoadStream"."ClientId"

	  FROM ct."LoadStream"
	  where   "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime"   IS NULL 
		  AND "StreamType" = 'Intervals'
		  AND "ApplicationCode" = "_ApplicationCode"
		  AND "IsInProgress" = true

	  ORDER BY "StreamId" DESC
	);
END 

$BODY$;



DROP FUNCTION IF EXISTS etl."GetOrCreateDimensionStreamId";
CREATE OR REPLACE FUNCTION etl."GetOrCreateStreamId"("_ApplicationCode" VARCHAR, "_StreamType" VARCHAR)
RETURNS TABLE
(
  "_StreamId" BIGINT
)
LANGUAGE plpgsql
AS $$
DECLARE "_nextStreamId" INTEGER  := 0;
BEGIN

    --Check for existing dimension stream
    SELECT  
			COALESCE ("StreamId", 0) into "_nextStreamId"  
	FROM ct."LoadStream" 
	where     "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime" IS NULL 
		  AND "StreamType" = "_StreamType"
		  AND "ApplicationCode" = "_ApplicationCode"

	ORDER BY "StreamId" DESC
	LIMIT 1;


   IF "_nextStreamId" = 0 OR "_nextStreamId" IS NULL  THEN 
     RAISE NOTICE 'CREATE NEW STREAM';
	   INSERT INTO ct."LoadStream"("FromSyncDateUTC", "ToSyncDateUTC", "ProcessStartDateTime", "ProcessEndDateTime", "Status", "ClientId", "LoadStreamETLConfigId", "StreamType", "IsInProgress","ApplicationCode")
	   VALUES (date_trunc('day', now())::timestamp without time zone, date_trunc('day', now())::timestamp without time zone, NULL, NULL, NULL, NULL, NULL,"_StreamType", true,"_ApplicationCode"); 	
   ELSE
      RAISE NOTICE 'STREAM ALREADY EXISTS';
   END IF;

   	  	
	RETURN QUERY
	SELECT 
		"StreamId"
	FROM ct."LoadStream"
	where     "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime" IS NULL 
		  AND "StreamType" = "_StreamType"
	ORDER BY "StreamId" DESC
	LIMIT 1;


END 
$$;




DROP TABLE IF EXISTS dw."FactVirtualEntities" ;


-- FactVirtualEntities
CREATE TABLE dw."FactVirtualEntities"
(
    "VirtualEntityKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"VirtualEntityConfigId" INT ,
    "VirtualSDPKey" INT ,
    "VirtualMeterKey" INT,
    "SourceChannelKey" BIGINT,
	"VirtualChannelKey" BIGINT,
    "FactValueGoalKey" SMALLINT,
	"FactStatusKey" SMALLINT,
	"ParentVirtualEntityKey" BIGINT,		
    "IsNegative" BOOLEAN,
    "Factor" NUMERIC(18,2)
);
COMMENT ON TABLE dw."FactVirtualEntities" IS 'VirtualEntities Fact Table';
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_SDP           FOREIGN KEY ("VirtualSDPKey")       REFERENCES dw."DimSDP" ("SDPKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_METER         FOREIGN KEY ("VirtualMeterKey")     REFERENCES dw."DimMeter" ("MeterKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_ChanSource    FOREIGN KEY ("SourceChannelKey")    REFERENCES dw."DimChannel" ("ChannelKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_ChanVirtual   FOREIGN KEY ("VirtualChannelKey")   REFERENCES dw."DimChannel" ("ChannelKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_FactValueGoal FOREIGN KEY ("FactValueGoalKey")    REFERENCES dw."DimFactValueGoal" ("FactValueGoalKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_FactStatus    FOREIGN KEY ("FactStatusKey")       REFERENCES dw."DimFactStatus" ("FactStatusKey");

CREATE INDEX VirtualEntities_1_index ON dw."FactVirtualEntities"("VirtualEntityConfigId", "FactStatusKey");
CREATE INDEX VirtualEntities_2_index ON dw."FactVirtualEntities"("VirtualSDPKey", "VirtualMeterKey", "SourceChannelKey", "VirtualChannelKey", "FactStatusKey");
CREATE INDEX VirtualEntities_3_index ON dw."FactVirtualEntities"("VirtualEntityConfigId", "VirtualSDPKey", "VirtualMeterKey", "FactStatusKey");






INSERT INTO public."DatabaseVersionHistory" VALUES ('046_DW_ETL_Script');-- View: dw."vIntervals_SETT"

-- DROP VIEW dw."vIntervals_SETT";

CREATE OR REPLACE VIEW dw."vIntervals_SETT" AS
 SELECT "FactIntervals_SETT"."IntervalKey",
    "FactIntervals_SETT"."InsertionDateTime",
    "FactIntervals_SETT"."AgingDateTime",
    "FactIntervals_SETT"."MonthlyRead",
    "FactIntervals_SETT"."Usage",
    "FactIntervals_SETT"."UsageDLF",
    "FactIntervals_SETT"."Demand",
    "FactIntervals_SETT"."DemandDLF",
    "FactIntervals_SETT"."DLP",
    "FactIntervals_SETT"."DLPSum",
    "FactIntervals_SETT"."DLPRation",
    "FactIntervals_SETT"."DLF",
    "FactIntervals_SETT"."StartDateTimeUTC",
    "FactIntervals_SETT"."EndDateTimeUTC",
    "FactIntervals_SETT"."StartDateTimeLocal",
    "FactIntervals_SETT"."EndDateTimeLocal",
    "FactIntervals_SETT"."AccountKey",
    "FactIntervals_SETT"."SDPKey",
    "FactIntervals_SETT"."MeterKey",
    "FactIntervals_SETT"."ChannelKey",
    "FactIntervals_SETT"."OriginConsumptionKey",
    "FactIntervals_SETT"."FactValueGoalKey",
    "FactIntervals_SETT"."ServiceTypeKey",
    "FactIntervals_SETT"."ParentIntervalKey",
    "FactIntervals_SETT"."FactStatusKey",
    "FactIntervals_SETT"."EndDateLocalKey",
    "FactIntervals_SETT"."EndTimeLocalKey",
    "FactIntervals_SETT"."EndDateUTCKey",
    "FactIntervals_SETT"."EndTimeUTCKey",
    "FactIntervals_SETT"."RecordedDateUTCKey"
   FROM dw."FactIntervals_SETT";

ALTER TABLE dw."vIntervals_SETT"
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('047_vIntervals_Sett_Create_Scripts');
CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"("startDateTime" TIMESTAMP WITHOUT TIME ZONE, "endDateTime" TIMESTAMP WITHOUT TIME ZONE
	)
    RETURNS TABLE("IntervalId" bigint, 
				  "InsertionDateTime" timestamp without time zone, 
				  "MonthlyRead" numeric, 
				  "Usage" numeric, 
				  "UsageDLF" numeric, 
				  "Demand" numeric, 
				  "DemandDLF" numeric, 
				  "DLP" numeric, 
				  "DLPSum" numeric, 
				  "DLPRation" numeric, 
				  "DLF" numeric, 
				  "StartDateTimeUTC" timestamp without time zone, 
				  "TradeDay" timestamp without time zone, 
				  "StartDateTimeLocal" timestamp without time zone, 
				  "EndDateTimeLocal" timestamp without time zone, 
				  "AccountNumber" integer, 
				  "MeterName" character varying, 
				  "ClientName" character varying,
				  "CustomerName" character varying,
				  "ControlAreaName" character varying,
				  "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
		FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"()
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('048_DW_UpdateFunction_GetSettlementIntervals');
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals" ("startDateTime" timestamp without time zone,"endDateTime" timestamp without time zone);
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals" ();

CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"("startDateTime" timestamp without time zone,"endDateTime" timestamp without time zone)
RETURNS 
TABLE
(
	"IntervalId" bigint,
	"InsertionDateTime" timestamp without time zone,
	"MonthlyRead" numeric,
	"Usage" numeric,
	"UsageDLF" numeric,
	"Demand" numeric,
	"DemandDLF" numeric,
	"DLP" numeric,
	"DLPSum" numeric,
	"DLPRation" numeric,
	"DLF" numeric,
	"StartDateTimeUTC" timestamp without time zone,
	"TradeDay" timestamp without time zone,
	"StartDateTimeLocal" timestamp without time zone,
	"EndDateTimeLocal" timestamp without time zone,
	"AccountNumber" integer,
	"MeterName" character varying,
	"ClientName" character varying,
	"CustomerName" character varying,
	"ControlAreaName" character varying,
	"ChannelNumber" integer
) 
LANGUAGE 'plpgsql'
COST 100
VOLATILE 
ROWS 1000
AS $BODY$

DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startDateTime"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("endDateTime" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
BEGIN

	RETURN QUERY
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
		FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		LEFT JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
		
		WHERE     fis."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fis."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fis."EndDateTimeUTC"   >  "startDateTime"
              AND fis."EndDateTimeUTC"   <= "endDateTime"
	)
	SELECT * 
	FROM INTERVALS_DATA;
	
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone)
OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('049_DW_UpdateFunction_GetSettlementIntervals');-- FUNCTION: dw."procRptCompare2DaysByAllAccounts"(integer, character varying, timestamp without time zone, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccounts"(integer, character varying, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccounts"(
	"clientId" integer,
	"ISO_Name" character varying,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transDate1" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" timestamp without time zone, "TransDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" timestamp without time zone, "TransDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"tradeDayLocalBegin1"   Date   := "tradeDay1"::Date;  
"tradeDayLocalEnd1"     timestamp   := "tradeDay1"::timestamp + interval '1 day - 3ms';
"tradeDayLocalBegin2"   Date   := "tradeDay2"::Date;  
"tradeDayLocalEnd2"     timestamp   := "tradeDay2"::timestamp + interval '1 day - 3 ms';

BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   fct."EndDateTimeLocal",
       fct."InsertionDateTime",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."Usage") AS "hourlyUsageDLFApplied" 
	
	     FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
		WHERE fct."EndDateTimeLocal"::Date >= "tradeDayLocalBegin1"
              AND fct."EndDateTimeLocal" < "tradeDayLocalEnd1"
		      AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
	          AND iso."ISOName" = "ISO_Name"
	
			  AND status."Code" = 'CURRENT'
			  
			/*AND
                (
                  ("transDate1" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transDate1" IS NOT NULL AND (fct."InsertionDateTime"::Date <= "transDate1"::Date AND (status."Code" = 'CURRENT' OR fct."AgingDateTime"::Date <= "transDate1"::Date)))
				)*/	         
              	  
GROUP BY fct."EndDateTimeLocal",
       	 fct."InsertionDateTime",
       	 ca."Abbreviation",
         act."AccountNumber",
 	 	 fct."Usage"

),
tmp2 AS 
(																					  
SELECT
	   fct."EndDateTimeLocal",
       fct."InsertionDateTime",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."Usage") AS "hourlyUsageDLFApplied" 

	     FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	        WHERE fct."EndDateTimeLocal"::Date >= "tradeDayLocalBegin2"
              AND fct."EndDateTimeLocal" < "tradeDayLocalEnd2"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
		      AND iso."ISOName" = "ISO_Name"
	
			  AND status."Code" = 'CURRENT'
              
				/*AND
                (
                  ("transDate1" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transDate1" IS NOT NULL AND (fct."InsertionDateTime"::Date <= "transDate1"::Date AND (status."Code" = 'CURRENT' OR fct."AgingDateTime"::Date <= "transDate1"::Date)))
				)*/	      
	                
GROUP BY fct."EndDateTimeLocal",
       	 fct."InsertionDateTime",
       	 ca."Abbreviation",
         act."AccountNumber"			 
)

SELECT "clientId" as "ClientID",
	   TO_CHAR("day1"."EndDateTimeLocal",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "TradeDay1",
	   TO_CHAR("day1"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "TransDate1",
       day1."Abbreviation" AS ControlArea1, 
       day1."AccountNumber" AS Account1, 
       CAST(day1."hourlyUsageDLFApplied" / 1000 AS DECIMAL(28,7)) AS "Adj_Total1",
       CAST(day2."hourlyUsageDLFApplied" / 1000 AS DECIMAL(28,7)) AS "Adj_Total2",
	   TO_CHAR("day2"."EndDateTimeLocal",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "TransDate1", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
														         
       
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) / 1000 AS DECIMAL(28,7)) AS "Difference_Adj_"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
ORDER BY 11 DESC;

END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccounts"(integer, character varying, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;



INSERT INTO public."DatabaseVersionHistory" VALUES ('050_DW_procRptCompare2DaysByAllAccounts');-- FUNCTION: dw."procRptDailyTotals"(integer, character varying, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptDailyTotals"(integer, character varying, timestamp without time zone, timestamp without time zone);


-- FUNCTION: dw."procRptDailyTotals"(integer, character varying, timestamp without time zone, timestamp without time zone)

-- DROP FUNCTION dw."procRptDailyTotals"(integer, character varying, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptDailyTotals"(
	"clientId" integer,
	"ISO_Name" character varying,
	"tradeDayLocal" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Tradeday" Date, "TransactionDate" Date, "Account" character varying, "MeterID" character varying, "ControlArea" character varying, "RawDailyUsage" numeric(24,8), "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
  
"tradeDayLocalBegin"   Date   := "tradeDayLocal"::Date;  
"tradeDayLocalEnd"     timestamp   := "tradeDayLocal"::timestamp + interval '1 day - 3 ms';

BEGIN

    RETURN  QUERY
	
SELECT tmp."Tradeday"
	  ,tmp."TransactionDate" 
	  ,tmp."Account"
	  ,tmp."MeterID"
	  ,tmp."ControlArea"
	  ,SUM(tmp."RawDailyUsage")
	  ,tmp."IntervalReadings"
	  
	  
FROM (
SELECT "tradeDayLocal"::Date AS "Tradeday"
	  ,"transactionDate"::Date AS "TransactionDate" 
	  ,act."AccountNumber" AS "Account"
	  ,mt."DeviceCode" AS "MeterID"
	  ,ca."Abbreviation" AS "ControlArea"
	  ,fct."Usage" AS "RawDailyUsage"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings"
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"        
		JOIN dw."DimOriginFactValue" ofv
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"      
		JOIN dw."DimControlArea" ca																						
		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
		JOIN dw."DimMeter" mt
		  ON mt."MeterKey" = fct."MeterKey"  
			
	    WHERE cli."ClientAlternateKey" = "clientId"
      		AND fct."EndDateTimeLocal"::Date = "tradeDayLocalBegin"
	   		And fct."EndDateTimeLocal" < "tradeDayLocalEnd" 
			AND fct."InsertionDateTime"::Date = "transactionDate"::Date
            AND serv."Code" = 'SETT'
            AND act."ApplicationCode" = 'SETT'
			AND iso."ISOName" = "ISO_Name"
           
 			AND status."Code" = 'CURRENT'
)tmp			
			/*AND
            
              ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
              OR
              ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
            */
		GROUP BY tmp."Tradeday"
	  		 	 ,tmp."TransactionDate" 
	  		 	 ,tmp."Account"
	  		 	 ,tmp."MeterID"
	    	 	 ,tmp."ControlArea"
	  		 	 ,tmp."IntervalReadings"
			 
		ORDER BY tmp."Account"
	  			 ,tmp."MeterID"
	  			 ,tmp."ControlArea";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyTotals"(integer, character varying, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('051_DW_procRptDailyTotals');-- FUNCTION: dw."procRptMonthlyTotals"(integer, character varying, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptMonthlyTotals"(integer, character varying, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptMonthlyTotals"(
	"clientId" integer,
	"ISO_Name" character varying,
	"monthDate" timestamp without time zone)
    RETURNS TABLE("Account" character varying, "Adj_Consumption" numeric, "StartDate" timestamp without time zone, "EndDate" timestamp without time zone, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"som" Date := date_trunc('MONTH', "monthDate"::Date);
"eom" Date := date_trunc('MONTH', "monthDate"::Date) + INTERVAL '1 MONTH - 3 ms';

BEGIN

    RETURN  QUERY

SELECT act."AccountNumber" AS "Account"
	  ,SUM(fct."UsageDLF") AS "Adj_Consumption"
	  ,"som"::Timestamp AS "StartDate"
      ,"eom"::Timestamp AS "EndDate"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings" 

FROM dw."FactIntervals_SETT" fct 
		JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
		JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
		JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
	    JOIN dw."DimOriginFactValue" ofv
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"   
		JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" =  act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"   
		
WHERE	 fct."EndDateTimeLocal"::Date >= "som" 
			AND fct."EndDateTimeLocal"::Date <= "eom" 
			AND cli."ClientAlternateKey" = "clientId"
            AND serv."Code" = 'SETT'
            AND act."ApplicationCode" = 'SETT'
			AND iso."ISOName" = "ISO_Name"
	
 			AND status."Code" = 'CURRENT'
                  																	
												
GROUP BY act."AccountNumber", ofv."OriginValueEnglishDescription"
ORDER BY act."AccountNumber";
		
	
END;
$BODY$;

ALTER FUNCTION dw."procRptMonthlyTotals"(integer, character varying, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('052_DW_procRptMonthlyTotals');-- DROP FUNCTION dw."procRptDailyDetailData"(integer, character varying, timestamp without time zone, timestamp without time zone);
DROP FUNCTION IF EXISTS dw."procRptDailyDetailData"(integer, character varying, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptDailyDetailData"(
	"clientId" integer,
	"ISO_Name" character varying,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone)
    RETURNS TABLE("TradeDay1" Date, "TransDate1" Date, "Abbreviation1" character varying, "Adj_Consumption" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
BEGIN

    RETURN  QUERY

SELECT 
	   tmp."tradeDay1",
	   tmp."transDate1",
	   tmp."Abbreviation1",
       SUM(tmp."Adj_Consumption") 
	  
	FROM(
 SELECT   fct."EndDateTimeLocal"::Date  AS "tradeDay1",
	   		fct."InsertionDateTime"::Date AS "transDate1",
	   		ca."Abbreviation" AS "Abbreviation1",
       		fct."Usage" AS "Adj_Consumption"
   
   FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"   																									
	        
			WHERE cli."ClientAlternateKey" = "clientId"
			  AND fct."EndDateTimeLocal"::Date >= "tradeDay1"::Date
			  AND fct."EndDateTimeLocal"::Date <= "tradeDay2"::Date
			  AND serv."Code" = 'SETT'
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOName" = "ISO_Name"
			  	
			  AND status."Code" = 'CURRENT'
   
   )tmp
			 /* AND
                (
                  ("transDate1" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transDate1" IS NOT NULL AND (fct."InsertionDateTime"::Date <= "transDate1"::Date AND (status."Code" = 'CURRENT' OR fct."AgingDateTime"::Date >= "transDate1"::Date)))
				)*/						
	
GROUP BY tmp."tradeDay1",
	   	 tmp."transDate1",
	     tmp."Abbreviation1"
	     
ORDER BY tmp."tradeDay1",
	   	 tmp."transDate1",
	     tmp."Abbreviation1";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyDetailData"(integer, character varying, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('054_DW_procRptDailyDetailData');-- FUNCTION: dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptMonthlyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"monthDate" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Account" character varying, "Adj_Consumption" numeric, "StartDate" timestamp without time zone, "EndDate" timestamp without time zone, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("monthDate"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("monthDate" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "monthDate" + interval '1' day;	  

"som" Date := date_trunc('MONTH', "monthDate"::Date);
"eom" timestamp := date_trunc('MONTH', "monthDate"::timestamp) + INTERVAL '1 MONTH - 3 ms';

BEGIN

    RETURN  QUERY

SELECT act."AccountNumber" AS "Account"
	  ,SUM(fct."UsageDLF") AS "Adj_Consumption"
	  ,"som"::Timestamp AS "StartDate"
      ,"eom"::Timestamp AS "EndDate"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings" 

FROM dw."FactIntervals_SETT" fct 
		JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
		JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
		JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
	    JOIN dw."DimOriginFactValue" ofv 
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"   
		JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" =  act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"   
		
WHERE   fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "monthDate"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id" 
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )													 														
												
GROUP BY act."AccountNumber", ofv."OriginValueEnglishDescription"
ORDER BY act."AccountNumber";
		
	
END;
$BODY$;

ALTER FUNCTION dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

		
INSERT INTO public."DatabaseVersionHistory" VALUES ('055_DW_procRptMonthlyTotals');-- FUNCTION: dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptDailyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"startTradeDayUTC" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Tradeday" date, "TransactionDate" timestamp without time zone, "Account" character varying, "MeterID" character varying, "ControlArea" character varying, "RawDailyUsage" numeric, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
   
"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;	  

--"tradeDayBegin"   Date   := "startTradeDayUTC"::Date;  
--"tradeDayEnd"     timestamp   := "startTradeDayUTC"::timestamp + interval '1 day - 3 ms';

BEGIN

    RETURN  QUERY
	
SELECT tmp."Tradeday"
	  ,tmp."TransactionDate" 
	  ,tmp."Account"
	  ,tmp."MeterID"
	  ,tmp."ControlArea"
	  ,SUM(tmp."RawDailyUsage")
	  ,tmp."IntervalReadings"
	  
	  
FROM (
SELECT "startTradeDayUTC"::Date AS "Tradeday"
	  ,"transactionDate" AS "TransactionDate" 
	  ,act."AccountNumber" AS "Account"
	  ,mt."DeviceCode" AS "MeterID"
	  ,ca."Abbreviation" AS "ControlArea"
	  ,fct."Usage" AS "RawDailyUsage"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings"

FROM dw."FactIntervals_SETT" fct 
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"        
		JOIN dw."DimOriginFactValue" ofv
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"      
		JOIN dw."DimControlArea" ca																						
		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
		JOIN dw."DimMeter" mt
		  ON mt."MeterKey" = fct."MeterKey"  
			
	    WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
	
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
)tmp			
			
		GROUP BY tmp."Tradeday"
	  		 	 ,tmp."TransactionDate" 
	  		 	 ,tmp."Account"
	  		 	 ,tmp."MeterID"
	    	 	 ,tmp."ControlArea"
	  		 	 ,tmp."IntervalReadings"
			 
		ORDER BY tmp."Account"
	  			 ,tmp."MeterID"
	  			 ,tmp."ControlArea";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('056_DW_procRptDailyTotals');-- FUNCTION: dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccounts"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "tradeDay1"
			  AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey2"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey2"
              AND fct."EndDateTimeUTC"  >=  "tradeDay2"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC2"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
       	  fct."InsertionDateTime"::Date,
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   tmpResult."Account1",
				   SUM(tmpResult."Adj_Total1"),
				   SUM(tmpResult."Adj_Total2"),
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   tmpResult."Account2",
				   SUM(tmpResult."Difference_Adj_1")
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	   	 tmpResult."Account1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2",
	     tmpResult."Account2"
	    
				
ORDER BY tmpResult."Account1", tmpResult."Account2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('057_DW_procRptCompare2DaysByAllAccounts');--CREATE OR REPLACE FUNCTION dw."stpGetCommercialChannelsData"(
--"StartDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"EndDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"Skip" INTEGER,
--"Limit" INTEGER
--)
--    RETURNS TABLE("ChannelKey" INTEGER, "IntervalsPerHour" SMALLINT) 
--    LANGUAGE 'plpgsql'

--    COST 100
--    VOLATILE 
--    ROWS 1000
--AS $BODY$

--DECLARE
--    "_StartDateUTCKey" INTEGER := CAST (TO_CHAR("StartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
--    "_EndDateUTCKey" INTEGER   := CAST (TO_CHAR(("EndDateUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
--BEGIN
--	RETURN QUERY 
--	SELECT DISTINCT fct."ChannelKey", dc."IntervalsPerHour" FROM dw."FactIntervals_SETT" fct
--	JOIN dw."DimChannel" dc
--	  ON fct."ChannelKey" = dc."ChannelKey"
--	JOIN dw."DimFactStatus" status
--	  ON status."FactStatusKey" = fct."FactStatusKey"
--	WHERE  fct."EndDateUTCKey" >= "_StartDateUTCKey"
--	AND fct."EndDateUTCKey" <= "_EndDateUTCKey"
--	AND status."Code" = 'CURRENT'
--	ORDER BY "ChannelKey"
--	LIMIT "Limit" OFFSET "Skip";
--END;

--$BODY$;

--ALTER FUNCTION dw."stpGetCommercialChannelsData"()
--    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('058_DW_stpGetCommercialChannelsData');--CREATE OR REPLACE FUNCTION dw."stpGetResidentialChannelsData"(
--"StartDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"EndDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"Skip" INTEGER,
--"Limit" INTEGER
--)
--    RETURNS TABLE("ChannelKey" INTEGER, "IntervalsPerHour" SMALLINT) 
--    LANGUAGE 'plpgsql'

--    COST 100
--    VOLATILE 
--    ROWS 1000
--AS $BODY$

--DECLARE
--    "_StartDateUTCKey" INTEGER := CAST (TO_CHAR("StartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
--    "_EndDateUTCKey" INTEGER   := CAST (TO_CHAR(("EndDateUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
--BEGIN
--	RETURN QUERY 
--	SELECT DISTINCT fct."ChannelKey", dc."IntervalsPerHour" FROM dw."FactIntervals_SETT" fct
--	JOIN dw."DimChannel" dc
--	  ON fct."ChannelKey" = dc."ChannelKey"
--	JOIN dw."DimFactStatus" status
--	  ON status."FactStatusKey" = fct."FactStatusKey"
--	WHERE  fct."EndDateUTCKey" >= "_StartDateUTCKey"
--	AND fct."EndDateUTCKey" <= "_EndDateUTCKey"
--	AND status."Code" = 'CURRENT'
--	ORDER BY "ChannelKey"
--	LIMIT "Limit" OFFSET "Skip";
--END;

--$BODY$;

--ALTER FUNCTION dw."stpGetResidentialChannelsData"()
--    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('059_DW_stpGetResidentialChannelsData');--CREATE OR REPLACE FUNCTION dw."stpGetCommercialChannelIntervalsData"(
--"_StartDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"_EndDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"_LastExecutionDateUTC" TIMESTAMP WITHOUT TIME ZONE,
--"_ChannelKey" INTEGER
--)
--    RETURNS TABLE("EndDateTimeUTC" TIMESTAMP WITHOUT TIME ZONE,
--	"Value" numeric(28,4),
--	"Temperature" INTEGER,
--	"Humidity" INTEGER
--	) 
--    LANGUAGE 'plpgsql'

--    COST 100
--    VOLATILE 
--    ROWS 1000
--AS $BODY$

--DECLARE
--    "_StartDateUTCKey" INTEGER := CAST (TO_CHAR("_StartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
--    "_EndDateUTCKey" INTEGER   := CAST (TO_CHAR(("_EndDateUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
--BEGIN
--	RETURN QUERY 
--	SELECT fct."EndDateTimeUTC", fct."DemandDLF" AS "Value", null::INTEGER AS "Temperature", null::INTEGER AS "Humidity"
--	FROM dw."FactIntervals_SETT" fct
--	JOIN dw."DimFactStatus" status
--	  ON status."FactStatusKey" = fct."FactStatusKey"
--	WHERE  fct."EndDateUTCKey" >= "_StartDateUTCKey"
--	  AND fct."EndDateUTCKey" <= "_EndDateUTCKey"
--	  AND fct."EndDateTimeUTC" >  "_StartDateUTC"
--	  AND fct."EndDateTimeUTC" <=  "_EndDateUTC"
--	  AND fct."ChannelKey" = "_ChannelKey"
--	  AND status."Code" = 'CURRENT'
--	  AND (
--		   ("_LastExecutionDateUTC" IS NULL) OR 
--		   ( "_LastExecutionDateUTC" IS NOT NULL AND fct."ParentIntervalKey" IS NOT NULL) OR
--		   ( "_LastExecutionDateUTC" IS NOT NULL AND fct."ParentIntervalKey" IS NULL AND fct."EndDateTimeUTC" > "_LastExecutionDateUTC" AND fct."EndDateTimeUTC" <= "_EndDateUTC")
--		  )
--	ORDER BY fct."EndDateTimeUTC";
--END;

--$BODY$;


--ALTER FUNCTION dw."stpGetCommercialChannelIntervalsData"()
--    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('060_DW_stpGetCommercialChannelIntervalsData');--CREATE OR REPLACE FUNCTION dw."stpGetResidentialChannelIntervalsData"(
--"_StartDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"_EndDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"_LastExecutionDateUTC" TIMESTAMP WITHOUT TIME ZONE,
--"_ChannelKey" INTEGER
--)
--    RETURNS TABLE("EndDateTimeUTC" TIMESTAMP WITHOUT TIME ZONE,
--	"Value" numeric(28,4),
--	"Temperature" INTEGER,
--	"Humidity" INTEGER
--	) 
--    LANGUAGE 'plpgsql'

--    COST 100
--    VOLATILE 
--    ROWS 1000
--AS $BODY$

--DECLARE
--    "_StartDateUTCKey" INTEGER := CAST (TO_CHAR("_StartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
--    "_EndDateUTCKey" INTEGER   := CAST (TO_CHAR(("_EndDateUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
--BEGIN
--	RETURN QUERY 
--	SELECT fct."EndDateTimeUTC", fct."DemandDLF" AS "Value", null::INTEGER AS "Temperature", null::INTEGER AS "Humidity"
--	FROM dw."FactIntervals_SETT" fct
--	JOIN dw."DimFactStatus" status
--	  ON status."FactStatusKey" = fct."FactStatusKey"
--	WHERE  fct."EndDateUTCKey" >= "_StartDateUTCKey"
--	  AND fct."EndDateUTCKey" <= "_EndDateUTCKey"
--	  AND fct."EndDateTimeUTC" >  "_StartDateUTC"
--	  AND fct."EndDateTimeUTC" <=  "_EndDateUTC"
--	  AND fct."ChannelKey" = "_ChannelKey"
--	  AND status."Code" = 'CURRENT'
--	  AND (
--		   ("_LastExecutionDateUTC" IS NULL) OR 
--		   ( "_LastExecutionDateUTC" IS NOT NULL AND fct."ParentIntervalKey" IS NOT NULL) OR
--		   ( "_LastExecutionDateUTC" IS NOT NULL AND fct."ParentIntervalKey" IS NULL AND fct."EndDateTimeUTC" > "_LastExecutionDateUTC" AND fct."EndDateTimeUTC" <= "_EndDateUTC")
--		  )
--	ORDER BY fct."EndDateTimeUTC";
--END;

--$BODY$;


--ALTER FUNCTION dw."stpGetCommercialChannelIntervalsData"()
--    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('061_DW_stpGetResidentialChannelIntervalsData');DROP FUNCTION IF EXISTS ct."stpGetLastLoadStreamInfo";

CREATE or REPLACE FUNCTION ct."stpGetLastLoadStreamInfo" ("_applicationCode" varchar, "_streamType" varchar)
RETURNS
  TABLE
      (
        "StreamId" bigint,
		"ClientId" INTEGER,
		"LoadStreamETLConfigId" INTEGER,
		"FromSyncDateUTC" timestamp,
		"ToSyncDateUTC" timestamp,
		"ProcessStartDateTime" timestamp,
		"ProcessEndDateTime" timestamp,
		"Status" character varying(10)		  
      ) AS $$      
BEGIN

    RETURN  QUERY
    SELECT  
		str."StreamId",
		str."ClientId",
		str."LoadStreamETLConfigId",
		str."FromSyncDateUTC",
		str."ToSyncDateUTC",
		str."ProcessStartDateTime",
		str."ProcessEndDateTime",
		str."Status"		  
    FROM  ct."LoadStream" str
	WHERE str."ApplicationCode" = "_applicationCode" 
	AND   str."StreamType"      = "_streamType" 

	ORDER BY "StreamId" DESC
	LIMIT 1;

END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('062_DW_AddClientId_Func_stpGetLastLoadStreamInfo_Script');

-----------------------------------------------------------------------
DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals_SETT";
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT";

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );


  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

---------------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('063_DW_ETL_SchemaChange_Create_Scripts');CREATE SCHEMA IF NOT EXISTS etl ;


CREATE OR REPLACE FUNCTION etl."InsertNewLoadCycle" ("_streamId" integer, "_envCode" text , "_sourceSchema" text , "_destSchema" text, "_loadType" text) 
RETURNS void AS $$
BEGIN
   
 INSERT INTO ct."LoadCycle"
 (
	 "EnvCode",
	 "SourceSchema",
	 "DestinationSchema",
	 "LoadType",
	 "StartingDateTime",
	 "EndDateTime",
	 "Status",
	 "StreamId"
 )
 VALUES ("_envCode","_sourceSchema", "_destSchema", "_loadType", clock_timestamp(), NULL, NULL,"_streamId" );

END;
$$ LANGUAGE plpgsql;


INSERT INTO public."DatabaseVersionHistory" VALUES ('064_DW_ETL_Create_Scripts');
TRUNCATE dw."DimAccount" CASCADE;


---------------------------------------------------------------

CREATE OR REPLACE FUNCTION etl."MergeAccountData"()
RETURNS void
LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
AS $BODY$

BEGIN

			INSERT INTO  etl.ACCOUNT_TEMP  
			SELECT ACC_TEMP.*, Cust."CustomerKey" as "InsertionCustomerKey"
			FROM 
			(
					SELECT 
						"AccountId",
						"CustomerId",
						"CustomerName",
						CASE 
							WHEN  ASrc."ApplicationCode"= 'OMDA'  THEN "CustomerId"::text
							ELSE "CustomerName"
						END AS "CustomerAlternateId",
						"ClientId",
						CL."ClientKey" as "InsertionClientKey",
						ASrc."AccountNumber",
						ASrc."PremiseNumber",
						"ControlAreaId",
						CA."ControlAreaKey" as "InsertionControlAreaKey",
						"TimeZoneId",
						TZ."TimeZoneKey" as "InsertionTimeZoneKey",
						ASrc."ClientAccountKey",
						ASrc."ApplicationCode",
						ASrc."StartActiveDateTimeUTC",
						ASrc."EndActiveDateTimeUTC",
						ASrc."StartActiveDateTimeLocal",
						ASrc."EndActiveDateTimeLocal",
						ASrc."StartDateTime",
						ADes."AccountKey",
						ADes."ClientKey"      

				FROM stg."Account" ASrc
				LEFT JOIN dw."DimAccount" ADes
				ON ASrc."AccountId" = ADes."AccountAlternateKey"  AND ASrc."ApplicationCode" = ADes."ApplicationCode" AND ADes."Current" = TRUE
				LEFT JOIN dw."DimClient" CL
				ON CL."ClientAlternateKey" = ASrc."ClientId" AND CL."Current" =  TRUE
				LEFT JOIN dw."DimControlArea" CA
				ON CA."ControlAreaAlternateKey" = ASrc."ControlAreaId"
				LEFT JOIN dw."DimTimeZone" TZ
				ON TZ."TimeZoneAlternateKey" =  ASrc."TimeZoneId"
			) ACC_TEMP
			LEFT JOIN dw."DimCustomer" Cust
			ON  Cust."CustomerAlternateKey" = ACC_TEMP."CustomerAlternateId" AND Cust."ApplicationCode" = ACC_TEMP."ApplicationCode" AND Cust."Current" =  TRUE ;

			-- INSERT NEW ROWS
			INSERT INTO dw."DimAccount"(
				"AccountAlternateKey",
				"ApplicationCode",
				"AccountNumber",
				"PremiseNumber",
				"TimeZoneKey",
				"ClientAccountKey",
				"ClientKey",
				"CustomerKey",
				"ControlAreaKey",
				"StartActiveDateTimeUTC",
				"EndActiveDateTimeUTC",
				"StartActiveDateTimeLocal",
				"EndActiveDateTimeLocal",
				"StartDateTime",
				"EndDateTime",
				"Current")
			SELECT 
					"AccountId",
					"ApplicationCode",
					"AccountNumber",
					"PremiseNumber",
					"InsertionTimeZoneKey",
					"ClientAccountKey",
					"InsertionClientKey",
					"InsertionCustomerKey",
					"InsertionControlAreaKey",
					"StartActiveDateTimeUTC",
					"EndActiveDateTimeUTC",
					"StartActiveDateTimeLocal",
					"EndActiveDateTimeLocal",
					"StartDateTime",
					NULL,
					TRUE
			FROM etl.ACCOUNT_TEMP
			WHERE "AccountKey" IS NULL ;

			-- UPDATE ROWS WITH NO HISTORICAL
			UPDATE dw."DimAccount"

				SET     	
					"ApplicationCode"= etl.ACCOUNT_TEMP."ApplicationCode",
					"AccountNumber"= etl.ACCOUNT_TEMP."AccountNumber",
					"PremiseNumber"= etl.ACCOUNT_TEMP."PremiseNumber",
					"TimeZoneKey"= etl.ACCOUNT_TEMP."InsertionTimeZoneKey",
					"ClientAccountKey"= etl.ACCOUNT_TEMP."ClientAccountKey",
					"ClientKey"= etl.ACCOUNT_TEMP."InsertionClientKey",
					"CustomerKey"= etl.ACCOUNT_TEMP."InsertionCustomerKey",
					"ControlAreaKey"= etl.ACCOUNT_TEMP."InsertionControlAreaKey",
					"StartActiveDateTimeUTC"= etl.ACCOUNT_TEMP."StartActiveDateTimeUTC",
					"EndActiveDateTimeUTC"= etl.ACCOUNT_TEMP."EndActiveDateTimeUTC",
					"StartActiveDateTimeLocal"= etl.ACCOUNT_TEMP."StartActiveDateTimeLocal",
					"EndActiveDateTimeLocal"= etl.ACCOUNT_TEMP."EndActiveDateTimeLocal"

			FROM     etl.ACCOUNT_TEMP
			WHERE    etl.ACCOUNT_TEMP."AccountKey" IS NOT NULL  
				  AND     etl.ACCOUNT_TEMP."AccountKey"              = dw."DimAccount"."AccountKey"
				  AND    COALESCE(etl.ACCOUNT_TEMP."InsertionClientKey",0)      = COALESCE(dw."DimAccount"."ClientKey",0)
				  AND    COALESCE(etl.ACCOUNT_TEMP."InsertionCustomerKey",0)    = COALESCE(dw."DimAccount"."CustomerKey",0)
				  AND    COALESCE(etl.ACCOUNT_TEMP."InsertionControlAreaKey",0) = COALESCE(dw."DimAccount"."ControlAreaKey",0) ;

			-- UPDATE ROWS WITH HISTORICAL (ENDDATETIME UPDATE)
			UPDATE dw."DimAccount"
			SET 
				"EndDateTime" = now()::timestamp,
				"Current" = FALSE                  
			FROM  etl.ACCOUNT_TEMP 
			WHERE    etl.ACCOUNT_TEMP."AccountKey" IS NOT NULL 
				  AND  etl.ACCOUNT_TEMP."AccountKey" = dw."DimAccount"."AccountKey"
				  AND  (
			  			COALESCE (etl.ACCOUNT_TEMP."InsertionClientKey",-1)      != COALESCE (dw."DimAccount"."ClientKey",-1) 
						OR 
						COALESCE (etl.ACCOUNT_TEMP."InsertionCustomerKey",-1)    != COALESCE (dw."DimAccount"."CustomerKey",-1)
						OR
						COALESCE (etl.ACCOUNT_TEMP."InsertionControlAreaKey",-1) != COALESCE (dw."DimAccount"."ControlAreaKey",-1)
					   );

			-- INSERT HISTORICAL ROWS
			INSERT INTO dw."DimAccount"(
				"AccountAlternateKey",
				"ApplicationCode",
				"AccountNumber",
				"PremiseNumber",
				"TimeZoneKey",
				"ClientAccountKey",
				"ClientKey",
				"CustomerKey",
				"ControlAreaKey",
				"StartActiveDateTimeUTC",
				"EndActiveDateTimeUTC",
				"StartActiveDateTimeLocal",
				"EndActiveDateTimeLocal",
				"StartDateTime",
				"EndDateTime",
				"Current")
			SELECT 
					ATemp."AccountId",
					ATemp."ApplicationCode",
					ATemp."AccountNumber",
					ATemp."PremiseNumber",
					ATemp."InsertionTimeZoneKey",
					ATemp."ClientAccountKey",
					ATemp."InsertionClientKey",
					ATemp."InsertionCustomerKey",
					ATemp."InsertionControlAreaKey",
					ATemp."StartActiveDateTimeUTC",
					ATemp."EndActiveDateTimeUTC",
					ATemp."StartActiveDateTimeLocal",
					ATemp."EndActiveDateTimeLocal",
					now()::timestamp as "StartDateTime",
					NULL,
					TRUE
			FROM etl.ACCOUNT_TEMP ATemp
			JOIN dw."DimAccount" ASrc 
			ON ASrc."AccountKey" = ATemp."AccountKey"
			WHERE         ATemp."AccountKey" IS NOT NULL  
					 AND  (
							COALESCE (ATemp."InsertionClientKey",-1)      != COALESCE (ASrc."ClientKey",-1) 
							OR 
							COALESCE (ATemp."InsertionCustomerKey",-1)    != COALESCE (ASrc."CustomerKey",-1)
							OR
							COALESCE (ATemp."InsertionControlAreaKey",-1) != COALESCE (ASrc."ControlAreaKey",-1)
						   );
	
END;
$BODY$;

ALTER FUNCTION etl."MergeAccountData"()
    OWNER TO postgres;


-----------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('065_DW_ETL_SchemaChange_Create_Scripts');-- FUNCTION: dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"clientId" integer,
	"ISO_Id" integer,
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" integer, "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
		FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
		
		AND ("clientId" IS NULL OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" IS NULL OR iso."ISOAlternateKey" = "ISO_Id") 
		
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('066_DW_stpGetSettlementIntervals');DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone);
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer);


CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone,
	"clientId" integer DEFAULT null::integer,
	"ISO_Id" integer DEFAULT null::integer)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" integer, "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
	    FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
		
		AND ("clientId" Is Null OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" Is Null OR iso."ISOAlternateKey" = "ISO_Id") 
		
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('067_DW_stpGetSettlementIntervals_clientOptional');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN


    RETURN  QUERY
    with intervalsData_CTE  as
	(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr"
		
        FROM dw."FactIntervals" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
	          AND chan."IsDelivered" = TRUE
			  AND fct."InsertionDateTime" <= "transactionDate"
			  AND status."Code" = 'CURRENT'
			  AND meter."ApplicationCode"  = 'SETT'
	),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('068_DW_GetMisoData');DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer);


CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone,
	"clientId" integer DEFAULT NULL::integer,
	"ISO_Id" integer DEFAULT NULL::integer)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" integer, "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
	    FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey" 
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey" 
		LEFT JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey" 
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
		
		AND ("clientId" Is Null OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" Is Null OR iso."ISOAlternateKey" = "ISO_Id") 
		
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;


INSERT INTO public."DatabaseVersionHistory" VALUES ('069_DW_sptGetSettlementIntervals_LeftJoinDimCustomer');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN


    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
	          AND chan."IsDelivered" = TRUE
			  AND fct."InsertionDateTime" <= "transactionDate"
			  AND status."Code" = 'CURRENT'
			  AND meter."ApplicationCode"  = 'SETT'
		),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"--,
                 --"ChannelAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";
END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('070_DW_stpGetMisoData');-- FUNCTION: dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptMonthlyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"monthDate" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Account" character varying, "Adj_Consumption" numeric, "StartDate" Date, "EndDate" Date, "DataType" TEXT, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("monthDate"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("monthDate" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "monthDate" + interval '1' day;	  

"som" Date := date_trunc('MONTH', "monthDate"::Date);
"eom" timestamp := date_trunc('MONTH', "monthDate"::timestamp) + INTERVAL '1 MONTH - 3 ms';

BEGIN

    RETURN  QUERY

SELECT act."AccountNumber" AS "Account"
	  ,SUM(fct."UsageDLF") AS "Adj_Consumption"
	  ,"som"::Date AS "StartDate"
      ,"eom"::Date AS "EndDate"
	  ,(CASE WHEN (ofv."Code" = 'CALC') THEN 'MONTHLY' ELSE 'INTERVAL' END) AS "DataType"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings"


FROM dw."FactIntervals_SETT" fct 
		JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
		JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
		JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
	    JOIN dw."DimOriginFactValue" ofv 
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"   
		JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" =  act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"   
		
WHERE   fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "monthDate"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id" 
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )													 														
												
GROUP BY act."AccountNumber", (CASE WHEN (ofv."Code" = 'CALC') THEN 'MONTHLY' ELSE 'INTERVAL' END), ofv."OriginValueEnglishDescription"
ORDER BY act."AccountNumber";
		
	
END;
$BODY$;

ALTER FUNCTION dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

		
INSERT INTO public."DatabaseVersionHistory" VALUES ('071_DW_procRptMonthlyTotals');DROP FUNCTION IF EXISTS dw."stpGetSettlementInfos";
CREATE or REPLACE FUNCTION dw."stpGetSettlementInfos" ( "clientIdParam"      INTEGER,
                                                        "isoIdParam"         INTEGER,
                                                        "startTradeDayUTC"   TIMESTAMP,
                                                        "transactionDate"    TIMESTAMP)
RETURNS
  TABLE
      (
          "TotalAccounts"        BIGINT ,
          "TotalIntervals"       BIGINT ,
          "CompletedIntervals"   BIGINT ,
          "EstimatedIntervals"   BIGINT ,
          "ExtraneousMeterReads" BIGINT ,
          "TotalKWH"             NUMERIC(28,4),
		  "TotalKWHReal"		 NUMERIC(28,4),
          "TotalMeters"          BIGINT,
          "TotalChannels"        BIGINT
      ) AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN

    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                orig."Code" as "OriginConsumptionCode",
                act."AccountAlternateKey",
                meter."MeterAlternateKey",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateUTCKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimOriginFactValue" orig
          ON orig."OriginConsumptionKey" = fct."OriginConsumptionKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND status."Code" = 'CURRENT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND fct."InsertionDateTime" <= "transactionDate"
              AND act."ApplicationCode"    = 'SETT'
              AND meter."ApplicationCode"  = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
		),
    totals_CTE as
    (
        SELECT
              COUNT(DISTINCT "AccountAlternateKey") AS "Accounts",
              COUNT(*) AS "Intervals",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('REAL','CALC') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsCompleted",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('ESTI') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsEstimated",
              0::BIGINT AS "ExtraneousReads",
              sum("UsageDLF") AS "KWH",
			  sum(
                CASE
                    WHEN "OriginConsumptionCode" in ('REAL') THEN "Usage"
                    ELSE 0
                END
			  ) AS "KWHReal",
              COUNT(DISTINCT "MeterAlternateKey") AS "Meters",
              COUNT(DISTINCT "ChannelAlternateKey") AS "Channels"
        FROM intervalsData_CTE
    )
    SELECT  *
    FROM totals_CTE;
END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('072_DW_SettlementInfos_Create_Scripts');DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       fct."UsageDLF" AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "tradeDay1"
			  AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       fct."UsageDLF" AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey2"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey2"
              AND fct."EndDateTimeUTC"  >=  "tradeDay2"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC2"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				           
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   tmpResult."Account1",
				   tmpResult."Adj_Total1",
				   tmpResult."Adj_Total2",
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   tmpResult."Account2",
				   tmpResult."Difference_Adj_1"
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
	    
				
ORDER BY tmpResult."Account1", tmpResult."Account2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('073_DW_procRptCompare2DaysByAllAccountsDetails');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
          "startDateTimeLocal"         TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN
    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",

                CASE WHEN ((((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1) AND (dteLocal."FullAlternateDateKey" > "startTradeDayUTC")) THEN (dteLocal."FullAlternateDateKey" + interval '-1' day)
                  ELSE dteLocal."FullAlternateDateKey" END AS "FullAlternateDateKey",


                CASE WHEN TO_CHAR(fct."EndDateTimeLocal", 'MI') = '00' THEN
                                CASE WHEN ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1
                                          THEN 23
                                          ELSE ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1)
                                END
                                ELSE (TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer)
                END  "24_hr",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE fct."EndDateTimeLocal"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeLocal"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
		),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";
END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('074_DW_stpGetMisoData_LocalDate');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
          "startDateTimeLocal"         TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN
    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",

                CASE WHEN ((((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1) AND (dteLocal."FullAlternateDateKey" > "startTradeDayUTC")) THEN (dteLocal."FullAlternateDateKey" + interval '-1' day)
                  ELSE dteLocal."FullAlternateDateKey" END AS "FullAlternateDateKey",


                CASE WHEN TO_CHAR(fct."EndDateTimeLocal", 'MI') = '00' THEN
                                CASE WHEN ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1
                                          THEN 23
                                          ELSE ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1)
                                END
                                ELSE (TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer)
                END  "24_hr",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
		),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";
END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('075_DW_stpGetMisoData');-- FUNCTION: dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "tradeDay1"
			  AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey2"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey2"
              AND fct."EndDateTimeUTC"  >=  "tradeDay2"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC2"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
       	  fct."InsertionDateTime"::Date,
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   tmpResult."Account1",
				   SUM(tmpResult."Adj_Total1"),
				   SUM(tmpResult."Adj_Total2"),
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   tmpResult."Account2",
				   SUM(tmpResult."Difference_Adj_1")
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	   	 tmpResult."Account1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2",
	     tmpResult."Account2"
	    
				
ORDER BY tmpResult."Account1", tmpResult."Account2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('076_DW_procRptCompare2DaysByAllAccountsDetails');-- FUNCTION: dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccounts"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "tradeDay1"
			  AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey2"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey2"
              AND fct."EndDateTimeUTC"  >=  "tradeDay2"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC2"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
       	  fct."InsertionDateTime"::Date,
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   SUM(tmpResult."Adj_Total1"),
				   SUM(tmpResult."Adj_Total2"),
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   SUM(tmpResult."Difference_Adj_1")
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('077_DW_procRptCompare2DaysByAllAccounts');-- FUNCTION: dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccounts"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ControlArea" character varying, 
				  "TradeDay1" date, 
				  "Accounts1" bigint, 
				  "TotalMWh1" numeric, 
				  "TotalMWh2" numeric, 
				  "TradeDay2" date, 
				  "Accounts2" bigint, 
				  "Diff" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  

BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       ca."Abbreviation",
       act."AccountNumber",
       fct."UsageDLF" AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "tradeDay1"
			  AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       ca."Abbreviation",
       act."AccountNumber",
       fct."UsageDLF" AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey2"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey2"
              AND fct."EndDateTimeUTC"  >=  "tradeDay2"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC2"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				           
)
SELECT  COALESCE(tmpResult."ControlArea1", tmpResult."ControlArea2") AS "ControlArea",
		tmpResult."TradeDay1",
		COUNT(tmpResult."Account1") AS "Accounts1",
		SUM(tmpResult."Adj_Total1") AS "TotalMWh1",
		SUM(tmpResult."Adj_Total2") AS "TotalMWh2",
		tmpResult."TradeDay2",
		COUNT(tmpResult."Account2") AS "Accounts2",
		SUM(tmpResult."Difference_Adj_1") AS "Diff"
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
							
			   
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY COALESCE(tmpResult."ControlArea1", tmpResult."ControlArea2"),
		 tmpResult."TradeDay1",
		 tmpResult."TradeDay2";
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('078_DW_procRptCompare2DaysByAllAccounts');DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone);
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer);


CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone,
	"clientId" integer DEFAULT null::integer,
	"ISO_Id" integer DEFAULT null::integer)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" integer, "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,da."AccountNumber" as "AccountNumber"	
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
	    FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
		
		AND ("clientId" Is Null OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" Is Null OR iso."ISOAlternateKey" = "ISO_Id") 
		
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('079_DW_stpGetSettlementIntervals_clientOptional');DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone);
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer);


CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone,
	"clientId" integer DEFAULT null::integer,
	"ISO_Id" integer DEFAULT null::integer)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" character varying(50), "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,da."AccountNumber" as "AccountNumber"	
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
	    FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
		
		AND ("clientId" Is Null OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" Is Null OR iso."ISOAlternateKey" = "ISO_Id") 
		
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('080_DW_stpGetSettlementIntervals_clientOptional');DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);

INSERT INTO public."DatabaseVersionHistory" VALUES ('081_DW_procRptCompare2DaysByAllAccounts');DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone);
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer);

CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone,
	"clientId" integer DEFAULT NULL::integer,
	"ISO_Id" integer DEFAULT NULL::integer)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" character varying, "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,da."AccountNumber" as "AccountNumber"	
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
	    FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		LEFT JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey" 
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
		
		AND ("clientId" Is Null OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" Is Null OR iso."ISOAlternateKey" = "ISO_Id") 
		
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('082_DW_stpGetSettlementIntervals_clientOptional');-- FUNCTION: dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptDailyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"startTradeDayUTC" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Tradeday" date, "TransactionDate" timestamp without time zone, "Account" character varying, "MeterID" character varying, "ControlArea" character varying, "RawDailyUsage" numeric, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
   
"startTradeDayUTCKey"	INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"		INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);

 "endTradeDayUTC" 		TIMESTAMP := "startTradeDayUTC" + interval '1' day;
 "startDateTimeLocal" 	TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN

    RETURN  QUERY
	
SELECT tmp."Tradeday"
	  ,tmp."TransactionDate" 
	  ,tmp."Account"
	  ,tmp."MeterID"
	  ,tmp."ControlArea"
	  ,SUM(tmp."RawDailyUsage")
	  ,tmp."IntervalReadings"
	  
	  
FROM (
SELECT "startTradeDayUTC"::Date AS "Tradeday"
	  ,"transactionDate" AS "TransactionDate" 
	  ,act."AccountNumber" AS "Account"
	  ,mt."DeviceCode" AS "MeterID"
	  ,ca."Abbreviation" AS "ControlArea"
	  ,fct."Usage" AS "RawDailyUsage"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings"

FROM dw."FactIntervals_SETT" fct 
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"        
		JOIN dw."DimOriginFactValue" ofv
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"      
		JOIN dw."DimControlArea" ca																						
		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
		JOIN dw."DimMeter" mt
		  ON mt."MeterKey" = fct."MeterKey"  
			
	    WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
	
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
)tmp			
			
		GROUP BY tmp."Tradeday"
	  		 	 ,tmp."TransactionDate" 
	  		 	 ,tmp."Account"
	  		 	 ,tmp."MeterID"
	    	 	 ,tmp."ControlArea"
	  		 	 ,tmp."IntervalReadings"
			 
		ORDER BY tmp."Account"
	  			 ,tmp."MeterID"
	  			 ,tmp."ControlArea";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('083_DW_procRptDailyTotals_LocalDate');DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  
"startDateTimeLocal" 	TIMESTAMP := "tradeDay1" + interval '15' MINUTE;

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"startDateTimeLocal2" 	TIMESTAMP := "tradeDay2" + interval '15' MINUTE;
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal2"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC2"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
       	  fct."InsertionDateTime"::Date,
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   tmpResult."Account1",
				   SUM(tmpResult."Adj_Total1"),
				   SUM(tmpResult."Adj_Total2"),
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   tmpResult."Account2",
				   SUM(tmpResult."Difference_Adj_1")
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	   	 tmpResult."Account1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2",
	     tmpResult."Account2"
	    
				
ORDER BY tmpResult."Account1", tmpResult."Account2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('084_DW_RptCompare2DaysByAllAccountsDetails_LocalDate');DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccounts"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ControlArea" character varying, "TradeDay1" date, "TradeDay2" date, "AccountsDay1" bigint, "AccountsDay2" bigint, "TotalMwhDay1" numeric, "TotalMwhDay2" numeric, "Diff" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  
"startDateTimeLocal" 	TIMESTAMP := "tradeDay1" + interval '15' MINUTE;

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"startDateTimeLocal2" 	TIMESTAMP := "tradeDay2" + interval '15' MINUTE;
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal2"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC2"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
       	  fct."InsertionDateTime"::Date,
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ControlArea1" AS "ControlArea",
		tmpResult."TradeDay1",
		tmpResult."TradeDay2",
		COUNT(tmpResult."Account1") AS "AccountsDay1",
	    COUNT(tmpResult."Account2") AS "AccountsDay2",
		SUM(tmpResult."Adj_Total1") AS "TotalMwhDay1",
		SUM(tmpResult."Adj_Total2") AS "TotalMwhDay2",
		(COALESCE(SUM(tmpResult."Adj_Total1"), 0) - COALESCE(SUM(tmpResult."Adj_Total2"), 0)) AS "Diff"
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2";
	    
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('085_DW_procRptCompare2DaysByAllAccounts_LocalDate');DROP FUNCTION IF EXISTS dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptMonthlyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"monthDate" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Account" character varying, "Adj_Consumption" numeric, "StartDate" date, "EndDate" date, "DataType" text, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("monthDate"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("monthDate" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "monthDate" + interval '1' day;	  

"som" Date := date_trunc('MONTH', "monthDate"::Date);
"eom" timestamp := date_trunc('MONTH', "monthDate"::timestamp) + INTERVAL '1 MONTH - 3 ms';

BEGIN

    RETURN  QUERY

SELECT act."AccountNumber" AS "Account"
	  ,SUM(fct."UsageDLF") AS "Adj_Consumption"
	  ,"som"::Date AS "StartDate"
      ,"eom"::Date AS "EndDate"
	  ,(CASE WHEN (ofv."Code" = 'CALC') THEN 'MONTHLY' ELSE 'INTERVAL' END) AS "DataType"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings"


FROM dw."FactIntervals_SETT" fct 
		JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
		JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
		JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
	    JOIN dw."DimOriginFactValue" ofv 
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"   
		JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" =  act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"   
		
WHERE   fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "monthDate"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
			
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id" 
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )													 														
												
GROUP BY act."AccountNumber", (CASE WHEN (ofv."Code" = 'CALC') THEN 'MONTHLY' ELSE 'INTERVAL' END), ofv."OriginValueEnglishDescription"
ORDER BY act."AccountNumber";
		
	
END;
$BODY$;

ALTER FUNCTION dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;
	
		
INSERT INTO public."DatabaseVersionHistory" VALUES ('086_DW_procRptMonthlyTotals');DROP FUNCTION IF EXISTS dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptMonthlyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"monthDate" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Account" character varying, "Adj_Consumption" numeric, "StartDate" date, "EndDate" date, "DataType" text) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("monthDate"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("monthDate" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "monthDate" + interval '1' day;	  

"som" Date := date_trunc('MONTH', "monthDate"::Date);
"eom" timestamp := date_trunc('MONTH', "monthDate"::timestamp) + INTERVAL '1 MONTH - 3 ms';

BEGIN

    RETURN  QUERY

SELECT act."AccountNumber" AS "Account"
	  ,SUM(fct."UsageDLF") AS "Adj_Consumption"
	  ,"som"::Date AS "StartDate"
      ,"eom"::Date AS "EndDate"
	  ,(CASE WHEN (ofv."Code" = 'CALC') THEN 'MONTHLY' ELSE 'INTERVAL' END) AS "DataType"
	  

FROM dw."FactIntervals_SETT" fct 
		JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
		JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
		JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
	    JOIN dw."DimOriginFactValue" ofv 
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"   
		JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" =  act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"   
		
WHERE   fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "monthDate"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
			
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id" 
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )													 														
												
GROUP BY act."AccountNumber", (CASE WHEN (ofv."Code" = 'CALC') THEN 'MONTHLY' ELSE 'INTERVAL' END), ofv."OriginValueEnglishDescription"
ORDER BY act."AccountNumber";
		
	
END;
$BODY$;

ALTER FUNCTION dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('087_DW_procRptMonthlyTotals');DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer);

CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone,
	"clientId" integer DEFAULT NULL::integer,
	"ISO_Id" integer DEFAULT NULL::integer)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" character varying, "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE

"_startDateTime" TIMESTAMP WITH TIME ZONE :=  "startDateTime" + INTERVAL '15 minute';
"_endDateTime" TIMESTAMP WITH TIME ZONE :=  "endDateTime"::Date;

BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,da."AccountNumber" as "AccountNumber"	
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
	 FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		LEFT JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey" 
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "_startDateTime" AND fis."EndDateTimeLocal" <= "_endDateTime"
		
		AND ("clientId" Is Null OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" Is Null OR iso."ISOAlternateKey" = "ISO_Id") 
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer)
    OWNER TO postgres;
			
INSERT INTO public."DatabaseVersionHistory" VALUES ('088_DW_stpGetSettlementIntervals');DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  
"startDateTimeLocal" 	TIMESTAMP := "tradeDay1" + interval '15' MINUTE;

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"startDateTimeLocal2" 	TIMESTAMP := "tradeDay2" + interval '15' MINUTE;
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal2"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC2"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
       	  fct."InsertionDateTime",
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   tmpResult."Account1",
				   SUM(tmpResult."Adj_Total1"),
				   SUM(tmpResult."Adj_Total2"),
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   tmpResult."Account2",
				   SUM(tmpResult."Difference_Adj_1")
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd HH24:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd HH24:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	   	 tmpResult."Account1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2",
	     tmpResult."Account2"
	    
				
ORDER BY tmpResult."Account1", tmpResult."Account2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('089_DW_procRptCompare2DaysByAllAccountsDetails');DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  
"startDateTimeLocal" 	TIMESTAMP := "tradeDay1" + interval '15' MINUTE;

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"startDateTimeLocal2" 	TIMESTAMP := "tradeDay2" + interval '15' MINUTE;
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2"::Date,
       MAX(fct."InsertionDateTime"::Timestamp) AS "InsertionDateTime2",
	   fct."InsertionDateTime"::Date AS "TransDate2" ,  
	   ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal2"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC2"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
		"TransDate2",
		act."AccountNumber",
        ca."Abbreviation"
         
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   tmpResult."Account1",
				   SUM(tmpResult."Adj_Total1"),
				   SUM(tmpResult."Adj_Total2"),
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   tmpResult."Account2",
				   SUM(tmpResult."Difference_Adj_1")
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd HH24:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime2",'yyyy-mm-dd HH24:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	   	 tmpResult."Account1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2",
	     tmpResult."Account2"
	    
				
ORDER BY tmpResult."Account1", tmpResult."Account2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('090_DW_procRptCompare2DaysByAllAccountsDetails');
ALTER TABLE dw."FactIntervals_SETT" ADD "IsDelivered" boolean;

ALTER TABLE stg."FactIntervals" ADD "IsDelivered" boolean;

ALTER TABLE etl.facts_temp_sett ADD "stg_IsDelivered" boolean;

INSERT INTO public."DatabaseVersionHistory" VALUES ('091_DW_addFlowDirectionColumn');
-----------------------------------------------------------------------
DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals_SETT";
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT";

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey",
				  fct."IsDelivered"   as "dw_IsDelivered"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey",
			fct."IsDelivered"       as "stg_IsDelivered"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );


  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

---------------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('092_DW_stpMergeDailyFactIntervals_SETT');ALTER TABLE etl.facts_temp_sett ADD "dw_IsDelivered" boolean;

INSERT INTO public."DatabaseVersionHistory" VALUES ('093_DW_addIsDeliveredFactTempSett');
-----------------------------------------------------------------------
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT";

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey",
				  fct."IsDelivered"   as "dw_IsDelivered"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey",
			fct."IsDelivered"       as "stg_IsDelivered"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett (
	"dw_IntervalKey",
	"dw_InsertionDateTime" ,
	"dw_MonthlyRead",
	"dw_Usage",
	"dw_UsageDLF",
	"dw_Demand",
	"dw_DemandDLF",
	"dw_DLP",
	"dw_DLPSum",
	"dw_DLPRation",
	"dw_DLF",
	"dw_StartDateTimeUTC",
	"dw_EndDateTimeUTC",
	"dw_StartDateTimeLocal",
	"dw_EndDateTimeLocal",
	"dw_AccountKey",
	"dw_SDPKey",
	"dw_MeterKey",
	"dw_ChannelKey",
	"dw_OriginConsumptionKey",
	"dw_FactValueGoalKey",
	"dw_ServiceTypeKey",
	"dw_ParentIntervalKey",
	"dw_FactStatusKey",
	"dw_EndDateLocalKey",
	"dw_EndTimeLocalKey",
	"dw_EndDateUTCKey",
	"dw_EndTimeUTCKey",
	"dw_RecordedDateUTCKey",
	"dw_ClientKey",
	"dw_IsDelivered"  
  )
  SELECT "dw_IntervalKey",
  		 "dw_InsertionDateTime" ,
		 "dw_MonthlyRead",
		 "dw_Usage",
		 "dw_UsageDLF",
		 "dw_Demand",
		 "dw_DemandDLF",
		 "dw_DLP",
		 "dw_DLPSum",
		 "dw_DLPRation",
		 "dw_DLF",
		 "dw_StartDateTimeUTC",
		 "dw_EndDateTimeUTC",
		 "dw_StartDateTimeLocal",
		 "dw_EndDateTimeLocal",
		 "dw_AccountKey",
		 "dw_SDPKey",
		 "dw_MeterKey",
		 "dw_ChannelKey",
		 "dw_OriginConsumptionKey",
		 "dw_FactValueGoalKey",
		 "dw_ServiceTypeKey",
		 "dw_ParentIntervalKey",
		 "dw_FactStatusKey",
		 "dw_EndDateLocalKey",
		 "dw_EndTimeLocalKey",
		 "dw_EndDateUTCKey",
		 "dw_EndTimeUTCKey",
		 "dw_RecordedDateUTCKey",
		 "dw_ClientKey",
		 "dw_IsDelivered"  
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );


  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

---------------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('094_DW_exposeAllFieldsInsert_stpMergeDailyFactIntervals_SETT');
-----------------------------------------------------------------------
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT";

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey",
				  fct."IsDelivered"   as "dw_IsDelivered"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey",
			fct."IsDelivered"       as "stg_IsDelivered"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett (
	"dw_IntervalKey",
	"dw_InsertionDateTime" ,
	"dw_MonthlyRead",
	"dw_Usage",
	"dw_UsageDLF",
	"dw_Demand",
	"dw_DemandDLF",
	"dw_DLP",
	"dw_DLPSum",
	"dw_DLPRation",
	"dw_DLF",
	"dw_StartDateTimeUTC",
	"dw_EndDateTimeUTC",
	"dw_StartDateTimeLocal",
	"dw_EndDateTimeLocal",
	"dw_AccountKey",
	"dw_SDPKey",
	"dw_MeterKey",
	"dw_ChannelKey",
	"dw_OriginConsumptionKey",
	"dw_FactValueGoalKey",
	"dw_ServiceTypeKey",
	"dw_ParentIntervalKey",
	"dw_FactStatusKey",
	"dw_EndDateLocalKey",
	"dw_EndTimeLocalKey",
	"dw_EndDateUTCKey",
	"dw_EndTimeUTCKey",
	"dw_RecordedDateUTCKey",
	"dw_ClientKey",
	"dw_IsDelivered",

    "stg_MonthlyRead",
    "stg_Usage",
    "stg_UsageDLF",
    "stg_Demand",
    "stg_DemandDLF",
    "stg_DLP",
    "stg_DLPSum",
    "stg_DLPRation",
    "stg_DLF",
    "stg_StartDateTimeUTC",
    "stg_EndDateTimeUTC",
    "stg_StartDateTimeLocal",
    "stg_EndDateTimeLocal",
    "stg_ClientKey",
    "stg_AccountKey",
    "stg_SDPKey",
    "stg_MeterKey",
    "stg_ChannelKey",
    "stg_OriginConsumptionKey",
    "stg_OriginConsumptionCode",
    "stg_ServiceTypeKey",
    "stg_EndDateLocalKey",
    "stg_EndDateUTCKey",
    "stg_EndTimeLocalKey",
    "stg_EndTimeUTCKey",
    "stg_RecordedDateKey",
	"stg_IsDelivered"
  )
  SELECT "dw_IntervalKey",
  		 "dw_InsertionDateTime" ,
		 "dw_MonthlyRead",
		 "dw_Usage",
		 "dw_UsageDLF",
		 "dw_Demand",
		 "dw_DemandDLF",
		 "dw_DLP",
		 "dw_DLPSum",
		 "dw_DLPRation",
		 "dw_DLF",
		 "dw_StartDateTimeUTC",
		 "dw_EndDateTimeUTC",
		 "dw_StartDateTimeLocal",
		 "dw_EndDateTimeLocal",
		 "dw_AccountKey",
		 "dw_SDPKey",
		 "dw_MeterKey",
		 "dw_ChannelKey",
		 "dw_OriginConsumptionKey",
		 "dw_FactValueGoalKey",
		 "dw_ServiceTypeKey",
		 "dw_ParentIntervalKey",
		 "dw_FactStatusKey",
		 "dw_EndDateLocalKey",
		 "dw_EndTimeLocalKey",
		 "dw_EndDateUTCKey",
		 "dw_EndTimeUTCKey",
		 "dw_RecordedDateUTCKey",
		 "dw_ClientKey",
		 "dw_IsDelivered",  

		"stg_MonthlyRead",
		"stg_Usage",
		"stg_UsageDLF",
		"stg_Demand",
		"stg_DemandDLF",
		"stg_DLP",
		"stg_DLPSum",
		"stg_DLPRation",
		"stg_DLF",
		"stg_StartDateTimeUTC",
		"stg_EndDateTimeUTC",
		"stg_StartDateTimeLocal",
		"stg_EndDateTimeLocal",
		"stg_ClientKey",
		"stg_AccountKey",
		"stg_SDPKey",
		"stg_MeterKey",
		"stg_ChannelKey",
		"stg_OriginConsumptionKey",
		"stg_OriginConsumptionCode",
		"stg_ServiceTypeKey",
		"stg_EndDateLocalKey",
		"stg_EndDateUTCKey",
		"stg_EndTimeLocalKey",
		"stg_EndTimeUTCKey",
		"stg_RecordedDateKey",
		"stg_IsDelivered"

  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );


  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;


---------------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('095_DW_stpMergeDailyFactIntervals_SETT');
-----------------------------------------------------------------------
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT";

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey",
				  fct."IsDelivered"   as "dw_IsDelivered"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey",
			fct."IsDelivered"       as "stg_IsDelivered"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett (
	"dw_IntervalKey",
	"dw_InsertionDateTime" ,
	"dw_MonthlyRead",
	"dw_Usage",
	"dw_UsageDLF",
	"dw_Demand",
	"dw_DemandDLF",
	"dw_DLP",
	"dw_DLPSum",
	"dw_DLPRation",
	"dw_DLF",
	"dw_StartDateTimeUTC",
	"dw_EndDateTimeUTC",
	"dw_StartDateTimeLocal",
	"dw_EndDateTimeLocal",
	"dw_AccountKey",
	"dw_SDPKey",
	"dw_MeterKey",
	"dw_ChannelKey",
	"dw_OriginConsumptionKey",
	"dw_FactValueGoalKey",
	"dw_ServiceTypeKey",
	"dw_ParentIntervalKey",
	"dw_FactStatusKey",
	"dw_EndDateLocalKey",
	"dw_EndTimeLocalKey",
	"dw_EndDateUTCKey",
	"dw_EndTimeUTCKey",
	"dw_RecordedDateUTCKey",
	"dw_ClientKey",
	"dw_IsDelivered",

    "stg_MonthlyRead",
    "stg_Usage",
    "stg_UsageDLF",
    "stg_Demand",
    "stg_DemandDLF",
    "stg_DLP",
    "stg_DLPSum",
    "stg_DLPRation",
    "stg_DLF",
    "stg_StartDateTimeUTC",
    "stg_EndDateTimeUTC",
    "stg_StartDateTimeLocal",
    "stg_EndDateTimeLocal",
    "stg_ClientKey",
    "stg_AccountKey",
    "stg_SDPKey",
    "stg_MeterKey",
    "stg_ChannelKey",
    "stg_OriginConsumptionKey",
    "stg_OriginConsumptionCode",
    "stg_ServiceTypeKey",
    "stg_EndDateLocalKey",
    "stg_EndDateUTCKey",
    "stg_EndTimeLocalKey",
    "stg_EndTimeUTCKey",
    "stg_RecordedDateKey",
	"stg_IsDelivered"
  )
  SELECT "dw_IntervalKey",
  		 "dw_InsertionDateTime" ,
		 "dw_MonthlyRead",
		 "dw_Usage",
		 "dw_UsageDLF",
		 "dw_Demand",
		 "dw_DemandDLF",
		 "dw_DLP",
		 "dw_DLPSum",
		 "dw_DLPRation",
		 "dw_DLF",
		 "dw_StartDateTimeUTC",
		 "dw_EndDateTimeUTC",
		 "dw_StartDateTimeLocal",
		 "dw_EndDateTimeLocal",
		 "dw_AccountKey",
		 "dw_SDPKey",
		 "dw_MeterKey",
		 "dw_ChannelKey",
		 "dw_OriginConsumptionKey",
		 "dw_FactValueGoalKey",
		 "dw_ServiceTypeKey",
		 "dw_ParentIntervalKey",
		 "dw_FactStatusKey",
		 "dw_EndDateLocalKey",
		 "dw_EndTimeLocalKey",
		 "dw_EndDateUTCKey",
		 "dw_EndTimeUTCKey",
		 "dw_RecordedDateUTCKey",
		 "dw_ClientKey",
		 "dw_IsDelivered",  

		"stg_MonthlyRead",
		"stg_Usage",
		"stg_UsageDLF",
		"stg_Demand",
		"stg_DemandDLF",
		"stg_DLP",
		"stg_DLPSum",
		"stg_DLPRation",
		"stg_DLF",
		"stg_StartDateTimeUTC",
		"stg_EndDateTimeUTC",
		"stg_StartDateTimeLocal",
		"stg_EndDateTimeLocal",
		"stg_ClientKey",
		"stg_AccountKey",
		"stg_SDPKey",
		"stg_MeterKey",
		"stg_ChannelKey",
		"stg_OriginConsumptionKey",
		"stg_OriginConsumptionCode",
		"stg_ServiceTypeKey",
		"stg_EndDateLocalKey",
		"stg_EndDateUTCKey",
		"stg_EndTimeLocalKey",
		"stg_EndTimeUTCKey",
		"stg_RecordedDateKey",
		"stg_IsDelivered"

  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
		AND dw_fact."dw_IsDelivered"    = stg_fact."stg_IsDelivered"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );


  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;


---------------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('096_DW_stpMergeDailyFactIntervals_SETT_IsDeliveredKey');----------------------------------------------------------------------
DROP FUNCTION IF EXISTS  dw."procRptCompare2DaysByAllAccounts";

CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccounts"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ControlArea" character varying, "TradeDay1" date, "TradeDay2" date, "AccountsDay1" bigint, "AccountsDay2" bigint, "TotalMwhDay1" numeric, "TotalMwhDay2" numeric, "Diff" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE
    ROWS 1000
AS $BODY$

DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  
"startDateTimeLocal" 	TIMESTAMP := "tradeDay1" + interval '15' MINUTE;

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"startDateTimeLocal2" 	TIMESTAMP := "tradeDay2" + interval '15' MINUTE;
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal2"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC2"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY  ca."Abbreviation",
		  "tradeDay2"::Date,
       	  fct."InsertionDateTime"::Date,
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ControlArea1" AS "ControlArea",
		tmpResult."TradeDay1",
		tmpResult."TradeDay2",
		COUNT(tmpResult."Account1") AS "AccountsDay1",
	    COUNT(tmpResult."Account2") AS "AccountsDay2",
		SUM(tmpResult."Adj_Total1") AS "TotalMwhDay1",
		SUM(tmpResult."Adj_Total2") AS "TotalMwhDay2",
		(COALESCE(SUM(tmpResult."Adj_Total1"), 0) - COALESCE(SUM(tmpResult."Adj_Total2"), 0)) AS "Diff"
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       COALESCE(day1."Abbreviation", day2."Abbreviation") AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2";
	    
END;

$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

    
INSERT INTO public."DatabaseVersionHistory" VALUES ('097_DW_procRptCompare2DaysByAllAccounts');CREATE INDEX DimAccount_AccountKey_ApplicationCode_index ON dw."DimAccount" ("AccountKey", "ApplicationCode");
CREATE INDEX DimClient_ClientKey_ClientAlternateKey_index ON dw."DimClient" ("ClientKey", "ClientAlternateKey");
CREATE INDEX DimServiceType_ServiceTypeKey_Code_index ON dw."DimServiceType" ("ServiceTypeKey", "Code");
CREATE INDEX DimFactStatus_FactStatusKey_Code_index ON dw."DimFactStatus" ("FactStatusKey", "Code");
CREATE INDEX DimControlArea_ISOKey_index ON dw."DimControlArea" ("ISOKey");
CREATE INDEX intervals_y2015m06_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m06 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2015m07_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m07 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2015m08_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m08 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2015m09_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m09 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2015m10_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m10 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2015m11_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m11 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2015m12_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m12 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m01_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m01 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m02_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m02 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m03_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m03 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m04_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m04 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m05_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m05 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m06_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m06 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m07_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m07 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m08_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m08 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m09_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m09 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m10_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m10 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m11_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m11 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m12_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m12 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m01_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m01 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m02_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m02 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m03_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m03 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m04_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m04 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m05_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m05 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m06_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m06 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m07_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m07 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m08_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m08 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m09_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m09 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m10_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m10 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m11_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m11 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m12_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m12 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m01_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m01 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m02_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m02 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m03_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m03 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m04_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m04 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m05_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m05 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m06_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m06 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m07_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m07 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m08_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m08 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m09_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m09 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m10_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m10 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m11_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m11 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m12_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m12 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m01_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m01 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m02_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m02 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m03_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m03 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m04_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m04 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m05_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m05 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m06_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m06 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m07_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m07 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m08_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m08 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m09_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m09 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m10_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m10 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m11_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m11 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m12_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m12 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");

INSERT INTO public."DatabaseVersionHistory" VALUES ('098_DW_CreateIndex');CREATE INDEX DimAccount_AccountKey_ControlAreaKey_index ON dw."DimAccount" ("AccountKey", "ControlAreaKey");
CREATE INDEX DimControlArea_ControlAreaKey_ISOKey_index ON dw."DimControlArea" ("ControlAreaKey", "ISOKey");
CREATE INDEX DimAccount_ClientKey_index ON dw."DimAccount" ("ClientKey");
CREATE INDEX DimAccount_ClientKey_AccountKey_ControlAreaKey_index ON dw."DimAccount" ("ClientKey", "AccountKey", "ControlAreaKey");
CREATE INDEX DimAccount_ClientKey_AccountKey_ApplicationCode_index ON dw."DimAccount" ("ClientKey", "AccountKey", "ApplicationCode");
CREATE INDEX intervals_y2015m06_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m06 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2015m07_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m07 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2015m08_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m08 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2015m09_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m09 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2015m10_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m10 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2015m11_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m11 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2015m12_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m12 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m01_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m01 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m02_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m02 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m03_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m03 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m04_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m04 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m05_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m05 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m06_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m06 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m07_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m07 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m08_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m08 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m09_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m09 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m10_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m10 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m11_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m11 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m12_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m12 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m01_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m01 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m02_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m02 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m03_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m03 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m04_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m04 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m05_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m05 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m06_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m06 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m07_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m07 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m08_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m08 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m09_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m09 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m10_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m10 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m11_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m11 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m12_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m12 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m01_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m01 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m02_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m02 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m03_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m03 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m04_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m04 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m05_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m05 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m06_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m06 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m07_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m07 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m08_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m08 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m09_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m09 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m10_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m10 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m11_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m11 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m12_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m12 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m01_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m01 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m02_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m02 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m03_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m03 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m04_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m04 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m05_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m05 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m06_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m06 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m07_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m07 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m08_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m08 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m09_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m09 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m10_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m10 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m11_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m11 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m12_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m12 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");

INSERT INTO public."DatabaseVersionHistory" VALUES ('099_DW_CreateIndex2');DROP FUNCTION IF EXISTS dw."stpGetSettlementGrandTotalInfos";


CREATE OR REPLACE FUNCTION dw."stpGetSettlementGrandTotalInfos"(
	"clientIdParam" integer,
	"isoIdParam" integer,
	"startTradeDayUTC" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("IndisOperatorId" integer, "Abbreviation" character varying, "Name" character varying, "TotalAccounts" bigint, "TotalKWH" numeric, "TotalKWHReal" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN

    RETURN  QUERY
   
				SELECT
                
				ca."ControlAreaAlternateKey" as "IndisOperatorId",
				ca."Abbreviation",
				ca."Name",
              	COUNT(DISTINCT act."AccountAlternateKey") AS "TotalAccounts",   
              	sum(fct."UsageDLF") AS "TotalKWH",
			  	sum(
                CASE
                    WHEN orig."Code" in ('REAL') THEN fct."Usage"
                    ELSE 0
                END
			  	) AS "TotalKWHReal"
              	
			
	FROM dw."FactIntervals_SETT" fct 
		JOIN dw."DimAccount" act 
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli 
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimOriginFactValue" orig
          ON orig."OriginConsumptionKey" = fct."OriginConsumptionKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"
       		
   WHERE   fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
    	AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
        AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
        AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
        AND serv."Code" = 'SETT'
        AND status."Code" = 'CURRENT'
        AND cli."ClientAlternateKey" = "clientIdParam"
        AND fct."InsertionDateTime" <= "transactionDate"
        AND act."ApplicationCode"    = 'SETT'
        AND meter."ApplicationCode"  = 'SETT'
        AND iso."ISOAlternateKey" = "isoIdParam"
			
	GROUP BY 
		ca."ControlAreaAlternateKey",
		ca."Abbreviation",			
		ca."Name";

END

$BODY$;

ALTER FUNCTION dw."stpGetSettlementGrandTotalInfos"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('100_DW_stpGetSettlementGrandTotalInfos');DROP FUNCTION IF EXISTS etl."GetTimeData"();

CREATE OR REPLACE FUNCTION etl."GetTimeData"()
  RETURNS TABLE(key integer, time_value text, hour_12 text, hour_24 text, am_pm text, day_minutes double precision, time05min double precision, time10min integer, time15min integer, time30min integer, time60min double precision, time_value1 text)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY
	SELECT
        CAST(to_char(minute, 'hh24mi') AS INTEGER) AS key,
        to_char(minute, 'hh24mi') AS time_value,
        to_char(minute, 'hh12') hour_12,
        to_char(minute, 'hh24') AS hour_24,
        case
            when to_char(minute, 'hh24:mi') BETWEEN '00:00' AND '11:59' then 'AM'
            else 'PM'
        end AS am_pm,
        extract(minute FROM minute) day_minutes,
        case
            when extract(minute FROM minute) in(0) then 11
            else (extract(minute FROM minute) / 5) -1
        end AS time05Min,
        case
            when extract(minute FROM minute) in(5,10) then 0
            when extract(minute FROM minute) in(15,20) then 1
            when extract(minute FROM minute) in(25,30) then 2
            when extract(minute FROM minute) in(35,40) then 3
            when extract(minute FROM minute) in(45,50) then 4
            else 5
        end AS time10Min,
        case
            when extract(minute FROM minute) in(5,10,15) then 0
            when extract(minute FROM minute) in(20,25,30) then 1
            when extract(minute FROM minute) in(35,40,45) then 2
            else 3
        end AS time15Min,
        case
            when extract(minute FROM minute) in(5,10,15,20,25,30) then 0
            else 1
        end AS time30Min,
        case
            when extract(minute FROM minute) in(0) and to_char(minute, 'hh12') in ('12')  then 23
            when extract(minute FROM minute) in(0) then extract(HOUR FROM minute) - 1
            else extract(HOUR FROM minute)
        end AS time60Min,
        to_char(minute, 'hh24:mi') AS time_value
	FROM
	  (
			SELECT '0:00'::time + 5*(sequence.minute || ' minutes')::interval AS minute
			FROM generate_series(0,287) AS sequence(minute)
	  ) DQ;


END
$$;

ALTER FUNCTION etl."GetTimeData"()
    OWNER TO postgres;

DROP FUNCTION IF EXISTS etl."GetDateData"();
DROP FUNCTION IF EXISTS etl."GetDateData"(integer);

CREATE OR REPLACE FUNCTION etl."GetDateData"("_days" integer)
  RETURNS TABLE(date_dim_id integer, date_actual date, date_actual_timestamp timestamp without time zone, day_of_week double precision, day_name text, day_name1 text, day_of_month double precision, day_of_year double precision, week_of_year double precision, month_name text, month_name1 text, month_actual double precision, quarter_actual double precision, year_actual double precision, semester integer, style101 text, style103 text)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY
		SELECT TO_CHAR(datum,'yyyymmdd')::INT AS date_dim_id,
		   datum AS date_actual,
		   TO_CHAR(datum,'yyyymmdd')::TIMESTAMP AS date_actual_Timestamp,
		   EXTRACT(isodow FROM datum) AS day_of_week,
		   TO_CHAR(datum,'Day') AS day_name,
		   TO_CHAR(datum,'Day') AS day_name,
		   EXTRACT(DAY FROM datum) AS day_of_month,
		   EXTRACT(doy FROM datum) AS day_of_year,
		   EXTRACT(week FROM datum) AS week_of_year,
		   TO_CHAR(datum,'Month') AS month_name,
		   TO_CHAR(datum,'Month') AS month_name,
		   EXTRACT(MONTH FROM datum) AS month_actual,
		   EXTRACT(quarter FROM datum) AS quarter_actual,
		   EXTRACT(isoyear FROM datum) AS year_actual,
		   CASE
			 WHEN EXTRACT(MONTH FROM datum) <= 6 THEN 1
			   ELSE 2
		   END AS semester,
		   TO_CHAR(datum,'mm/dd/yyyy') AS style101,
		   TO_CHAR(datum,'dd/mm/yyyy') AS style103
	FROM (SELECT '2015-01-01'::DATE+ SEQUENCE.DAY AS datum
		  FROM GENERATE_SERIES (0,_days) AS SEQUENCE (DAY)
		  GROUP BY SEQUENCE.DAY
		  order by datum) DQ
	ORDER BY 1
;

END
$$;

ALTER FUNCTION etl."GetDateData"(integer)
    OWNER TO postgres;

DROP FUNCTION IF EXISTS etl."TruncateStagingTables"();

CREATE OR REPLACE FUNCTION etl."TruncateStagingTables"()
  RETURNS void AS
$$
DECLARE
   _tbl text;
BEGIN
   FOR _tbl IN SELECT * FROM etl."GetStagingTableListToTruncate"()
   LOOP
        EXECUTE format('TRUNCATE TABLE stg.%I CASCADE', _tbl);
   END LOOP;
END
$$ LANGUAGE plpgsql;

ALTER FUNCTION etl."TruncateStagingTables"()
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('101_DW_UpdateEtlSP');DROP FUNCTION IF EXISTS dw."stpGetOMARNewData"(integer, timestamp, timestamp, integer);

CREATE OR REPLACE FUNCTION dw."stpGetOMARNewData"("ClientId" integer, "TradeDayUTC" timestamp without time zone, "TransactionDateTimeUTC" timestamp without time zone, "IsoId" integer)
  RETURNS TABLE("CONTROLAREA" integer, "CHANNEL" text, "DATE" text, "TIME" text, "VALUE" numeric, "UOM" text, "INTERVAL" text, "STATUS" text, "DSTFLAG" text)
LANGUAGE plpgsql
AS $$
DECLARE
    "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("TradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("TradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTC"        TIMESTAMP := "TradeDayUTC" + interval '1' day;
BEGIN

   RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                chan."ChannelNumber",
                uom."UomFromMV90",
                ca."ControlAreaAlternateKey",
                dte."FullAlternateDateKey",
                dtime."24_hr"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateUTCKey"
        JOIN dw."DimTime" dtime
          ON dtime."TimeKey" = fct."EndTimeUTCKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"
        JOIN dw."DimUOM" uom
          ON uom."UomKey" = chan."UomKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "TradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "ClientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "IsoId"
              AND
                (
                  ("TransactionDateTimeUTC" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("TransactionDateTimeUTC" IS NOT NULL AND (fct."InsertionDateTime" <= "TransactionDateTimeUTC" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "TransactionDateTimeUTC")))
                )
		),
    omar_CTE as
    (
        SELECT
             fct."ControlAreaAlternateKey",
             '1' AS "Channel",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DD') as "_TradeDate",
             TO_CHAR("24_hr"+1, 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF"),0) AS "_UsageDLF",
             '1' AS "UOM",
             '60' AS "_INTERVAL",
             'A' as "STATUS",
             'N' AS "DSTFLAG"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM omar_CTE;
END
$$;

ALTER FUNCTION dw."stpGetOMARNewData"(integer, timestamp, timestamp, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('102_DW_UpdatestpGetOMARNewData');DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT"(timestamp, timestamp);

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" timestamp without time zone, "dailyEndDateUTC" timestamp without time zone)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey",
				  fct."IsDelivered"   as "dw_IsDelivered"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey",
			fct."IsDelivered"       as "stg_IsDelivered"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett (
	"dw_IntervalKey",
	"dw_InsertionDateTime" ,
	"dw_MonthlyRead",
	"dw_Usage",
	"dw_UsageDLF",
	"dw_Demand",
	"dw_DemandDLF",
	"dw_DLP",
	"dw_DLPSum",
	"dw_DLPRation",
	"dw_DLF",
	"dw_StartDateTimeUTC",
	"dw_EndDateTimeUTC",
	"dw_StartDateTimeLocal",
	"dw_EndDateTimeLocal",
	"dw_AccountKey",
	"dw_SDPKey",
	"dw_MeterKey",
	"dw_ChannelKey",
	"dw_OriginConsumptionKey",
	"dw_FactValueGoalKey",
	"dw_ServiceTypeKey",
	"dw_ParentIntervalKey",
	"dw_FactStatusKey",
	"dw_EndDateLocalKey",
	"dw_EndTimeLocalKey",
	"dw_EndDateUTCKey",
	"dw_EndTimeUTCKey",
	"dw_RecordedDateUTCKey",
	"dw_ClientKey",
	"dw_IsDelivered",

    "stg_MonthlyRead",
    "stg_Usage",
    "stg_UsageDLF",
    "stg_Demand",
    "stg_DemandDLF",
    "stg_DLP",
    "stg_DLPSum",
    "stg_DLPRation",
    "stg_DLF",
    "stg_StartDateTimeUTC",
    "stg_EndDateTimeUTC",
    "stg_StartDateTimeLocal",
    "stg_EndDateTimeLocal",
    "stg_ClientKey",
    "stg_AccountKey",
    "stg_SDPKey",
    "stg_MeterKey",
    "stg_ChannelKey",
    "stg_OriginConsumptionKey",
    "stg_OriginConsumptionCode",
    "stg_ServiceTypeKey",
    "stg_EndDateLocalKey",
    "stg_EndDateUTCKey",
    "stg_EndTimeLocalKey",
    "stg_EndTimeUTCKey",
    "stg_RecordedDateKey",
	"stg_IsDelivered"
  )
  SELECT "dw_IntervalKey",
  		 "dw_InsertionDateTime" ,
		 "dw_MonthlyRead",
		 "dw_Usage",
		 "dw_UsageDLF",
		 "dw_Demand",
		 "dw_DemandDLF",
		 "dw_DLP",
		 "dw_DLPSum",
		 "dw_DLPRation",
		 "dw_DLF",
		 "dw_StartDateTimeUTC",
		 "dw_EndDateTimeUTC",
		 "dw_StartDateTimeLocal",
		 "dw_EndDateTimeLocal",
		 "dw_AccountKey",
		 "dw_SDPKey",
		 "dw_MeterKey",
		 "dw_ChannelKey",
		 "dw_OriginConsumptionKey",
		 "dw_FactValueGoalKey",
		 "dw_ServiceTypeKey",
		 "dw_ParentIntervalKey",
		 "dw_FactStatusKey",
		 "dw_EndDateLocalKey",
		 "dw_EndTimeLocalKey",
		 "dw_EndDateUTCKey",
		 "dw_EndTimeUTCKey",
		 "dw_RecordedDateUTCKey",
		 "dw_ClientKey",
		 "dw_IsDelivered",

		"stg_MonthlyRead",
		"stg_Usage",
		"stg_UsageDLF",
		"stg_Demand",
		"stg_DemandDLF",
		"stg_DLP",
		"stg_DLPSum",
		"stg_DLPRation",
		"stg_DLF",
		"stg_StartDateTimeUTC",
		"stg_EndDateTimeUTC",
		"stg_StartDateTimeLocal",
		"stg_EndDateTimeLocal",
		"stg_ClientKey",
		"stg_AccountKey",
		"stg_SDPKey",
		"stg_MeterKey",
		"stg_ChannelKey",
		"stg_OriginConsumptionKey",
		"stg_OriginConsumptionCode",
		"stg_ServiceTypeKey",
		"stg_EndDateLocalKey",
		"stg_EndDateUTCKey",
		"stg_EndTimeLocalKey",
		"stg_EndTimeUTCKey",
		"stg_RecordedDateKey",
		"stg_IsDelivered"

  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
		AND COALESCE (dw_fact."dw_IsDelivered",false)    = COALESCE (stg_fact."stg_IsDelivered",false)
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );


  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

ALTER FUNCTION etl."stpMergeDailyFactIntervals_SETT"(timestamp, timestamp)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('103_DW_UpdatestpMergeDailyFactIntervals_SETT');DROP FUNCTION IF EXISTS dw."stpGetOMARNewData"(integer, timestamp, timestamp, integer);

CREATE OR REPLACE FUNCTION dw."stpGetOMARNewData"("ClientId" integer, "TradeDayUTC" timestamp without time zone, "TransactionDateTimeUTC" timestamp without time zone, "IsoId" integer)
  RETURNS TABLE("CONTROLAREA" integer, "CHANNEL" text, "DATE" text, "TIME" text, "VALUE" numeric, "UOM" text, "INTERVAL" text, "STATUS" text, "DSTFLAG" text)
LANGUAGE plpgsql
AS $$
DECLARE
    "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("TradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("TradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
    "startTradeDayUTC"      TIMESTAMP := "TradeDayUTC" + interval '1' hour;
    "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
    "startTradeDayUTCKey2"   INTEGER   := "endTradeDayUTCKey";
    "endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("TradeDayUTC" + interval '2' day)::Date,'YYYYMMDD') AS INTEGER);
BEGIN

   RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                chan."ChannelNumber",
                uom."UomFromMV90",
                ca."ControlAreaAlternateKey",
                dte."FullAlternateDateKey",
                dtime."24_hr"
        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = "startTradeDayUTCKey"
        JOIN dw."DimTime" dtime
          ON dtime."TimeKey" = fct."EndTimeUTCKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"
        JOIN dw."DimUOM" uom
          ON uom."UomKey" = chan."UomKey"

        WHERE     ((fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey") OR
              (fct."EndDateUTCKey"    >= "startTradeDayUTCKey2"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey2"))
              AND fct."EndDateTimeUTC"   >=  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "ClientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "IsoId"
              AND
                (
                  ("TransactionDateTimeUTC" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("TransactionDateTimeUTC" IS NOT NULL AND (fct."InsertionDateTime" <= "TransactionDateTimeUTC" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "TransactionDateTimeUTC")))
                )
		),
    omar_CTE as
    (
        SELECT
             fct."ControlAreaAlternateKey",
             '1' AS "Channel",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             case
                when (TO_CHAR("24_hr", 'fm00') || ':00:00') = '00:00:00' then '24:00:00'
                else (TO_CHAR("24_hr", 'fm00') || ':00:00')
             end as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF"),0) AS "_UsageDLF",
             '1' AS "UOM",
             '60' AS "_INTERVAL",
             'A' as "STATUS",
             'N' AS "DSTFLAG"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM omar_CTE;
END
$$;

ALTER FUNCTION dw."stpGetOMARNewData"(integer, timestamp, timestamp, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('104_DW_OMARNewData_Fix');-- FUNCTION: dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptDailyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"startTradeDayUTC" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Tradeday" date, "TransactionDate" timestamp without time zone, "Account" character varying, "MeterID" character varying, "ControlArea" character varying, "RawDailyUsage" numeric, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
   
"startTradeDayUTCKey"	INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"		INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);

 "endTradeDayUTC" 		TIMESTAMP := "startTradeDayUTC" + interval '1' day;
 "startDateTimeLocal" 	TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN

    RETURN  QUERY
	
SELECT tmp."Tradeday"
	  ,tmp."TransactionDate" 
	  ,tmp."Account"
	  ,tmp."MeterID"
	  ,tmp."ControlArea"
	  ,SUM(tmp."RawDailyUsage")
	  ,tmp."IntervalReadings"
	  
	  
FROM (
	SELECT "startTradeDayUTC"::Date AS "Tradeday"
		  ,"transactionDate" AS "TransactionDate" 
		  ,act."AccountNumber" AS "Account"
		  ,mt."DeviceCode" AS "MeterID"
		  ,ca."Abbreviation" AS "ControlArea"
		  ,fct."Usage" AS "RawDailyUsage"
		  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings"

	FROM dw."FactIntervals_SETT" fct 
			JOIN dw."DimAccount" act
			  ON act."AccountKey" = fct."AccountKey"
			JOIN dw."DimClient" cli
			  ON cli."ClientKey" = act."ClientKey"																											
			JOIN dw."DimServiceType" serv																			
			  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
			JOIN dw."DimFactStatus" status
			  ON status."FactStatusKey" = fct."FactStatusKey"        
			JOIN dw."DimOriginFactValue" ofv
			  ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"      
			JOIN dw."DimControlArea" ca																						
			  ON ca."ControlAreaKey" = act."ControlAreaKey"
			JOIN dw."DimISO" iso
			  ON iso."ISOKey" = ca."ISOKey"
			JOIN dw."DimMeter" mt
			  ON mt."MeterKey" = fct."MeterKey"  
			
			WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
				  AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
	
				  AND serv."Code" = 'SETT'
				  AND cli."ClientAlternateKey" = "clientId"
				  AND act."ApplicationCode"    = 'SETT'
				  AND iso."ISOAlternateKey" = "ISO_Id"
				  AND
					(
					  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
					  OR
					  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
					)
	)tmp
	GROUP BY tmp."Tradeday"
	 	 ,tmp."TransactionDate" 
	 	 ,tmp."Account"
	 	 ,tmp."MeterID"
   	 	 ,tmp."ControlArea"
	 	 ,tmp."IntervalReadings"
	ORDER BY tmp."IntervalReadings"
		 ,tmp."ControlArea"
		 ,tmp."Account"
		 ,tmp."MeterID";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('105_DW_procRptDailyTotals_LocalDate');DROP FUNCTION IF EXISTS dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptDailyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"startTradeDayUTC" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Tradeday" date, "TransactionDate" timestamp without time zone, "Account" character varying, "MeterID" character varying, "ControlArea" character varying, "RawDailyUsage" numeric, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
   
"startTradeDayUTCKey"	INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"		INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);

 "endTradeDayUTC" 		TIMESTAMP := "startTradeDayUTC" + interval '1' day;
 "startDateTimeLocal" 	TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN

    RETURN  QUERY
	
SELECT tmp."Tradeday"
	  ,tmp."TransactionDate" 
	  ,tmp."Account"
	  ,tmp."MeterID"
	  ,tmp."ControlArea"
	  ,SUM(tmp."RawDailyUsage")
	  ,tmp."IntervalReadings"
	  
	  
FROM (
	SELECT "startTradeDayUTC"::Date AS "Tradeday"
		  ,"transactionDate" AS "TransactionDate" 
		  ,act."AccountNumber" AS "Account"
		  ,mt."DeviceCode" AS "MeterID"
		  ,ca."Abbreviation" AS "ControlArea"
		  ,fct."Usage" AS "RawDailyUsage"
		  ,CASE WHEN ofv."OriginValueEnglishDescription" = 'Calculated' THEN 'Monthly' ELSE ofv."OriginValueEnglishDescription" END AS "IntervalReadings"

	FROM dw."FactIntervals_SETT" fct 
			JOIN dw."DimAccount" act
			  ON act."AccountKey" = fct."AccountKey"
			JOIN dw."DimClient" cli
			  ON cli."ClientKey" = act."ClientKey"																											
			JOIN dw."DimServiceType" serv																			
			  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
			JOIN dw."DimFactStatus" status
			  ON status."FactStatusKey" = fct."FactStatusKey"        
			JOIN dw."DimOriginFactValue" ofv
			  ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"      
			JOIN dw."DimControlArea" ca																						
			  ON ca."ControlAreaKey" = act."ControlAreaKey"
			JOIN dw."DimISO" iso
			  ON iso."ISOKey" = ca."ISOKey"
			JOIN dw."DimMeter" mt
			  ON mt."MeterKey" = fct."MeterKey"  
			
			WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
				  AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
	
				  AND serv."Code" = 'SETT'
				  AND cli."ClientAlternateKey" = "clientId"
				  AND act."ApplicationCode"    = 'SETT'
				  AND iso."ISOAlternateKey" = "ISO_Id"
				  AND
					(
					  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
					  OR
					  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
					)
	)tmp
	GROUP BY tmp."Tradeday"
	 	 ,tmp."TransactionDate" 
	 	 ,tmp."Account"
	 	 ,tmp."MeterID"
   	 	 ,tmp."ControlArea"
	 	 ,tmp."IntervalReadings"
	ORDER BY tmp."IntervalReadings"
		 ,tmp."ControlArea"
		 ,tmp."Account"
		 ,tmp."MeterID";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('106_DW_procRptDailyTotals_order');DROP FUNCTION IF EXISTS dw."stpGetMisoData"(INTEGER, INTEGER, TIMESTAMP, TIMESTAMP);

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer, "isoIdParam" integer, "startTradeDayUTC" timestamp without time zone, "transactionDate" timestamp without time zone)
  RETURNS TABLE("MSId" text, "TradeDate" text, "TradeTime" text, "UsageDLF" numeric, "Stat" text)
LANGUAGE plpgsql
AS $$
DECLARE
          "endTradeDay"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
          "startDateTime"         TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN
    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",

                CASE WHEN ((((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1) AND (dte."FullAlternateDateKey" > "startTradeDayUTC")) THEN (dte."FullAlternateDateKey" + interval '-1' day)
                  ELSE dte."FullAlternateDateKey" END AS "FullAlternateDateKey",


                CASE WHEN TO_CHAR(fct."EndDateTimeLocal", 'MI') = '00' THEN
                                CASE WHEN ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1
                                          THEN 23
                                          ELSE ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1)
                                END
                                ELSE (TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer)
                END  "24_hr",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE fct."EndDateTimeLocal"   >=  "startDateTime"
              AND fct."EndDateTimeLocal"   <=  "endTradeDay"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
		),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";
END;
$$;

ALTER FUNCTION dw."stpGetMisoData"(INTEGER, INTEGER, TIMESTAMP, TIMESTAMP)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('107_DW_stpGetMisoData');DROP FUNCTION IF EXISTS dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptDailyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"startTradeDayUTC" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Tradeday" date, "TransactionDate" timestamp without time zone, "Account" character varying, "MeterID" character varying, "ControlArea" character varying, "RawDailyUsage" numeric, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
   
"startTradeDayUTCKey"	INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"		INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);

 "endTradeDayUTC" 		TIMESTAMP := "startTradeDayUTC" + interval '1' day;
 "startDateTimeLocal" 	TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN

    RETURN  QUERY
	
SELECT tmp."Tradeday"
	  ,tmp."TransactionDate" 
	  ,tmp."Account"
	  ,tmp."MeterID"
	  ,tmp."ControlArea"
	  ,SUM(tmp."RawDailyUsage")
	  ,tmp."IntervalReadings"
	  
	  
FROM (
	SELECT "startTradeDayUTC"::Date AS "Tradeday"
		  ,"transactionDate" AS "TransactionDate" 
		  ,act."AccountNumber" AS "Account"
		  ,mt."DeviceCode" AS "MeterID"
		  ,ca."Abbreviation" AS "ControlArea"
		  ,fct."Usage" AS "RawDailyUsage"
		  ,CASE WHEN ofv."OriginValueEnglishDescription" = 'Calculated' THEN 'Monthly' WHEN ofv."OriginValueEnglishDescription" = 'Real' THEN 'Interval' ELSE ofv."OriginValueEnglishDescription" END AS "IntervalReadings"

	FROM dw."FactIntervals_SETT" fct 
			JOIN dw."DimAccount" act
			  ON act."AccountKey" = fct."AccountKey"
			JOIN dw."DimClient" cli
			  ON cli."ClientKey" = act."ClientKey"																											
			JOIN dw."DimServiceType" serv																			
			  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
			JOIN dw."DimFactStatus" status
			  ON status."FactStatusKey" = fct."FactStatusKey"        
			JOIN dw."DimOriginFactValue" ofv
			  ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"      
			JOIN dw."DimControlArea" ca																						
			  ON ca."ControlAreaKey" = act."ControlAreaKey"
			JOIN dw."DimISO" iso
			  ON iso."ISOKey" = ca."ISOKey"
			JOIN dw."DimMeter" mt
			  ON mt."MeterKey" = fct."MeterKey"  
			
			WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
				  AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
	
				  AND serv."Code" = 'SETT'
				  AND cli."ClientAlternateKey" = "clientId"
				  AND act."ApplicationCode"    = 'SETT'
				  AND iso."ISOAlternateKey" = "ISO_Id"
				  AND
					(
					  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
					  OR
					  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
					)
	)tmp
	GROUP BY tmp."Tradeday"
	 	 ,tmp."TransactionDate" 
	 	 ,tmp."Account"
	 	 ,tmp."MeterID"
   	 	 ,tmp."ControlArea"
	 	 ,tmp."IntervalReadings"
	ORDER BY tmp."IntervalReadings"
		 ,tmp."ControlArea"
		 ,tmp."Account"
		 ,tmp."MeterID";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('108_DW_procRptDailyTotals_order');DROP FUNCTION IF EXISTS dw."stpGetOMARNewData"(integer, timestamp, timestamp, integer);

CREATE OR REPLACE FUNCTION dw."stpGetOMARNewData"("ClientId" integer, "TradeDayUTC" timestamp without time zone, "TransactionDateTimeUTC" timestamp without time zone, "IsoId" integer)
  RETURNS TABLE("CONTROLAREA" integer, "CHANNEL" text, "DATE" text, "TIME" text, "VALUE" numeric, "UOM" text, "INTERVAL" text, "STATUS" text, "DSTFLAG" text)
LANGUAGE plpgsql
AS $$
DECLARE
    "endTradeDay" TIMESTAMP := "TradeDayUTC" + interval '1' day;
    "startDateTime" TIMESTAMP := "TradeDayUTC" + interval '15' MINUTE;
BEGIN

   RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                chan."ChannelNumber",
                uom."UomFromMV90",
                ca."ControlAreaAlternateKey",
                CASE WHEN ((((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1) AND (dte."FullAlternateDateKey" > "TradeDayUTC")) THEN (dte."FullAlternateDateKey" + interval '-1' day)
                  ELSE dte."FullAlternateDateKey" END AS "FullAlternateDateKey",
                CASE WHEN TO_CHAR(fct."EndDateTimeLocal", 'MI') = '00' THEN
                                CASE WHEN ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1
                                          THEN 23
                                          ELSE ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1)
                                END
                                ELSE (TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer)
                END  "24_hr"
        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"
        JOIN dw."DimUOM" uom
          ON uom."UomKey" = chan."UomKey"

        WHERE fct."EndDateTimeLocal" >= "startDateTime"
              AND fct."EndDateTimeLocal" < "endTradeDay"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "ClientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "IsoId"
              AND
                (
                  ("TransactionDateTimeUTC" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("TransactionDateTimeUTC" IS NOT NULL AND (fct."InsertionDateTime" <= "TransactionDateTimeUTC" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "TransactionDateTimeUTC")))
                )
		),
    omar_CTE as
    (
        SELECT
             fct."ControlAreaAlternateKey",
             '1' AS "Channel",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             case
                when (TO_CHAR("24_hr", 'fm00') || ':00:00') = '00:00:00' then '24:00:00'
                else (TO_CHAR("24_hr", 'fm00') || ':00:00')
             end as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF"),0) AS "_UsageDLF",
             '1' AS "UOM",
             '60' AS "_INTERVAL",
             'A' as "STATUS",
             'N' AS "DSTFLAG"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM omar_CTE;
END
$$;

ALTER FUNCTION dw."stpGetOMARNewData"(integer, timestamp, timestamp, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('109_DW_OMARNewData');CREATE TABLE public."DatabaseVersionHistory" 
(
	"DatabaseVersionId" VARCHAR(150) PRIMARY KEY,
	"InsertionDateTime" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO public."DatabaseVersionHistory" VALUES ('000_DW_DatabaseVersionHistory_Create_Scripts');CREATE SCHEMA ct;
CREATE TABLE ct."LoadStream"
(
    "StreamId" BIGSERIAL PRIMARY KEY NOT NULL,
    "FromSyncDateUTC" TIMESTAMP NOT NULL,
	"ToSyncDateUTC" TIMESTAMP NOT NULL,
    "ProcessStartDateTime" TIMESTAMP NULL,
    "ProcessEndDateTime" TIMESTAMP,
    "Status" VARCHAR(10)
);

CREATE TABLE ct."LoadCycle"
(
    "LoadCycleId" BIGSERIAL PRIMARY KEY NOT NULL,
	"EnvCode" VARCHAR(50) NOT NULL,
    "SourceSchema" VARCHAR(30) NOT NULL,
    "DestinationSchema" VARCHAR(30) NOT NULL,
	"LoadType" VARCHAR(30) NOT NULL,
    "StartingDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Status" VARCHAR(10),
    "StreamId" BIGINT NOT NULL
);
ALTER TABLE ct."LoadCycle" ADD CONSTRAINT FK_LoadCycle_LoadStream FOREIGN KEY ("StreamId") REFERENCES ct."LoadStream" ("StreamId");

CREATE TABLE ct."Audit"
(
    "AuditKey" BIGSERIAL PRIMARY KEY NOT NULL,
    "ParentAuditKey" BIGINT,
    "TableName" VARCHAR(50) NOT NULL,
    "JobName" VARCHAR(50) NOT NULL,
    "ExecutionStartDateTime" TIMESTAMP NOT NULL,
    "ExecutionStopDateTime" TIMESTAMP,
    "ExtractRowCount" INT,
    "InsertRowCount" INT,
    "UpdateRowCount" INT,
    "ErrorRowCount" INT,
    "TableInitialRow" INT,
    "TableFinalRow" INT,
    "ProcessingStatus" INT,
    "LoadCycleId" BIGINT NOT NULL
);
ALTER TABLE ct."Audit" ADD CONSTRAINT FK_Audit_LoadCycle FOREIGN KEY ("LoadCycleId") REFERENCES ct."LoadCycle" ("LoadCycleId");

INSERT INTO public."DatabaseVersionHistory" VALUES ('001_DW_ControlTables_Create_Scripts');--CREATE DBLINK EXTENSION
CREATE EXTENSION dblink;

CREATE SCHEMA dw;
-- DimWeatherStation
CREATE TABLE dw."DimWeatherStation"
(
    "StationKey" SERIAL PRIMARY KEY NOT NULL,
    "StationAlternateKey" INT NOT NULL,
    "Name" VARCHAR(5) NOT NULL
);
COMMENT ON TABLE dw."DimWeatherStation" IS 'Weather Station Dimension';
CREATE UNIQUE INDEX DimWeatherStation_StationAlternateKey_index ON dw."DimWeatherStation" ("StationAlternateKey");
CREATE INDEX DimWeatherStation_StationAlternateKey_Name_index ON dw."DimWeatherStation" ("StationAlternateKey","Name");


-- DimLocation
CREATE TABLE dw."DimLocation"
(
    "LocationKey" SERIAL PRIMARY KEY NOT NULL,
    "LocationAlternateKey" INT NOT NULL,
    "City" VARCHAR(100) NOT NULL,
    "StateProvinceAbbr" VARCHAR(3) NOT NULL,
    "StateProvinceName" VARCHAR(30) NOT NULL,
    "CountryAbbr" VARCHAR(3) NOT NULL,
    "EnglishCountryName" VARCHAR(30) NOT NULL,
    "SpanishCountryName" VARCHAR(30) NOT NULL
);
COMMENT ON TABLE dw."DimLocation" IS 'Location Dimension';
CREATE UNIQUE INDEX DimLocation_LocationAlternateKey_index ON dw."DimLocation" ("LocationAlternateKey");
CREATE INDEX DimLocation_LocationAlternateKey_City_index ON dw."DimLocation" ("LocationAlternateKey","City");


-- DimISO
CREATE TABLE dw."DimISO"
(
    "ISOKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "ISOAlternateKey" SMALLINT NOT NULL,
    "ISOName" VARCHAR(20) NOT NULL,
    "ISOEnglishDescription" VARCHAR(50) NOT NULL,
    "ISOSpanishDescription" VARCHAR(50) NOT NULL,
    "ISODefaultFormat" VARCHAR(20) NOT NULL
);
COMMENT ON TABLE dw."DimISO" IS 'Independant System Operation Dimension';
CREATE UNIQUE INDEX DimISO_ISOAlternateKey_index ON dw."DimISO" ("ISOAlternateKey");
CREATE INDEX DimISO_ISOAlternateKey_ISOName_index ON dw."DimISO" ("ISOAlternateKey","ISOName");

--DimControlArea
CREATE TABLE dw."DimControlArea"
(
    "ControlAreaKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "ControlAreaAlternateKey" INT NOT NULL,
    "Name" VARCHAR(50) NOT NULL,
    "Abbreviation" VARCHAR(5) NOT NULL,
    "Duns" VARCHAR(100),
	"ISOKey" SMALLINT
);
COMMENT ON TABLE dw."DimControlArea" IS 'Control Area Dimension';
ALTER TABLE dw."DimControlArea" ADD CONSTRAINT FK_ControlArea_ISO FOREIGN KEY ("ISOKey") REFERENCES dw."DimISO" ("ISOKey");
CREATE UNIQUE INDEX DimControlArea_ControlAreaAlternateKey_index ON dw."DimControlArea" ("ControlAreaAlternateKey");
CREATE INDEX DimControlArea_ControlAreaAlternateKey_Name_index ON dw."DimControlArea" ("ControlAreaAlternateKey","Name");


-- DimClient
CREATE TABLE dw."DimClient"
(
    "ClientKey" SERIAL PRIMARY KEY NOT NULL,
    "ClientAlternateKey" INT,
    "ClientName" VARCHAR(50) NOT NULL,
    "LogoFileName" VARCHAR(100),
    "LogoFileBinaryContent" BYTEA,
    "ClientUrl" VARCHAR(255),
    "MonthsToRetain" SMALLINT NOT NULL,
	"Duns" VARCHAR (13),
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimClient" IS 'Client Dimension';
CREATE UNIQUE INDEX DimClient_ClientAlternateKey_index ON dw."DimClient" ("ClientAlternateKey"); -- TEMPORARY INDEX
CREATE INDEX DimClient_ClientAlternateKey_ClientName_Current_index ON dw."DimClient" ("ClientAlternateKey","ClientName","Current");


--DimCustomer
CREATE TABLE dw."DimCustomer"
(
    "CustomerKey" SERIAL PRIMARY KEY NOT NULL,
    "CustomerAlternateKey" VARCHAR(256) NOT NULL,
	"ApplicationCode" varchar(4) NOT NULL,
    "Name" VARCHAR(256),
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimCustomer" IS 'Customer Dimension';
CREATE UNIQUE INDEX DimCustomer_CustomerAlternateKey_ApplicationCode_index ON dw."DimCustomer" ("CustomerAlternateKey","ApplicationCode"); -- TEMPORARY INDEX
CREATE INDEX DimCustomer_CustomerAlternateKey_Name_Current_index ON dw."DimCustomer" ("CustomerAlternateKey","Name","Current");

--DimAccount
CREATE TABLE dw."DimAccount"
(
    "AccountKey" SERIAL PRIMARY KEY NOT NULL,
    "AccountAlternateKey" INTEGER NOT NULL,
	"ApplicationCode" varchar(4),
    "AccountNumber" VARCHAR(50),
    "PremiseNumber" VARCHAR(5),
	"TimeZoneKey" integer,
	"ClientAccountKey" character varying(100),
	"ClientKey" INT,
	"CustomerKey" INT NULL,
	"ControlAreaKey" SMALLINT,
	"StartActiveDateTimeUTC"   TIMESTAMP,
	"EndActiveDateTimeUTC"     TIMESTAMP,
	"StartActiveDateTimeLocal" TIMESTAMP,
	"EndActiveDateTimeLocal"   TIMESTAMP,
    "StartDateTime"            TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimAccount" IS 'Account Information Dimension';
CREATE INDEX DimAccount_AccountAlternateKey_ApplicationCode_AccountNumber_CustomerKey_ClientKey_ControlArea_index ON dw."DimAccount" ("AccountAlternateKey","ApplicationCode","AccountNumber","CustomerKey","ClientKey","ControlAreaKey","Current");
ALTER TABLE dw."DimAccount" ADD CONSTRAINT FK_Account_Client FOREIGN KEY ("ClientKey") REFERENCES dw."DimClient" ("ClientKey");
ALTER TABLE dw."DimAccount" ADD CONSTRAINT FK_Account_Customer FOREIGN KEY ("CustomerKey") REFERENCES dw."DimCustomer" ("CustomerKey");
ALTER TABLE dw."DimAccount" ADD CONSTRAINT FK_Account_ControlArea FOREIGN KEY ("ControlAreaKey") REFERENCES dw."DimControlArea" ("ControlAreaKey");

-- DimCurrency
CREATE TABLE dw."DimPriceCurrency"
(
    "CurrencyKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "CurrencyCode" VARCHAR(3) NOT NULL,
    "EnglishCurrencyName" VARCHAR(50) NOT NULL,
    "SpanishCurrencyName" VARCHAR(50) NOT NULL
);
COMMENT ON TABLE dw."DimPriceCurrency" IS 'Currency Dimension';
CREATE UNIQUE INDEX DimPriceCurrency_CurrencyCode_index ON dw."DimPriceCurrency" ("CurrencyCode");


-- DimOriginFactValue
CREATE TABLE dw."DimOriginFactValue"
(
    "OriginConsumptionKey" SMALLINT PRIMARY KEY NOT NULL,
	"Code" VARCHAR(8) NOT NULL,
    "OriginValueEnglishDescription" VARCHAR(20) NOT NULL,
    "OriginValueSpanishDescription" VARCHAR(20) NOT NULL
);
COMMENT ON TABLE dw."DimOriginFactValue" IS 'Is Fact Consumption Value Calculated, Estimated or Real ?';

-- DimFactValueGoal
CREATE TABLE dw."DimFactValueGoal"
(
    "FactValueGoalKey" SMALLINT PRIMARY KEY NOT NULL,
	"Code" VARCHAR(8) NOT NULL,
    "FactValueGoalEnglishDescription" VARCHAR(20) NOT NULL,
    "FactValueGoalSpanishDescription" VARCHAR(20) NOT NULL
);
COMMENT ON TABLE dw."DimFactValueGoal" IS 'Is Fact Consumption Value Initial, New Value or Correction ?';

--DimTimeZone
CREATE TABLE dw."DimTimeZone"
(
    "TimeZoneKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "TimeZoneAlternateKey" SMALLINT NOT NULL,
    "Abbreviation" VARCHAR(5) NOT NULL,
    "EnglishName" VARCHAR(50) NOT NULL,
    "SpanishName" VARCHAR(50) NOT NULL,
    "OffsetToGMT" INT NOT NULL
);
COMMENT ON TABLE dw."DimTimeZone" IS 'Time Zone Dimension';
CREATE UNIQUE INDEX DimTimeZone_TimeZoneAlternateKey_index ON dw."DimTimeZone" ("TimeZoneAlternateKey");
CREATE INDEX DimTimeZone_TimeZoneAlternateKey_Abbreviation_EnglishName_index ON dw."DimTimeZone" ("TimeZoneAlternateKey","Abbreviation","EnglishName");


-- DimEnergyPowerType
CREATE TABLE dw."DimEnergyPowerType"
(
    "EnergyPowerTypeKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "EnergyPowerTypeAlternateKey" SMALLINT NOT NULL,
    "EnglishEnergyPowerTypeDescription" VARCHAR(20) NOT NULL,
    "SpanishPowerTypeDescription" VARCHAR(20) NOT NULL
);
COMMENT ON TABLE dw."DimEnergyPowerType" IS 'Power Type Classification Dimension';
CREATE UNIQUE INDEX DimEnergyPowerType_EnergyPowerTypeAlternateKey_index ON dw."DimEnergyPowerType" ("EnergyPowerTypeAlternateKey");
CREATE INDEX DimEnergyPowerType_EnergyPowerTypeAlternateKey_EnglishDescription_index ON dw."DimEnergyPowerType" ("EnergyPowerTypeAlternateKey","EnglishEnergyPowerTypeDescription");

-- DimDate
CREATE TABLE dw."DimDate"
(
    "DateKey" INT PRIMARY KEY NOT NULL,
    "FullAlternateDateKey" DATE NOT NULL,
	"FullAlternateDateTimeStamp" TIMESTAMP NOT NULL,
    "DayNumberOfWeek" SMALLINT NOT NULL,
    "EnglishDayNameOfWeek" VARCHAR(10) NOT NULL,
    "SpanishDayNameOfWeek" VARCHAR(10) NOT NULL,
    "DayNumberOfMonth" SMALLINT NOT NULL,
    "DayNumberOfYear" SMALLINT NOT NULL,
    "WeekNumberOfYear" SMALLINT NOT NULL,
    "EnglishMonthName" VARCHAR(10) NOT NULL,
    "SpanishMonthName" VARCHAR(10) NOT NULL,
    "MonthNumberOfYear" SMALLINT NOT NULL,
    "CalendarQuarter" SMALLINT NOT NULL,
    "CalendarYear" SMALLINT NOT NULL,
    "CalendarSemester" SMALLINT NOT NULL,
    "DateStyle101" VARCHAR(10) NOT NULL,
    "DateStyle103" VARCHAR(10) NOT NULL
);
COMMENT ON TABLE dw."DimDate" IS 'Date Dimension';
CREATE UNIQUE INDEX DimDate_FullDateAlternateKey_uindex ON dw."DimDate" ("FullAlternateDateKey","FullAlternateDateTimeStamp");

-- DimTime
CREATE TABLE dw."DimTime"
(
    "TimeKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "TimeAlternateKey" VARCHAR(5) NOT NULL,
    "12_hr" SMALLINT NOT NULL,
    "24_hr" SMALLINT NOT NULL,
    "am_pm" VARCHAR(2) NOT NULL,
    "MinuteInHour" SMALLINT NOT NULL,
    "Time05Min" SMALLINT NOT NULL,
    "Time10Min" SMALLINT NOT NULL,
    "Time15Min" SMALLINT NOT NULL,
    "Time30Min" SMALLINT NOT NULL,
    "Time60Min" SMALLINT NOT NULL,
    "TimeValue" VARCHAR(10) NOT NULL
);
COMMENT ON TABLE dw."DimTime" IS 'Time Dimension';
CREATE UNIQUE INDEX DimTime_TimeAlternateKey_TimeValue_uindex ON dw."DimTime" ("TimeAlternateKey","TimeValue");


-- DimMeter
CREATE TABLE dw."DimMeter"
(
    "MeterKey" SERIAL PRIMARY KEY NOT NULL,
    "MeterAlternateKey" VARCHAR(50) NOT NULL,
    "ApplicationCode" varchar(4) NOT NULL,
    "Name" VARCHAR(50) NOT NULL,
    "IntervalsPerHour" SMALLINT NOT NULL,
    "IsDSTEnabled" boolean NOT NULL,
    "IsVirtual" boolean NOT NULL,
    "MeterType" VARCHAR(50) NULL,
    "Manufacturer" VARCHAR(50) NULL,
    "TimeZoneKey" SMALLINT NULL,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimMeter" IS 'Meter, MeterType and MeterManufacturer Dimension';
CREATE INDEX DimMeter_MeterAlternateKey_Name_Current_index ON dw."DimMeter" ("MeterAlternateKey","Name","Current");
ALTER TABLE dw."DimMeter" ADD CONSTRAINT FK_Meter_TimeZone FOREIGN KEY ("TimeZoneKey") REFERENCES dw."DimTimeZone" ("TimeZoneKey");

-- DimSDP
CREATE TABLE dw."DimSDP"
(
    "SDPKey" SERIAL PRIMARY KEY NOT NULL,
    "SDPAlternateKey" INT NOT NULL,
    "Address" VARCHAR(250),
    "Address1" VARCHAR(250),
    "PostalCode" VARCHAR(9),
    "Longitude" DECIMAL(9,6),
    "Latitude" DECIMAL(9,6),
    "Name" VARCHAR(50),
    "IsVirtual" boolean NOT NULL,
    "LoadReductionPriceCode" VARCHAR(20),
    "CustomerBaseLineAdjLoadReduction" DECIMAL(18,2),
    "CustomerBaseLineAdjType" VARCHAR(1),
    "LocationKey" INT ,
    "StationKey" INT ,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimSDP" IS 'SDP Information Dimension';
CREATE UNIQUE INDEX DimSDP_SDPAlternateKey_index ON dw."DimSDP" ("SDPAlternateKey"); --TEMPORARY INDEX
CREATE INDEX DimSDP_SDPAlternateKey_Name_Current_index ON dw."DimSDP" ("SDPAlternateKey","Name","Current");

ALTER TABLE dw."DimSDP" ADD CONSTRAINT FK_SDP_Location FOREIGN KEY ("LocationKey") REFERENCES dw."DimLocation" ("LocationKey");
ALTER TABLE dw."DimSDP" ADD CONSTRAINT FK_SDP_WeatherStation FOREIGN KEY ("StationKey") REFERENCES dw."DimWeatherStation" ("StationKey");

-- DimUOM
CREATE TABLE dw."DimUOM"
(
    "UomKey" SMALLSERIAL PRIMARY KEY NOT NULL,
    "UomAlternateKey" SMALLINT NOT NULL,
    "EnglishDescription" VARCHAR(20) NOT NULL,
    "SpanishDescription" VARCHAR(20) NOT NULL,
    "Code" VARCHAR(20) NOT NULL,
    "UomFromMV90" INT,
    "ConversionKey" SMALLINT,
    "EnglishUomTypeDescription" VARCHAR(20) NOT NULL,
    "SpanishUomTypeDescription" VARCHAR(20) NOT NULL,
    "EnergyPowerTypeKey" SMALLINT,
	"EDI867Code" VARCHAR (200)
);
COMMENT ON TABLE dw."DimUOM" IS 'Unit Of Measurement and Uom Type  Dimension';
CREATE UNIQUE INDEX DimUOM_UomAlternateKey_index ON dw."DimUOM" ("UomAlternateKey");
CREATE INDEX DimUOM_UomAlternateKey_EnglishDescription_index ON dw."DimUOM" ("UomAlternateKey","EnglishDescription");
ALTER TABLE dw."DimUOM" ADD CONSTRAINT FK_UOM_EnergyPowerType FOREIGN KEY ("EnergyPowerTypeKey") REFERENCES dw."DimEnergyPowerType"("EnergyPowerTypeKey");


-- DimPowerFctConfig
CREATE TABLE dw."DimPowerFctConfig"
(
    "PowerFctConfigKey" SERIAL PRIMARY KEY NOT NULL,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP
);
COMMENT ON TABLE dw."DimPowerFctConfig" IS 'Power Factor Configuration Dimension';

-- DimChannel
CREATE TABLE dw."DimChannel"
(
    "ChannelKey" SERIAL PRIMARY KEY NOT NULL,
    "ChannelAlternateKey" INT NOT NULL,
    "ChannelNumber" SMALLINT NOT NULL,
    "SetNumber" SMALLINT,
    "NumberOfDials" SMALLINT NOT NULL,
    "MeterMultiplier" DECIMAL(12,5) NOT NULL,
    "PulseMultiplier" DECIMAL(12,5) NOT NULL,
    "PulseOffset" DECIMAL(12,5) NOT NULL,
    "BillingMultiplier" DECIMAL(12,5) NOT NULL,
    "EnglishChannelTypeDescription" VARCHAR(20) NOT NULL,
    "SpanishChannelTypeDescription" VARCHAR(20) NOT NULL,
    "IntervalsPerHour" SMALLINT NOT NULL,
    "IsDelivered" boolean,
    "IsVirtual" boolean NOT NULL,
    "UomKey" SMALLINT NOT NULL,
	"PowerFctConfigKey" INT,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimChannel" IS 'Channel and Channel Type Dimension';
CREATE UNIQUE INDEX DimChannel_ChannelAlternateKey_index ON dw."DimChannel" ("ChannelAlternateKey"); -- TEMPORARY INDEX
CREATE INDEX DimChannel_ChannelAlternateKey_ChannelNumber_Current_index ON dw."DimChannel" ("ChannelAlternateKey","ChannelNumber","Current");
ALTER TABLE dw."DimChannel" ADD CONSTRAINT FK_Channel_UOM FOREIGN KEY ("UomKey") REFERENCES dw."DimUOM"("UomKey");
ALTER TABLE dw."DimChannel" ADD CONSTRAINT FK_Channel_PowerFctConfig   FOREIGN KEY ("PowerFctConfigKey") REFERENCES dw."DimPowerFctConfig"("PowerFctConfigKey");


-- DimServiceType
CREATE TABLE dw."DimServiceType"
(
    "ServiceTypeKey" SMALLINT PRIMARY KEY NOT NULL,
	"Code" VARCHAR(8) NOT NULL,
    "Description" VARCHAR(50) NOT NULL
);
COMMENT ON TABLE dw."DimServiceType" IS 'Is Service OMDA or Settlement ?';



-- DimFactStatus
CREATE TABLE dw."DimFactStatus"
(
    "FactStatusKey" SMALLINT PRIMARY KEY NOT NULL,
	"Code" VARCHAR(8) NOT NULL,
    "EnglishFactStatusDescription" VARCHAR(20) NOT NULL,
    "SpanishFactStatusDescription" VARCHAR(20) NOT NULL
);
COMMENT ON TABLE dw."DimFactStatus" IS 'Is Fact Current or Old ?';

INSERT INTO public."DatabaseVersionHistory" VALUES ('002_DW_Dimensions_Create_Scripts');-- FactIntervals
CREATE TABLE dw."FactIntervals"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
    "MontlhyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,	
    "UsageDLF" NUMERIC(28,4),	
    "Demand" NUMERIC(28,4) ,    
    "DemandDLF" NUMERIC(28,4) ,    
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
    "DLP" NUMERIC(18,6),	
    "DLPSum" NUMERIC(18,6),
    "DLPRation" NUMERIC(18,6),	
    "DLF" NUMERIC(18,7),
    "Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
    "MarginalUsage" NUMERIC(28,4),
    "MarginalCost" NUMERIC(28,4),
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
    "StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
    "AccountKey" INT,
    "SDPKey" INT ,
    "MeterKey" INT,
    "ChannelKey" INT,
    "CurrencyKey" SMALLINT,
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
    "ServiceTypeKey" SMALLINT,
    "ParentIntervalKey" BIGINT,
    "FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
    "RecordedDateUTCKey" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactIntervals" IS 'Intervals Fact Table';

--2015
CREATE TABLE dw.intervals_y2015m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m07 ("StartDateTimeUTC", "EndDateTimeUTC");


CREATE TABLE dw.intervals_y2015m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2015m12 ("StartDateTimeUTC", "EndDateTimeUTC");


--2016
CREATE TABLE dw.intervals_y2016m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2016m12 ("StartDateTimeUTC", "EndDateTimeUTC");

--2017
CREATE TABLE dw.intervals_y2017m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2017m12 ("StartDateTimeUTC", "EndDateTimeUTC");

--2018
CREATE TABLE dw.intervals_y2018m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2018m12 ("StartDateTimeUTC", "EndDateTimeUTC");

--2019
CREATE TABLE dw.intervals_y2019m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime");
CREATE INDEX ON dw.intervals_y2019m12 ("StartDateTimeUTC", "EndDateTimeUTC");

INSERT INTO public."DatabaseVersionHistory" VALUES ('003_DW_FactIntervals_Create_Scripts');-- FactWeather
CREATE TABLE dw."FactWeather"
(
    "WeatherKey" BIGSERIAL,
    "InsertionDateTime" TIMESTAMP,
    "TimeZoneKey" SMALLINT,
    "StationKey" INT,
	"EndDateTimeLocal" TIMESTAMP ,
	"EndDateTimeUTC" TIMESTAMP ,
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
    "oC" INT,
    "oF" INT,
    "Humidity" INT
)PARTITION BY RANGE ("EndDateLocalKey");
COMMENT ON TABLE dw."FactWeather" IS 'Weather Fact Table';


--2015
CREATE TABLE dw.weather_y2015m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.weather_y2015m06 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2015m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.weather_y2015m07 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");


CREATE TABLE dw.weather_y2015m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.weather_y2015m08 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2015m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.weather_y2015m09 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2015m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.weather_y2015m10 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2015m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.weather_y2015m11 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2015m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.weather_y2015m12 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");


--2016
CREATE TABLE dw.weather_y2016m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.weather_y2016m01 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.weather_y2016m02 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.weather_y2016m03 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.weather_y2016m04 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.weather_y2016m05 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.weather_y2016m06 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.weather_y2016m07 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.weather_y2016m08 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.weather_y2016m09 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.weather_y2016m10 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.weather_y2016m11 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2016m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.weather_y2016m12 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

--2017
CREATE TABLE dw.weather_y2017m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.weather_y2017m01 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.weather_y2017m02 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.weather_y2017m03 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.weather_y2017m04 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.weather_y2017m05 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.weather_y2017m06 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.weather_y2017m07 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.weather_y2017m08 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.weather_y2017m09 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.weather_y2017m10 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.weather_y2017m11 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2017m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.weather_y2017m12 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

--2018
CREATE TABLE dw.weather_y2018m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.weather_y2018m01 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.weather_y2018m02 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.weather_y2018m03 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.weather_y2018m04 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.weather_y2018m05 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.weather_y2018m06 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.weather_y2018m07 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.weather_y2018m08 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.weather_y2018m09 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.weather_y2018m10 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.weather_y2018m11 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2018m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.weather_y2018m12 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

--2019
CREATE TABLE dw.weather_y2019m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.weather_y2019m01 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.weather_y2019m02 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.weather_y2019m03 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.weather_y2019m04 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.weather_y2019m05 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.weather_y2019m06 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.weather_y2019m07 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.weather_y2019m08 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.weather_y2019m09 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.weather_y2019m10 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.weather_y2019m11 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

CREATE TABLE dw.weather_y2019m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.weather_y2019m12 ("EndDateLocalKey", "EndTimeLocalKey", "EndDateTimeLocal");

INSERT INTO public."DatabaseVersionHistory" VALUES ('004_DW_FactWeather_Create_Scripts');CREATE SCHEMA stg;
-- Stg_Account
CREATE TABLE stg."Account"
(
    "AccountId" integer ,
    "CustomerId" integer,
	"CustomerName" character varying(256),
    "ClientId" integer,
    "AccountNumber" character varying(50),
    "PremiseNumber" character varying(5),
    "ControlAreaId" integer,
	"TimeZoneId" integer,
	"ClientAccountKey" character varying(100),
    "ApplicationCode" varchar(4),
	"StartActiveDateTimeUTC"   TIMESTAMP,
	"EndActiveDateTimeUTC"     TIMESTAMP,
	"StartActiveDateTimeLocal" TIMESTAMP,
	"EndActiveDateTimeLocal"   TIMESTAMP,
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."Account" IS 'Account Staging Table';


-- Stg_Channel
CREATE TABLE stg."Channel"
(
    "ChannelId" integer ,
    "ChannelNumber" integer,
    "UnitOfMeasureId" integer,
    "ChannelTypeId" integer,
    "RTPId" integer,
    "IntervalsPerHour" integer,
    "NumberOfDials" integer,
    "IsDelivered" boolean,
    "SetNumber" integer,
    "MeterMultiplier" numeric(12,5),
    "PulseMultiplier" numeric(12,5),
    "PulseOffset" numeric(12,5),
    "BillingMultiplier" numeric(12,5),
    "IsVirtual" boolean,
    "IsSum" boolean,
	"ChannelTypeDescription" character varying(20),
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."Channel" IS 'Channel Staging Table';

--Stg_Client
CREATE TABLE stg."Client"
(
    "ClientId" integer ,
    "Name" character varying(50) ,
    "LogoFileName" character varying(100) ,
    "ClientUrl" character varying(255) ,
    "IsUserSetupAllowed" boolean ,
    "MonthsToRetain" integer ,
    "ShowIntervalStatus" boolean ,
    "CustomThemeId" integer ,
    "Duns" text,
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."Client" IS 'Client Staging Table';


--Stg_ControlArea
CREATE TABLE stg."ControlArea"
(
    "ControlAreaId" integer ,
    "Name" character varying(50),
    "Abbreviation" character varying(5),
    "Duns" text,
    "StatusDateTime" timestamp without time zone,
    "StatusId" integer,
    "StatusWebUserId" integer,
    "IndSysOperatorId" integer
);
COMMENT ON TABLE stg."ControlArea" IS 'ControlArea Staging Table';

--Stg_Customer
CREATE TABLE stg."Customer"
(
    "CustomerId" integer,
    "Name" character varying(256),
	"ApplicationCode" varchar(4),
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."Customer" IS 'Customer Staging Table';


--Stg_EnergyPowerType
CREATE TABLE stg."EnergyPowerType"
(
    "EnergyPowerTypeId" integer,
    "Description" character varying(20)
);
COMMENT ON TABLE stg."EnergyPowerType" IS 'EnergyPowerType Staging Table';

--Stg_IndSysOperator
CREATE TABLE stg."IndSysOperator"
(
    "IndSysOperatorId" integer,
    "Name" character varying(50),
    "Description" text,
    "StatusDateTime" timestamp without time zone,
    "StatusId" integer,
    "StatusWebUserId" integer
);
COMMENT ON TABLE stg."IndSysOperator" IS 'IndSysOperator Staging Table';

--Stg_Meter
CREATE TABLE stg."Meter"
(
    "MeterId" integer,
    "MeterTypeId" integer,
    "Name" character varying(50),
    "DeviceCode" character varying(50),
    "IntervalsPerHour" integer,
    "IsDSTEnabled" boolean,
    "TimeZoneId" integer,
    "IsVirtual" boolean,
    "DSTRegionId" integer,
    "FirstEndDateTime" timestamp(0) with time zone,
    "LastEndDateTime" timestamp(0) with time zone,
	"Manufacturer" character varying(50),
	"Type" character varying(50),
	"ApplicationCode" varchar(4),
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."Meter" IS 'Meter Staging Table';

--Stg_ObservationStation
CREATE TABLE stg."ObservationStation"
(
    "ObservationStationId" integer,
    "Name" character varying(5)
);
COMMENT ON TABLE stg."ObservationStation" IS 'ObservationStation Staging Table';

--Stg_PowerFactorGroup
CREATE TABLE stg."PowerFactorGroup"
(
    "PowerFactorGroupId" integer,
    "ActiveUnitOfMeasureId" integer,
    "ReactiveUnitOfMeasureId" integer,
    "ApparentUnitOfMeasureId" integer,
    "QuadergyUnitOfMeasureId" integer
);
COMMENT ON TABLE stg."PowerFactorGroup" IS 'PowerFactorGroup Staging Table';

--Stg_SDP
CREATE TABLE stg."SDP"
(
    "SDPId" integer,
    "Name" character varying(50),
    "Address" character varying(250),
    "Address1" character varying(250),
    "CityId" integer,
    "PostalCode" character varying(9),
    "Longitude" numeric(9,6),
    "Latitude" numeric(9,6),
    "TimeZoneId" integer,
    "DSTRegionId" integer,
    "IsVirtual" boolean,
    "LoadReductionPriceCode" character varying(20),
    "CustomerBaseLineAdjustmentLoadReduction" numeric(18,2),
    "CustomerBaseLineAdjustmentType" character varying(1),
    "RtpId" integer,
    "ObservationStationId" integer,
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."SDP" IS 'SDP Staging Table';

--Stg_Location
CREATE TABLE stg."Location"
(
   "CityId" integer ,
   "CityName" character varying(100),
   "StateAbbreviation" character varying(3),
   "StateName" character varying(30),
   "CountryAbbreviation" character varying(3),
   "CountryName" character varying(30)
);
COMMENT ON TABLE stg."Location" IS 'Location Staging Table';

--Stg_TimeZone
CREATE TABLE stg."TimeZone"
(
    "TimeZoneId" integer,
    "OffsetToGMT" integer,
	"Abbreviation" character varying(5),
    "Name" character varying(50)
);
COMMENT ON TABLE stg."TimeZone" IS 'TimeZone Staging Table';

--Stg_UnitOfMeasure
CREATE TABLE stg."UnitOfMeasure"
(
    "UnitOfMeasureId" integer,
    "Code" character varying(20),
    "UnitOfMeasureTypeId" integer,
    "EnergyPowerTypeId" integer,
    "UomFromMV90" integer,
    "Description" character varying(20),
    "UnitOfMeasureConversionId" integer,
    "EDI867Code" text,
	"UomTypeDescription" character varying(20)
);
COMMENT ON TABLE stg."UnitOfMeasure" IS 'UnitOfMeasure Staging Table';




-- FactIntervals
CREATE TABLE stg."FactIntervals"
(
	"MontlhyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,
	"UsageDLF" NUMERIC(28,4),
    "Demand" NUMERIC(28,4) ,
	"DemandDLF" NUMERIC(28,4) ,
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
    "DLP" NUMERIC(18,6),
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),
    "DLF" NUMERIC(18,7),
	"Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
    "MarginalUsage" NUMERIC(28,4),
    "MarginalCost" NUMERIC(28,4),
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
	"ClientId" INT,
    "AccountId" INT,
    "SDPId" INT ,
    "DeviceCode" character varying(50),
    "ChannelId" INT,
    "CurrencyCode" VARCHAR(3),
	"OriginConsumptionCode" VARCHAR(8),
	"ApplicationCode" varchar(4),
    "EndDateLocal" TIMESTAMP,
    "EndTimeLocal" VARCHAR(10),
    "EndDateUTC" TIMESTAMP,
    "EndTimeUTC" VARCHAR(10),
	"RecordedDateUTC" TIMESTAMP
);
COMMENT ON TABLE stg."FactIntervals" IS 'Intervals Staging Fact Table';
CREATE INDEX ON stg."FactIntervals" ("EndDateTimeUTC", "ApplicationCode");


-- TEMPORARY TABLE USED DURING  MERGE OPERATION
CREATE TABLE public.meter_temp
(
    "MeterId" integer,
    "MeterTypeId" integer,
    "Name" character varying(50) COLLATE pg_catalog."default",
    "DeviceCode" character varying(50) COLLATE pg_catalog."default",
    "IntervalsPerHour" integer,
    "IsDSTEnabled" boolean,
    "TimeZoneId" integer,
    "InsertionTimeZoneKey" smallint,
    "IsVirtual" boolean,
    "DSTRegionId" integer,
    "FirstEndDateTime" timestamp(0) with time zone,
    "LastEndDateTime" timestamp(0) with time zone,
    "Manufacturer" character varying(50) COLLATE pg_catalog."default",
    "Type" character varying(50) COLLATE pg_catalog."default",
    "ApplicationCode" character varying(4) COLLATE pg_catalog."default",
    "StartDateTime" timestamp without time zone,
    "MeterKey" integer,
    "Current" boolean,
    "TimeZoneKey" smallint
);


CREATE TABLE public.account_temp
(
    "AccountId" integer,
    "CustomerId" integer,
    "CustomerName" character varying(256) COLLATE pg_catalog."default",
    "CustomerAlternateId" character varying COLLATE pg_catalog."default",
    "ClientId" integer,
    "InsertionClientKey" integer,
    "AccountNumber" character varying(50) COLLATE pg_catalog."default",
    "PremiseNumber" character varying(5) COLLATE pg_catalog."default",
    "ControlAreaId" integer,
    "InsertionControlAreaKey" smallint,
    "TimeZoneId" integer,
    "InsertionTimeZoneKey" smallint,
    "ClientAccountKey" character varying(100) COLLATE pg_catalog."default",
    "ApplicationCode" character varying(4) COLLATE pg_catalog."default",
    "StartActiveDateTimeUTC" timestamp without time zone,
    "EndActiveDateTimeUTC" timestamp without time zone,
    "StartActiveDateTimeLocal" timestamp without time zone,
    "EndActiveDateTimeLocal" timestamp without time zone,
    "StartDateTime" timestamp without time zone,
    "AccountKey" integer,
	"ClientKey" integer,
    "InsertionCustomerKey" integer
);

CREATE TABLE public.facts_temp
(
    "dw_IntervalKey" bigint,
    "dw_InsertionDateTime" timestamp without time zone,
    "dw_MontlhyRead" numeric(28,4),
    "dw_Usage" numeric(28,4),
    "dw_UsageDLF" numeric(28,4),
    "dw_Demand" numeric(28,4),
    "dw_DemandDLF" numeric(28,4),
    "dw_TCC" numeric(28,4),
    "dw_CBL" numeric(28,4),
    "dw_DLP" numeric(18,6),
    "dw_DLPSum" numeric(18,6),
    "dw_DLPRation" numeric(18,6),
    "dw_DLF" numeric(18,7),
    "dw_Price" numeric(28,4),
    "dw_PriceReduction" numeric(28,4),
    "dw_MarginalUsage" numeric(28,4),
    "dw_MarginalCost" numeric(28,4),
    "dw_StartDateTimeUTC" timestamp without time zone,
    "dw_EndDateTimeUTC" timestamp without time zone,
    "dw_StartDateTimeLocal" timestamp without time zone,
    "dw_EndDateTimeLocal" timestamp without time zone,
    "dw_AccountKey" integer,
    "dw_SDPKey" integer,
    "dw_MeterKey" integer,
    "dw_ChannelKey" integer,
    "dw_CurrencyKey" smallint,
    "dw_OriginConsumptionKey" smallint,
    "dw_FactValueGoalKey" smallint,
    "dw_ServiceTypeKey" smallint,
    "dw_ParentIntervalKey" bigint,
    "dw_FactStatusKey" smallint,
    "dw_EndDateLocalKey" integer,
    "dw_EndTimeLocalKey" smallint,
    "dw_EndDateUTCKey" integer,
    "dw_EndTimeUTCKey" smallint,
    "dw_RecordedDateUTCKey" integer,
    "dw_ClientKey" integer,
    "stg_MontlhyRead" numeric(28,4),
    "stg_Usage" numeric(28,4),
    "stg_UsageDLF" numeric(28,4),
    "stg_Demand" numeric(28,4),
    "stg_DemandDLF" numeric(28,4),
    "stg_TCC" numeric(28,4),
    "stg_CBL" numeric(28,4),
    "stg_DLP" numeric(18,6),
    "stg_DLPSum" numeric(18,6),
    "stg_DLPRation" numeric(18,6),
    "stg_DLF" numeric(18,7),
    "stg_Price" numeric(28,4),
    "stg_PriceReduction" numeric(28,4),
    "stg_MarginalUsage" numeric(28,4),
    "stg_MarginalCost" numeric(28,4),
    "stg_StartDateTimeUTC" timestamp without time zone,
    "stg_EndDateTimeUTC" timestamp without time zone,
    "stg_StartDateTimeLocal" timestamp without time zone,
    "stg_EndDateTimeLocal" timestamp without time zone,
    "stg_ClientKey" integer,
    "stg_AccountKey" integer,
    "stg_SDPKey" integer,
    "stg_MeterKey" integer,
    "stg_ChannelKey" integer,
    "stg_OriginConsumptionKey" smallint,
    "stg_OriginConsumptionCode" character varying(8) COLLATE pg_catalog."default",
    "stg_CurrencyKey" smallint,
    "stg_ServiceTypeKey" smallint,
    "stg_EndDateLocalKey" integer,
    "stg_EndDateUTCKey" integer,
    "stg_EndTimeLocalKey" smallint,
    "stg_EndTimeUTCKey" smallint,
    "stg_RecordedDateKey" integer
) ;
CREATE INDEX ON public.facts_temp ("stg_EndDateUTCKey","dw_IntervalKey");

INSERT INTO public."DatabaseVersionHistory" VALUES ('005_DW_StagingTables_Create_Scripts');DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals";
CREATE OR REPLACE FUNCTION public."stpMergeDailyFactIntervals"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN


   -- TRUNCATE TEMP TABLE
  TRUNCATE  TABLE public.facts_temp ;

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MontlhyRead"        as "dw_MontlhyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "TCC"                as "dw_TCC",
                 "CBL"                as "dw_CBL",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "Price"              as "dw_Price",
                 "PriceReduction"     as "dw_PriceReduction",
                 "MarginalUsage"      as "dw_MarginalUsage",
                 "MarginalCost"       as "dw_MarginalCost",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "CurrencyKey"        as "dw_CurrencyKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
          	"MontlhyRead"           as "stg_MontlhyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "TCC"                   as "stg_TCC",
            "CBL"                   as "stg_CBL",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "Price"                 as "stg_Price",
            "PriceReduction"        as "stg_PriceReduction",
            "MarginalUsage"         as "stg_MarginalUsage",
            "MarginalCost"          as "stg_MarginalCost",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "CurrencyKey"           as "stg_CurrencyKey",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimPriceCurrency" price
        ON price."CurrencyCode" = fct."CurrencyCode"
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO public.facts_temp
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"      = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"
        AND dw_fact."dw_CurrencyKey"    = stg_fact."stg_CurrencyKey"
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_TCC",
           "stg_CBL",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_Price",
           "stg_PriceReduction",
           "stg_MarginalUsage",
           "stg_MarginalCost",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_CurrencyKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals" dw_fct
       SET "FactStatusKey" = 2
   FROM public.facts_temp fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_TCC"            != fct."dw_TCC"
               OR fct."stg_CBL"            != fct."dw_CBL"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
               OR fct."stg_Price"          != fct."dw_Price"
               OR fct."stg_PriceReduction" != fct."dw_PriceReduction"
               OR fct."stg_MarginalUsage"  != fct."dw_MarginalUsage"
               OR fct."stg_MarginalCost"   != fct."dw_MarginalCost"
            );

    INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
            now()::timestamp,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_TCC",
           "stg_CBL",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_Price",
           "stg_PriceReduction",
           "stg_MarginalUsage",
           "stg_MarginalCost",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_CurrencyKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_TCC"            != fct."dw_TCC"
               OR fct."stg_CBL"            != fct."dw_CBL"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
               OR fct."stg_Price"          != fct."dw_Price"
               OR fct."stg_PriceReduction" != fct."dw_PriceReduction"
               OR fct."stg_MarginalUsage"  != fct."dw_MarginalUsage"
               OR fct."stg_MarginalCost"   != fct."dw_MarginalCost"
            );

  -- CANCEL UNEXISTANTS FACTS
  UPDATE dw."FactIntervals" dw_fct
       SET "FactStatusKey" = 2
   FROM public.facts_temp fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;

   INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
   SELECT
           now()::timestamp,
           "dw_MontlhyRead",
           "dw_Usage",
           "dw_UsageDLF",
           "dw_Demand",
           "dw_DemandDLF",
           "dw_TCC",
           "dw_CBL",
           "dw_DLP",
           "dw_DLPSum",
           "dw_DLPRation",
           "dw_DLF",
           "dw_Price",
           "dw_PriceReduction",
           "dw_MarginalUsage",
           "dw_MarginalCost",
           "dw_StartDateTimeUTC",
           "dw_EndDateTimeUTC",
           "dw_StartDateTimeLocal",
           "dw_EndDateTimeLocal",
           "dw_AccountKey",
           "dw_SDPKey",
           "dw_MeterKey",
           "dw_ChannelKey",
           "dw_CurrencyKey",
           "dw_OriginConsumptionKey",
           3,
           "dw_ServiceTypeKey",
           "dw_ParentIntervalKey",
           2,
           "dw_EndDateLocalKey",
           "dw_EndTimeLocalKey",
           "dw_EndDateUTCKey",
           "dw_EndTimeUTCKey",
           "dw_RecordedDateUTCKey"
   FROM public.facts_temp fct
   WHERE    fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;




  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('006_DW_MergeDailyFacts_Create_Scripts');CREATE or REPLACE FUNCTION dw."stpGetSettlementInfos" ( "clientIdParam"      INTEGER,
                                                        "startTradeDayUTC"   TIMESTAMP,
                                                        "transactionDate"    TIMESTAMP)
RETURNS
  TABLE
      (
          "TotalAccounts"        BIGINT ,
          "TotalIntervals"       BIGINT ,
          "CompletedIntervals"   BIGINT ,
          "EstimatedIntervals"   BIGINT ,
          "ExtraneousMeterReads" BIGINT ,
          "TotalKWH"             NUMERIC(28,4),
          "TotalMeters"          BIGINT,
          "TotalChannels"        BIGINT
      ) AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN

    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                orig."Code" as "OriginConsumptionCode",
                act."AccountAlternateKey",
                meter."MeterAlternateKey",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateUTCKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimOriginFactValue" orig
          ON orig."OriginConsumptionKey" = fct."OriginConsumptionKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND status."Code" = 'CURRENT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND fct."InsertionDateTime" <= "transactionDate"
              AND act."ApplicationCode"    = 'SETT'
              AND meter."ApplicationCode"  = 'SETT'
		),
    totals_CTE as
    (
        SELECT
              COUNT(DISTINCT "AccountAlternateKey") AS "Accounts",
              COUNT(*) AS "Intervals",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('REAL','CALC') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsCompleted",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('ESTI') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsEstimated",
              0::BIGINT AS "ExtraneousReads",
              sum("UsageDLF") AS "KWH",
              COUNT(DISTINCT "MeterAlternateKey") AS "Meters",
              COUNT(DISTINCT "ChannelAlternateKey") AS "Channels"
        FROM intervalsData_CTE
    )
    SELECT  *
    FROM totals_CTE;
END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('007_DW_SettlementInfos_Create_Scripts');DROP FUNCTION IF EXISTS dw."stpGetSettlementInfos";
CREATE or REPLACE FUNCTION dw."stpGetSettlementInfos" ( "clientIdParam"      INTEGER,
                                                        "isoIdParam"         INTEGER,
                                                        "startTradeDayUTC"   TIMESTAMP,
                                                        "transactionDate"    TIMESTAMP)
RETURNS
  TABLE
      (
          "TotalAccounts"        BIGINT ,
          "TotalIntervals"       BIGINT ,
          "CompletedIntervals"   BIGINT ,
          "EstimatedIntervals"   BIGINT ,
          "ExtraneousMeterReads" BIGINT ,
          "TotalKWH"             NUMERIC(28,4),
          "TotalMeters"          BIGINT,
          "TotalChannels"        BIGINT
      ) AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN

    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                orig."Code" as "OriginConsumptionCode",
                act."AccountAlternateKey",
                meter."MeterAlternateKey",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateUTCKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimOriginFactValue" orig
          ON orig."OriginConsumptionKey" = fct."OriginConsumptionKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND status."Code" = 'CURRENT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND fct."InsertionDateTime" <= "transactionDate"
              AND act."ApplicationCode"    = 'SETT'
              AND meter."ApplicationCode"  = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
		),
    totals_CTE as
    (
        SELECT
              COUNT(DISTINCT "AccountAlternateKey") AS "Accounts",
              COUNT(*) AS "Intervals",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('REAL','CALC') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsCompleted",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('ESTI') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsEstimated",
              0::BIGINT AS "ExtraneousReads",
              sum("UsageDLF") AS "KWH",
              COUNT(DISTINCT "MeterAlternateKey") AS "Meters",
              COUNT(DISTINCT "ChannelAlternateKey") AS "Channels"
        FROM intervalsData_CTE
    )
    SELECT  *
    FROM totals_CTE;
END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('008_DW_SettlementInfos_Create_Scripts');DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals";
CREATE OR REPLACE FUNCTION public."stpMergeDailyFactIntervals"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MontlhyRead"        as "dw_MontlhyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "TCC"                as "dw_TCC",
                 "CBL"                as "dw_CBL",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "Price"              as "dw_Price",
                 "PriceReduction"     as "dw_PriceReduction",
                 "MarginalUsage"      as "dw_MarginalUsage",
                 "MarginalCost"       as "dw_MarginalCost",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "CurrencyKey"        as "dw_CurrencyKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
          	"MontlhyRead"           as "stg_MontlhyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "TCC"                   as "stg_TCC",
            "CBL"                   as "stg_CBL",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "Price"                 as "stg_Price",
            "PriceReduction"        as "stg_PriceReduction",
            "MarginalUsage"         as "stg_MarginalUsage",
            "MarginalCost"          as "stg_MarginalCost",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "CurrencyKey"           as "stg_CurrencyKey",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimPriceCurrency" price
        ON price."CurrencyCode" = fct."CurrencyCode"
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO public.facts_temp
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"      = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"
        AND dw_fact."dw_CurrencyKey"    = stg_fact."stg_CurrencyKey"
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_TCC",
           "stg_CBL",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_Price",
           "stg_PriceReduction",
           "stg_MarginalUsage",
           "stg_MarginalCost",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_CurrencyKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals" dw_fct
       SET "FactStatusKey" = 2
   FROM public.facts_temp fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_TCC"            != fct."dw_TCC"
               OR fct."stg_CBL"            != fct."dw_CBL"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
               OR fct."stg_Price"          != fct."dw_Price"
               OR fct."stg_PriceReduction" != fct."dw_PriceReduction"
               OR fct."stg_MarginalUsage"  != fct."dw_MarginalUsage"
               OR fct."stg_MarginalCost"   != fct."dw_MarginalCost"
            );

    INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
            now()::timestamp,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_TCC",
           "stg_CBL",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_Price",
           "stg_PriceReduction",
           "stg_MarginalUsage",
           "stg_MarginalCost",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_CurrencyKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_TCC"            != fct."dw_TCC"
               OR fct."stg_CBL"            != fct."dw_CBL"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
               OR fct."stg_Price"          != fct."dw_Price"
               OR fct."stg_PriceReduction" != fct."dw_PriceReduction"
               OR fct."stg_MarginalUsage"  != fct."dw_MarginalUsage"
               OR fct."stg_MarginalCost"   != fct."dw_MarginalCost"
            );

  -- CANCEL UNEXISTANTS FACTS
  UPDATE dw."FactIntervals" dw_fct
       SET "FactStatusKey" = 2
   FROM public.facts_temp fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;

   INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
   SELECT
           now()::timestamp,
           "dw_MontlhyRead",
           "dw_Usage",
           "dw_UsageDLF",
           "dw_Demand",
           "dw_DemandDLF",
           "dw_TCC",
           "dw_CBL",
           "dw_DLP",
           "dw_DLPSum",
           "dw_DLPRation",
           "dw_DLF",
           "dw_Price",
           "dw_PriceReduction",
           "dw_MarginalUsage",
           "dw_MarginalCost",
           "dw_StartDateTimeUTC",
           "dw_EndDateTimeUTC",
           "dw_StartDateTimeLocal",
           "dw_EndDateTimeLocal",
           "dw_AccountKey",
           "dw_SDPKey",
           "dw_MeterKey",
           "dw_ChannelKey",
           "dw_CurrencyKey",
           "dw_OriginConsumptionKey",
           3,
           "dw_ServiceTypeKey",
           "dw_ParentIntervalKey",
           2,
           "dw_EndDateLocalKey",
           "dw_EndTimeLocalKey",
           "dw_EndDateUTCKey",
           "dw_EndTimeUTCKey",
           "dw_RecordedDateUTCKey"
   FROM public.facts_temp fct
   WHERE    fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;




  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('010_DW_MergeDailyFacts_Create_Scripts');DROP TABLE dw."FactIntervals";
-- FactIntervals
CREATE TABLE dw."FactIntervals"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"MontlhyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,	
	"UsageDLF" NUMERIC(28,4),	
    "Demand" NUMERIC(28,4) ,    
	"DemandDLF" NUMERIC(28,4) ,    
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
    "DLP" NUMERIC(18,6),	
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),	
    "DLF" NUMERIC(18,7),
	"Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
    "MarginalUsage" NUMERIC(28,4),
    "MarginalCost" NUMERIC(28,4),
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
    "AccountKey" INT,
    "SDPKey" INT ,
    "MeterKey" INT,
    "ChannelKey" INT,
    "CurrencyKey" SMALLINT,
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
	"ServiceTypeKey" SMALLINT,
	"ParentIntervalKey" BIGINT,
	"FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactIntervals" IS 'Intervals Fact Table';

--2015
CREATE TABLE dw.intervals_y2015m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m07 ("StartDateTimeUTC", "EndDateTimeUTC");


CREATE TABLE dw.intervals_y2015m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2015m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m12 ("StartDateTimeUTC", "EndDateTimeUTC");


--2016
CREATE TABLE dw.intervals_y2016m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2016m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m12 ("StartDateTimeUTC", "EndDateTimeUTC");

--2017
CREATE TABLE dw.intervals_y2017m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2017m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m12 ("StartDateTimeUTC", "EndDateTimeUTC");

--2018
CREATE TABLE dw.intervals_y2018m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2018m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m12 ("StartDateTimeUTC", "EndDateTimeUTC");

--2019
CREATE TABLE dw.intervals_y2019m01 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m01 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m02 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m02 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m03 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m03 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m04 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m04 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m05 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m05 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m06 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m06 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m07 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m07 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m08 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m08 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m09 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m09 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m10 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m10 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m11 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m11 ("StartDateTimeUTC", "EndDateTimeUTC");

CREATE TABLE dw.intervals_y2019m12 PARTITION OF dw."FactIntervals"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m12 ("StartDateTimeUTC", "EndDateTimeUTC");

INSERT INTO public."DatabaseVersionHistory" VALUES ('011_DW_FactIntervals_Drop_Create_Scripts');DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals";
CREATE OR REPLACE FUNCTION public."stpMergeDailyFactIntervals"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MontlhyRead"        as "dw_MontlhyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "TCC"                as "dw_TCC",
                 "CBL"                as "dw_CBL",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "Price"              as "dw_Price",
                 "PriceReduction"     as "dw_PriceReduction",
                 "MarginalUsage"      as "dw_MarginalUsage",
                 "MarginalCost"       as "dw_MarginalCost",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "CurrencyKey"        as "dw_CurrencyKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MontlhyRead"           as "stg_MontlhyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "TCC"                   as "stg_TCC",
            "CBL"                   as "stg_CBL",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "Price"                 as "stg_Price",
            "PriceReduction"        as "stg_PriceReduction",
            "MarginalUsage"         as "stg_MarginalUsage",
            "MarginalCost"          as "stg_MarginalCost",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "CurrencyKey"           as "stg_CurrencyKey",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimPriceCurrency" price
        ON price."CurrencyCode" = fct."CurrencyCode"
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO public.facts_temp
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"      = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"
        AND dw_fact."dw_CurrencyKey"    = stg_fact."stg_CurrencyKey"
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "AgingDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_TCC",
           "stg_CBL",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_Price",
           "stg_PriceReduction",
           "stg_MarginalUsage",
           "stg_MarginalCost",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_CurrencyKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_TCC"            != fct."dw_TCC"
               OR fct."stg_CBL"            != fct."dw_CBL"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
               OR fct."stg_Price"          != fct."dw_Price"
               OR fct."stg_PriceReduction" != fct."dw_PriceReduction"
               OR fct."stg_MarginalUsage"  != fct."dw_MarginalUsage"
               OR fct."stg_MarginalCost"   != fct."dw_MarginalCost"
            );

    INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "AgingDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_TCC",
           "stg_CBL",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_Price",
           "stg_PriceReduction",
           "stg_MarginalUsage",
           "stg_MarginalCost",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_CurrencyKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_TCC"            != fct."dw_TCC"
               OR fct."stg_CBL"            != fct."dw_CBL"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
               OR fct."stg_Price"          != fct."dw_Price"
               OR fct."stg_PriceReduction" != fct."dw_PriceReduction"
               OR fct."stg_MarginalUsage"  != fct."dw_MarginalUsage"
               OR fct."stg_MarginalCost"   != fct."dw_MarginalCost"
            );

  -- CANCEL UNEXISTANTS FACTS
  UPDATE dw."FactIntervals" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;

   INSERT INTO dw."FactIntervals"(
      "InsertionDateTime",
      "AgingDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "TCC",
      "CBL",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "Price",
      "PriceReduction",
      "MarginalUsage",
      "MarginalCost",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "CurrencyKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
   SELECT
           now()::timestamp,
	   now()::timestamp,
           "dw_MontlhyRead",
           "dw_Usage",
           "dw_UsageDLF",
           "dw_Demand",
           "dw_DemandDLF",
           "dw_TCC",
           "dw_CBL",
           "dw_DLP",
           "dw_DLPSum",
           "dw_DLPRation",
           "dw_DLF",
           "dw_Price",
           "dw_PriceReduction",
           "dw_MarginalUsage",
           "dw_MarginalCost",
           "dw_StartDateTimeUTC",
           "dw_EndDateTimeUTC",
           "dw_StartDateTimeLocal",
           "dw_EndDateTimeLocal",
           "dw_AccountKey",
           "dw_SDPKey",
           "dw_MeterKey",
           "dw_ChannelKey",
           "dw_CurrencyKey",
           "dw_OriginConsumptionKey",
           3,
           "dw_ServiceTypeKey",
           "dw_ParentIntervalKey",
           2,
           "dw_EndDateLocalKey",
           "dw_EndTimeLocalKey",
           "dw_EndDateUTCKey",
           "dw_EndTimeUTCKey",
           "dw_RecordedDateUTCKey"
   FROM public.facts_temp fct
   WHERE    fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;




  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('012_DW_MergeDailyFacts_Create_Scripts');CREATE or REPLACE FUNCTION dw."stpGetOMARNewData"("ClientId" INTEGER, "TradeDay" TIMESTAMP WITHOUT TIME ZONE, "TransactionDateTime" TIMESTAMP WITHOUT TIME ZONE)
  RETURNS TABLE("Id" INTEGER, "TheClientId" INTEGER, "TheTradeDay" TIMESTAMP WITHOUT TIME ZONE, "TheTransactionDateTime" TIMESTAMP WITHOUT TIME ZONE)
LANGUAGE plpgsql
AS $$
BEGIN

RETURN QUERY
SELECT 1 AS "Id", "ClientId", "TradeDay", "TransactionDateTime"
UNION
SELECT 2 AS "Id", "ClientId", "TradeDay", "TransactionDateTime"
UNION
SELECT 3 AS "Id", "ClientId", "TradeDay", "TransactionDateTime";
END
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('013_DW_OMARNewData_Create_Scripts');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN


    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
		),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"--,
                 --"ChannelAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";
END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('014_DW_MisoData_Create_Scripts');--DimMeter RECREATE INDEXES
DROP INDEX dw.DimMeter_MeterAlternateKey_Name_Current_index;
CREATE INDEX DimMeter_MeterAlternateKey_AppCode_Name_Current_index ON dw."DimMeter" ("MeterAlternateKey","ApplicationCode","Name","Current");
REINDEX TABLE dw."DimMeter";


--DimChannel Rearange alternatekey value

--TRUNCATE DATA 
TRUNCATE TABLE dw."FactIntervals";
TRUNCATE TABLE dw."DimChannel";

--DROP TABLE 
DROP TABLE dw."DimChannel";

-- RECREATE CHANNEL TABLE 
CREATE TABLE dw."DimChannel"
(
    "ChannelKey" BIGSERIAL PRIMARY KEY NOT NULL,
    "ChannelAlternateKey" VARCHAR(100) NOT NULL,
	"ApplicationCode" varchar(4) NOT NULL,
    "ChannelNumber" SMALLINT NOT NULL,
    "SetNumber" SMALLINT,
    "NumberOfDials" SMALLINT NOT NULL,
    "MeterMultiplier" DECIMAL(12,5) NOT NULL,
    "PulseMultiplier" DECIMAL(12,5) NOT NULL,
    "PulseOffset" DECIMAL(12,5) NOT NULL,
    "BillingMultiplier" DECIMAL(12,5) NOT NULL,
    "EnglishChannelTypeDescription" VARCHAR(20) NOT NULL,
    "SpanishChannelTypeDescription" VARCHAR(20) NOT NULL,
    "IntervalsPerHour" SMALLINT NOT NULL,
    "IsDelivered" boolean,
    "IsVirtual" boolean NOT NULL,
    "UomKey" SMALLINT NOT NULL,
	"PowerFctConfigKey" INT,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimChannel" IS 'Channel and Channel Type Dimension';
CREATE INDEX DimChan_AlternateKey_AppCode_ChanNumber_Current_index ON dw."DimChannel" ("ChannelAlternateKey","ApplicationCode","ChannelNumber","Current");
CREATE INDEX DimChan_AlternateKey_AppCode_IntPerHour_Uom_Current_index ON dw."DimChannel" ("ChannelAlternateKey","ApplicationCode","IntervalsPerHour","UomKey","Current");
ALTER TABLE dw."DimChannel" ADD CONSTRAINT FK_Channel_UOM FOREIGN KEY ("UomKey") REFERENCES dw."DimUOM"("UomKey");
ALTER TABLE dw."DimChannel" ADD CONSTRAINT FK_Channel_PowerFctConfig   FOREIGN KEY ("PowerFctConfigKey") REFERENCES dw."DimPowerFctConfig"("PowerFctConfigKey");


--REBUILD INDEX
REINDEX TABLE dw."DimChannel";


-- DROP STAGING TABLE 
DROP TABLE stg."Channel";

--RECREATE STAGING TABLE 
CREATE TABLE stg."Channel"
(
    "ChannelId" VARCHAR(100) ,
	"ApplicationCode" varchar(4),
    "ChannelNumber" integer,
    "UnitOfMeasureId" integer,
    "ChannelTypeId" integer,
    "RTPId" integer,
    "IntervalsPerHour" integer,
    "NumberOfDials" integer,
    "IsDelivered" boolean,
    "SetNumber" integer,
    "MeterMultiplier" numeric(12,5),
    "PulseMultiplier" numeric(12,5),
    "PulseOffset" numeric(12,5),
    "BillingMultiplier" numeric(12,5),
    "IsVirtual" boolean,
    "IsSum" boolean,
	"ChannelTypeDescription" character varying(20),
	"StartDateTime" TIMESTAMP
);
COMMENT ON TABLE stg."Channel" IS 'Channel Staging Table';


ALTER TABLE stg."FactIntervals"
ALTER COLUMN "ChannelId" SET DATA TYPE VARCHAR(100);


INSERT INTO public."DatabaseVersionHistory" VALUES ('015_DW_DimChannel_AlternateKey_Update_Script');


--Clured Dimension table on their primary key

--DimAccount
CLUSTER dw."DimAccount" USING "DimAccount_pkey";

--DimChannel
CLUSTER dw."DimChannel" USING "DimChannel_pkey";

--DimClient
CLUSTER dw."DimClient" USING "DimClient_pkey";

--DimControlArea
CLUSTER dw."DimControlArea" USING "DimControlArea_pkey";

--DimCustomer
CLUSTER dw."DimCustomer" USING "DimCustomer_pkey";

--DimDate
CLUSTER dw."DimDate" USING "DimDate_pkey";

--DimEnergyPowerType
CLUSTER dw."DimEnergyPowerType" USING "DimEnergyPowerType_pkey";

--DimFactStatus
CLUSTER dw."DimFactStatus" USING "DimFactStatus_pkey";

--DimFactValueGoal
CLUSTER dw."DimFactValueGoal" USING "DimFactValueGoal_pkey";

--DimISO
CLUSTER dw."DimISO" USING "DimISO_pkey";

--DimLocation
CLUSTER dw."DimLocation" USING "DimLocation_pkey";

--DimMeter
CLUSTER dw."DimMeter" USING "DimMeter_pkey";

--DimOriginFactValue
CLUSTER dw."DimOriginFactValue" USING "DimOriginFactValue_pkey";

--DimPowerFctConfig
CLUSTER dw."DimPowerFctConfig" USING "DimPowerFctConfig_pkey";

--DimPriceCurrency
CLUSTER dw."DimPriceCurrency" USING "DimPriceCurrency_pkey";

--DimSDP
CLUSTER dw."DimSDP" USING "DimSDP_pkey";

--DimServiceType
CLUSTER dw."DimServiceType" USING "DimServiceType_pkey";

--DimTime
CLUSTER dw."DimTime" USING "DimTime_pkey";

--DimTimeZone
CLUSTER dw."DimTimeZone" USING "DimTimeZone_pkey";

--DimUom
CLUSTER dw."DimUOM" USING "DimUOM_pkey";

--DimWeatherStation
CLUSTER dw."DimWeatherStation" USING "DimWeatherStation_pkey";

INSERT INTO public."DatabaseVersionHistory" VALUES ('016_DW_DimClustered_Create_Script');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN


    RETURN  QUERY
    with intervalsData_CTE  as
	(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr"
		
        FROM dw."FactIntervals" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
	          AND chan."IsDelivered" = TRUE
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
	),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('017_DW_MisoData_Create_Scripts');DROP FUNCTION IF EXISTS ct."stpGetLastLoadStreamInfo";

CREATE or REPLACE FUNCTION ct."stpGetLastLoadStreamInfo" ()
RETURNS
  TABLE
      (
        "StreamId" bigint,
		"FromSyncDateUTC" timestamp,
		"ToSyncDateUTC" timestamp,
		"ProcessStartDateTime" timestamp,
		"ProcessEndDateTime" timestamp,
		"Status" character varying(10)		  
      ) AS $$      
BEGIN

    RETURN  QUERY
    SELECT  
		str."StreamId",
		str."FromSyncDateUTC",
		str."ToSyncDateUTC",
		str."ProcessStartDateTime",
		str."ProcessEndDateTime",
		str."Status"		  
    FROM ct."LoadStream" str
	ORDER BY "StreamId" DESC
	LIMIT 1;

END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('018_DW_EtlGetLastLoadStream_Create_Scripts');
DROP TABLE dw."FactIntervals";
-- FactIntervals
CREATE TABLE dw."FactIntervals_SETT"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"MontlhyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,	
	"UsageDLF" NUMERIC(28,4),	
    "Demand" NUMERIC(28,4) ,    
	"DemandDLF" NUMERIC(28,4) ,        
    "DLP" NUMERIC(18,6),	
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),	
    "DLF" NUMERIC(18,7),    
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
    "AccountKey" INT,
    "SDPKey" INT ,
    "MeterKey" INT,
    "ChannelKey" INT,    
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
	"ServiceTypeKey" SMALLINT,
	"ParentIntervalKey" BIGINT,
	"FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactIntervals_SETT" IS 'Intervals Fact Table';

--2015
CREATE TABLE dw.intervals_y2015m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2015m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateTimeUTC", "StartDateTimeUTC");


CREATE TABLE dw.intervals_y2015m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2015m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2015m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2015m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2015m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateTimeUTC", "StartDateTimeUTC");


--2016
CREATE TABLE dw.intervals_y2016m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2016m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateTimeUTC", "StartDateTimeUTC");

--2017
CREATE TABLE dw.intervals_y2017m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2017m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateTimeUTC", "StartDateTimeUTC");

--2018
CREATE TABLE dw.intervals_y2018m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2018m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateTimeUTC", "StartDateTimeUTC");

--2019
CREATE TABLE dw.intervals_y2019m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateTimeUTC", "StartDateTimeUTC");

CREATE TABLE dw.intervals_y2019m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateTimeUTC", "StartDateTimeUTC");

INSERT INTO public."DatabaseVersionHistory" VALUES ('019_DW_FactIntervals_Remove_Unused_Create_Scripts');DROP TABLE stg."FactIntervals";

-- FactIntervals
CREATE TABLE stg."FactIntervals_SETT"
(
	"MontlhyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,
	"UsageDLF" NUMERIC(28,4),
    "Demand" NUMERIC(28,4) ,
	"DemandDLF" NUMERIC(28,4),        
    "DLP" NUMERIC(18,6),
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),
    "DLF" NUMERIC(18,7),
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
	"ClientId" INT,
    "AccountId" INT,
    "SDPId" INT ,
    "DeviceCode" character varying(50),
    "ChannelId" VARCHAR(100),
	"OriginConsumptionCode" VARCHAR(8),
	"ApplicationCode" varchar(4),
    "EndDateLocal" TIMESTAMP,
    "EndTimeLocal" VARCHAR(10),
    "EndDateUTC" TIMESTAMP,
    "EndTimeUTC" VARCHAR(10),
	"RecordedDateUTC" TIMESTAMP
);
COMMENT ON TABLE stg."FactIntervals_SETT" IS 'Intervals Staging Fact Table for Settlement';
CREATE INDEX ON stg."FactIntervals_SETT" ("EndDateTimeUTC", "ApplicationCode");



DROP TABLE public.facts_temp;

CREATE TABLE public.facts_temp_sett
(
    "dw_IntervalKey" bigint,
    "dw_InsertionDateTime" timestamp without time zone,
    "dw_MontlhyRead" numeric(28,4),
    "dw_Usage" numeric(28,4),
    "dw_UsageDLF" numeric(28,4),
    "dw_Demand" numeric(28,4),
    "dw_DemandDLF" numeric(28,4),
    "dw_DLP" numeric(18,6),
    "dw_DLPSum" numeric(18,6),
    "dw_DLPRation" numeric(18,6),
    "dw_DLF" numeric(18,7),
    "dw_StartDateTimeUTC" timestamp without time zone,
    "dw_EndDateTimeUTC" timestamp without time zone,
    "dw_StartDateTimeLocal" timestamp without time zone,
    "dw_EndDateTimeLocal" timestamp without time zone,
    "dw_AccountKey" integer,
    "dw_SDPKey" integer,
    "dw_MeterKey" integer,
    "dw_ChannelKey" integer,
    "dw_OriginConsumptionKey" smallint,
    "dw_FactValueGoalKey" smallint,
    "dw_ServiceTypeKey" smallint,
    "dw_ParentIntervalKey" bigint,
    "dw_FactStatusKey" smallint,
    "dw_EndDateLocalKey" integer,
    "dw_EndTimeLocalKey" smallint,
    "dw_EndDateUTCKey" integer,
    "dw_EndTimeUTCKey" smallint,
    "dw_RecordedDateUTCKey" integer,
    "dw_ClientKey" integer,
    "stg_MontlhyRead" numeric(28,4),
    "stg_Usage" numeric(28,4),
    "stg_UsageDLF" numeric(28,4),
    "stg_Demand" numeric(28,4),
    "stg_DemandDLF" numeric(28,4),
    "stg_DLP" numeric(18,6),
    "stg_DLPSum" numeric(18,6),
    "stg_DLPRation" numeric(18,6),
    "stg_DLF" numeric(18,7),
    "stg_StartDateTimeUTC" timestamp without time zone,
    "stg_EndDateTimeUTC" timestamp without time zone,
    "stg_StartDateTimeLocal" timestamp without time zone,
    "stg_EndDateTimeLocal" timestamp without time zone,
    "stg_ClientKey" integer,
    "stg_AccountKey" integer,
    "stg_SDPKey" integer,
    "stg_MeterKey" integer,
    "stg_ChannelKey" integer,
    "stg_OriginConsumptionKey" smallint,
    "stg_OriginConsumptionCode" character varying(8) COLLATE pg_catalog."default",
    "stg_ServiceTypeKey" smallint,
    "stg_EndDateLocalKey" integer,
    "stg_EndDateUTCKey" integer,
    "stg_EndTimeLocalKey" smallint,
    "stg_EndTimeUTCKey" smallint,
    "stg_RecordedDateKey" integer
) ;
CREATE INDEX ON public.facts_temp_sett ("stg_EndDateUTCKey","dw_IntervalKey");



INSERT INTO public."DatabaseVersionHistory" VALUES ('020_DW_StagingTables_Remove_Unused_Create_Scripts');DROP FUNCTION IF EXISTS dw."stpGetSettlementInfos";
CREATE or REPLACE FUNCTION dw."stpGetSettlementInfos" ( "clientIdParam"      INTEGER,
                                                        "isoIdParam"         INTEGER,
                                                        "startTradeDayUTC"   TIMESTAMP,
                                                        "transactionDate"    TIMESTAMP)
RETURNS
  TABLE
      (
          "TotalAccounts"        BIGINT ,
          "TotalIntervals"       BIGINT ,
          "CompletedIntervals"   BIGINT ,
          "EstimatedIntervals"   BIGINT ,
          "ExtraneousMeterReads" BIGINT ,
          "TotalKWH"             NUMERIC(28,4),
          "TotalMeters"          BIGINT,
          "TotalChannels"        BIGINT
      ) AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN

    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                orig."Code" as "OriginConsumptionCode",
                act."AccountAlternateKey",
                meter."MeterAlternateKey",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateUTCKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimOriginFactValue" orig
          ON orig."OriginConsumptionKey" = fct."OriginConsumptionKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND status."Code" = 'CURRENT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND fct."InsertionDateTime" <= "transactionDate"
              AND act."ApplicationCode"    = 'SETT'
              AND meter."ApplicationCode"  = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
		),
    totals_CTE as
    (
        SELECT
              COUNT(DISTINCT "AccountAlternateKey") AS "Accounts",
              COUNT(*) AS "Intervals",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('REAL','CALC') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsCompleted",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('ESTI') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsEstimated",
              0::BIGINT AS "ExtraneousReads",
              sum("UsageDLF") AS "KWH",
              COUNT(DISTINCT "MeterAlternateKey") AS "Meters",
              COUNT(DISTINCT "ChannelAlternateKey") AS "Channels"
        FROM intervalsData_CTE
    )
    SELECT  *
    FROM totals_CTE;
END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('021_DW_SettlementInfos_Create_Scripts');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN


    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
		),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"--,
                 --"ChannelAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";
END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('022_DW_MisoData_Create_Scripts');DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals";
CREATE OR REPLACE FUNCTION public."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MontlhyRead"        as "dw_MontlhyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MontlhyRead"           as "stg_MontlhyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals_SETT" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO public.facts_temp_sett
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"      = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MontlhyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  fct."stg_MontlhyRead"    != fct."dw_MontlhyRead"
               OR fct."stg_Usage"          != fct."dw_Usage"
               OR fct."stg_UsageDLF"       != fct."dw_UsageDLF"
               OR fct."stg_Demand"         != fct."dw_Demand"
               OR fct."stg_DemandDLF"      != fct."dw_DemandDLF"
               OR fct."stg_DLP"            != fct."dw_DLP"
               OR fct."stg_DLPSum"         != fct."dw_DLPSum"
               OR fct."stg_DLPRation"      != fct."dw_DLPRation"
               OR fct."stg_DLF"            != fct."dw_DLF"
            );

  -- CANCEL UNEXISTANTS FACTS
  UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;

   INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MontlhyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
   SELECT
           now()::timestamp,
	   now()::timestamp,
           "dw_MontlhyRead",
           "dw_Usage",
           "dw_UsageDLF",
           "dw_Demand",
           "dw_DemandDLF",
           "dw_DLP",
           "dw_DLPSum",
           "dw_DLPRation",
           "dw_DLF",
           "dw_StartDateTimeUTC",
           "dw_EndDateTimeUTC",
           "dw_StartDateTimeLocal",
           "dw_EndDateTimeLocal",
           "dw_AccountKey",
           "dw_SDPKey",
           "dw_MeterKey",
           "dw_ChannelKey",
           "dw_OriginConsumptionKey",
           3,
           "dw_ServiceTypeKey",
           "dw_ParentIntervalKey",
           2,
           "dw_EndDateLocalKey",
           "dw_EndTimeLocalKey",
           "dw_EndDateUTCKey",
           "dw_EndTimeUTCKey",
           "dw_RecordedDateUTCKey"
   FROM public.facts_temp_sett fct
   WHERE    fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;




  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('023_DW_MergeDailyFacts_SETT_Create_Scripts');
-- FactIntervals
CREATE TABLE dw."FactIntervals_OMDA"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"IntervalTimeId" BIGINT,
    "Usage" NUMERIC(28,4) ,		
    "Demand" NUMERIC(28,4) ,    	   
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
	"Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
    "MarginalUsage" NUMERIC(28,4),
    "MarginalCost" NUMERIC(28,4),
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
    "AccountKey" INT,
    "SDPKey" INT ,
    "MeterKey" INT,
    "ChannelKey" INT,
    "CurrencyKey" SMALLINT,
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
	"ServiceTypeKey" SMALLINT,
	"ParentIntervalKey" BIGINT,
	"FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT
)PARTITION BY RANGE ("EndDateLocalKey");
COMMENT ON TABLE dw."FactIntervals_OMDA" IS 'Intervals Fact Table';

--2015
CREATE TABLE dw.intervals_omda_y2015m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_omda_y2015m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2015m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_omda_y2015m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2015m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_omda_y2015m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2015m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_omda_y2015m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2015m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_omda_y2015m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2015m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_omda_y2015m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2015m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_omda_y2015m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("SDPKey", "MeterKey", "AccountKey");





--2016
CREATE TABLE dw.intervals_omda_y2016m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_omda_y2016m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2016m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_omda_y2016m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2016m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_omda_y2016m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2016m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_omda_y2016m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2016m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_omda_y2016m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2016m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_omda_y2016m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2016m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_omda_y2016m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2016m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_omda_y2016m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2016m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_omda_y2016m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2016m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_omda_y2016m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2016m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_omda_y2016m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2016m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_omda_y2016m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("SDPKey", "MeterKey", "AccountKey");





--2017
CREATE TABLE dw.intervals_omda_y2017m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_omda_y2017m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2017m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_omda_y2017m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_omda_y2017m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2017m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_omda_y2017m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2017m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_omda_y2017m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2017m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_omda_y2017m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_omda_y2017m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_omda_y2017m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_omda_y2017m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_omda_y2017m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_omda_y2017m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2017m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_omda_y2017m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("SDPKey", "MeterKey", "AccountKey");






--2018
CREATE TABLE dw.intervals_omda_y2018m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_omda_y2018m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_omda_y2018m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2018m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_omda_y2018m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_omda_y2018m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_omda_y2018m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_omda_y2018m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_omda_y2018m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("SDPKey", "MeterKey", "AccountKey");






CREATE TABLE dw.intervals_omda_y2018m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_omda_y2018m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_omda_y2018m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_omda_y2018m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2018m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_omda_y2018m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("SDPKey", "MeterKey", "AccountKey");




CREATE TABLE dw.intervals_omda_y2018m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_omda_y2018m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("SDPKey", "MeterKey", "AccountKey");




--2019
CREATE TABLE dw.intervals_omda_y2019m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_omda_y2019m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_omda_y2019m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_omda_y2019m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_omda_y2019m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_omda_y2019m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_omda_y2019m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_omda_y2019m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_omda_y2019m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_omda_y2019m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_omda_y2019m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_omda_y2019m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("SDPKey", "MeterKey", "AccountKey");





CREATE TABLE dw.intervals_omda_y2019m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_omda_y2019m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("IntervalTimeId", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("SDPKey", "MeterKey", "AccountKey");






INSERT INTO public."DatabaseVersionHistory" VALUES ('024_DW_FactIntervals_OMDA_Create_Scripts');DROP TABLE dw."FactWeather";

-- FactWeather
CREATE TABLE dw."FactWeather"
(
    "WeatherKey" BIGSERIAL,
    "InsertionDateTime" TIMESTAMP,
    "AgingDateTime" TIMESTAMP,	
	"WeatherObservationId" BIGINT,
    "StationKey" INT,
	"FactValueGoalKey" SMALLINT,	
	"FactStatusKey" SMALLINT,
	"ParentWeatherKey" BIGINT,	
	"EndDateTimeUTC" TIMESTAMP ,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT,
    "oC" INT,
    "oF" INT,
    "Humidity" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactWeather" IS 'Weather Fact Table';


--2015
CREATE TABLE dw.weather_y2015m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.weather_y2015m06 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2015m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.weather_y2015m07 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2015m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.weather_y2015m08 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2015m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.weather_y2015m09 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2015m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.weather_y2015m10 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2015m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.weather_y2015m11 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");







CREATE TABLE dw.weather_y2015m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.weather_y2015m12 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2015m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");






--2016
CREATE TABLE dw.weather_y2016m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.weather_y2016m01 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.weather_y2016m02 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2016m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.weather_y2016m03 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.weather_y2016m04 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.weather_y2016m05 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.weather_y2016m06 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.weather_y2016m07 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.weather_y2016m08 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.weather_y2016m09 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2016m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.weather_y2016m10 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");






CREATE TABLE dw.weather_y2016m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.weather_y2016m11 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");






CREATE TABLE dw.weather_y2016m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.weather_y2016m12 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2016m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





--2017
CREATE TABLE dw.weather_y2017m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.weather_y2017m01 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");






CREATE TABLE dw.weather_y2017m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.weather_y2017m02 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.weather_y2017m03 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.weather_y2017m04 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.weather_y2017m05 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.weather_y2017m06 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.weather_y2017m07 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.weather_y2017m08 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.weather_y2017m09 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.weather_y2017m10 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.weather_y2017m11 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2017m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.weather_y2017m12 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2017m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





--2018
CREATE TABLE dw.weather_y2018m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.weather_y2018m01 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2018m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.weather_y2018m02 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");



CREATE TABLE dw.weather_y2018m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.weather_y2018m03 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2018m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.weather_y2018m04 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.weather_y2018m05 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.weather_y2018m06 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.weather_y2018m07 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.weather_y2018m08 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.weather_y2018m09 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.weather_y2018m10 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.weather_y2018m11 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2018m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.weather_y2018m12 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2018m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





--2019
CREATE TABLE dw.weather_y2019m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.weather_y2019m01 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2019m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.weather_y2019m02 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.weather_y2019m03 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.weather_y2019m04 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.weather_y2019m05 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.weather_y2019m06 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.weather_y2019m07 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.weather_y2019m08 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");




CREATE TABLE dw.weather_y2019m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.weather_y2019m09 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.weather_y2019m10 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.weather_y2019m11 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");





CREATE TABLE dw.weather_y2019m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.weather_y2019m12 ("EndDateUTCKey", "EndTimeUTCKey", "EndDateTimeUTC");
CREATE INDEX ON dw.weather_y2019m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC");



INSERT INTO public."DatabaseVersionHistory" VALUES ('025_DW_FactWeather_Create_Scripts');DROP TABLE stg."FactIntervals_SETT";

-- FactIntervals
CREATE TABLE stg."FactIntervals"
(
    "Omda_IntervalTimeId" BIGINT,
	"MonthlyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,
	"UsageDLF" NUMERIC(28,4),
    "Demand" NUMERIC(28,4) ,
	"DemandDLF" NUMERIC(28,4) ,
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
    "DLP" NUMERIC(18,6),
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),
    "DLF" NUMERIC(18,7),
	"Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
    "MarginalUsage" NUMERIC(28,4),
    "MarginalCost" NUMERIC(28,4),
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
	"ClientId" INT,
    "AccountId" INT,
    "SDPId" INT ,
    "DeviceCode" character varying(50),
    "ChannelId" VARCHAR(100),
    "CurrencyCode" VARCHAR(3),
	"OriginConsumptionCode" VARCHAR(8),
	"ApplicationCode" varchar(4),
    "EndDateLocal" TIMESTAMP,
    "EndTimeLocal" VARCHAR(10),
    "EndDateUTC" TIMESTAMP,
    "EndTimeUTC" VARCHAR(10),
	"RecordedDateUTC" TIMESTAMP
);
COMMENT ON TABLE stg."FactIntervals" IS 'Intervals Staging Fact Table';
CREATE INDEX ON stg."FactIntervals" ("EndDateTimeUTC", "ApplicationCode");
CREATE INDEX ON stg."FactIntervals" ("Omda_IntervalTimeId","EndDateTimeUTC", "ApplicationCode");


-- FactWeather 
CREATE TABLE stg."FactWeather"
(
	"WeatherObservationId" BIGINT,
    "ObservationStationId" INT,	
	"EndDateTimeUTC" TIMESTAMP ,
    "EndDateUTC" TIMESTAMP,
    "EndTimeUTC" VARCHAR(10),
	"RecordedDateUTC" TIMESTAMP,
    "oC" INT,
    "oF" INT,
    "Humidity" INT
);
COMMENT ON TABLE stg."FactWeather" IS 'Weather Fact Table';
CREATE INDEX ON  stg."FactWeather" ("EndDateTimeUTC");
CREATE INDEX ON  stg."FactWeather" ("WeatherObservationId","ObservationStationId","EndDateTimeUTC");



-- Meter
DROP TABLE stg."Meter";
CREATE TABLE stg."Meter"
(
    "MeterId" integer,
    "MeterTypeId" integer,
    "Name" character varying(50) ,
    "DeviceCode" character varying(50) ,
    "IntervalsPerHour" integer,
    "IsDSTEnabled" boolean,
    "TimeZoneId" integer,
    "IsVirtual" boolean,
    "DSTRegionId" integer,
    "FirstEndDateTimeUTC" timestamp,
    "LastEndDateTimeUTC" timestamp,
    "Manufacturer" character varying(50) ,
    "Type" character varying(50) ,
    "ApplicationCode" character varying(4),
	"MeterSDP" character varying(100),
	"MeterSDPStartDateTime" timestamp,
	"MeterSDPStopDateTime" timestamp,
    "StartDateTime" timestamp without time zone
);
COMMENT ON TABLE stg."Meter" IS 'Staging Meter';


DROP TABLE dw."DimMeter";
CREATE TABLE dw."DimMeter"
(
    "MeterKey" SERIAL PRIMARY KEY NOT NULL,
    "MeterAlternateKey" VARCHAR(50) NOT NULL,
    "ApplicationCode" varchar(4) NOT NULL,
    "Name" VARCHAR(50) NOT NULL,
    "IntervalsPerHour" SMALLINT NOT NULL,
    "IsDSTEnabled" boolean NOT NULL,
    "IsVirtual" boolean NOT NULL,
    "MeterType" VARCHAR(50) NULL,
    "Manufacturer" VARCHAR(50) NULL,
	"FirstEndDateTimeUTC" TIMESTAMP,
    "LastEndDateTimeUTC" TIMESTAMP,
	"MeterSDP" character varying(100) NULL,
	"MeterSDPStartDateTime" timestamp NULL,
	"MeterSDPStopDateTime" timestamp NULL,
    "TimeZoneKey" SMALLINT NULL,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL
);
COMMENT ON TABLE dw."DimMeter" IS 'Meter, MeterType and MeterManufacturer Dimension';
CREATE INDEX DimMeter_MeterAlternateKey_AppCode_Name_Current_index ON dw."DimMeter" ("MeterAlternateKey","ApplicationCode","Name","Current");
ALTER TABLE dw."DimMeter" ADD CONSTRAINT FK_Meter_TimeZone FOREIGN KEY ("TimeZoneKey") REFERENCES dw."DimTimeZone" ("TimeZoneKey");





-- TEMPORARY TABLE USED DURING  MERGE OPERATION
DROP TABLE public.meter_temp ;
CREATE TABLE public.meter_temp
(
    "MeterId" integer,
    "MeterTypeId" integer,
    "Name" character varying(50) COLLATE pg_catalog."default",
    "DeviceCode" character varying(50) COLLATE pg_catalog."default",
    "IntervalsPerHour" integer,
    "IsDSTEnabled" boolean,
    "TimeZoneId" integer,
    "InsertionTimeZoneKey" smallint,
    "IsVirtual" boolean,
    "DSTRegionId" integer,
    "FirstEndDateTimeUTC" timestamp,
    "LastEndDateTimeUTC" timestamp,
    "Manufacturer" character varying(50) COLLATE pg_catalog."default",
    "Type" character varying(50) COLLATE pg_catalog."default",
    "ApplicationCode" character varying(4) COLLATE pg_catalog."default",
	"MeterSDP" character varying(100) NULL,
	"MeterSDPStartDateTime" timestamp NULL,
	"MeterSDPStopDateTime" timestamp NULL,
    "StartDateTime" timestamp without time zone,
    "MeterKey" integer,
    "Current" boolean,
    "TimeZoneKey" smallint
);




DROP TABLE public.facts_temp_sett;

CREATE TABLE public.facts_temp_sett
(
    "dw_IntervalKey" bigint,
    "dw_InsertionDateTime" timestamp without time zone,
    "dw_MonthlyRead" numeric(28,4),
    "dw_Usage" numeric(28,4),
    "dw_UsageDLF" numeric(28,4),
    "dw_Demand" numeric(28,4),
    "dw_DemandDLF" numeric(28,4),
    "dw_DLP" numeric(18,6),
    "dw_DLPSum" numeric(18,6),
    "dw_DLPRation" numeric(18,6),
    "dw_DLF" numeric(18,7),
    "dw_StartDateTimeUTC" timestamp without time zone,
    "dw_EndDateTimeUTC" timestamp without time zone,
    "dw_StartDateTimeLocal" timestamp without time zone,
    "dw_EndDateTimeLocal" timestamp without time zone,
    "dw_AccountKey" integer,
    "dw_SDPKey" integer,
    "dw_MeterKey" integer,
    "dw_ChannelKey" integer,
    "dw_OriginConsumptionKey" smallint,
    "dw_FactValueGoalKey" smallint,
    "dw_ServiceTypeKey" smallint,
    "dw_ParentIntervalKey" bigint,
    "dw_FactStatusKey" smallint,
    "dw_EndDateLocalKey" integer,
    "dw_EndTimeLocalKey" smallint,
    "dw_EndDateUTCKey" integer,
    "dw_EndTimeUTCKey" smallint,
    "dw_RecordedDateUTCKey" integer,
    "dw_ClientKey" integer,
    "stg_MonthlyRead" numeric(28,4),
    "stg_Usage" numeric(28,4),
    "stg_UsageDLF" numeric(28,4),
    "stg_Demand" numeric(28,4),
    "stg_DemandDLF" numeric(28,4),
    "stg_DLP" numeric(18,6),
    "stg_DLPSum" numeric(18,6),
    "stg_DLPRation" numeric(18,6),
    "stg_DLF" numeric(18,7),
    "stg_StartDateTimeUTC" timestamp without time zone,
    "stg_EndDateTimeUTC" timestamp without time zone,
    "stg_StartDateTimeLocal" timestamp without time zone,
    "stg_EndDateTimeLocal" timestamp without time zone,
    "stg_ClientKey" integer,
    "stg_AccountKey" integer,
    "stg_SDPKey" integer,
    "stg_MeterKey" integer,
    "stg_ChannelKey" integer,
    "stg_OriginConsumptionKey" smallint,
    "stg_OriginConsumptionCode" character varying(8) COLLATE pg_catalog."default",
    "stg_ServiceTypeKey" smallint,
    "stg_EndDateLocalKey" integer,
    "stg_EndDateUTCKey" integer,
    "stg_EndTimeLocalKey" smallint,
    "stg_EndTimeUTCKey" smallint,
    "stg_RecordedDateKey" integer
) ;
CREATE INDEX ON public.facts_temp_sett ("stg_EndDateUTCKey","dw_IntervalKey");




CREATE TABLE public.facts_temp_weather
(
   "dw_WeatherKey" BIGINT,
   "dw_InsertionDateTime" TIMESTAMP ,
   "dw_AgingDateTime" TIMESTAMP,
   "dw_WeatherObservationId" BIGINT,
   "dw_StationKey" INTEGER,
   "dw_FactValueGoalKey" SMALLINT,
   "dw_FactStatusKey" SMALLINT,
   "dw_ParentWeatherkey" BIGINT,
   "dw_EndDateTimeUTC" TIMESTAMP,
   "dw_EndDateUTCKey" INTEGER,
   "dw_EndTimeUTCKey" SMALLINT,
   "dw_RecorderdDateUTCKey" INTEGER,
   "dw_oC" INTEGER,
   "dw_oF" INTEGER,
   "dw_Humidity" INTEGER,
   "stg_WeatherObservationId" BIGINT,
   "stg_EndDateTimeUTC" TIMESTAMP,
   "stg_oC" INTEGER,
   "stg_oF" INTEGER,
   "stg_Humidity" INTEGER,
   "stg_StationKey" INTEGER,           
   "stg_EndDateUTCKey" INTEGER,         
   "stg_EndTimeUTCKey" SMALLINT,
   "stg_RecordedDateKey" INTEGER
) ;
CREATE INDEX ON public.facts_temp_weather ("stg_EndDateUTCKey","dw_WeatherKey");





INSERT INTO public."DatabaseVersionHistory" VALUES ('026_DW_StagingTables_Create_Scripts');ALTER TABLE dw."FactIntervals_SETT" 
RENAME COLUMN "MontlhyRead" TO "MonthlyRead";



DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals_SETT";

CREATE OR REPLACE FUNCTION public."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO public.facts_temp_sett
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM public.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

  -- CANCEL UNEXISTANTS FACTS
  UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;

   INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
   SELECT
           now()::timestamp,
	   now()::timestamp,
           "dw_MonthlyRead",
           "dw_Usage",
           "dw_UsageDLF",
           "dw_Demand",
           "dw_DemandDLF",
           "dw_DLP",
           "dw_DLPSum",
           "dw_DLPRation",
           "dw_DLF",
           "dw_StartDateTimeUTC",
           "dw_EndDateTimeUTC",
           "dw_StartDateTimeLocal",
           "dw_EndDateTimeLocal",
           "dw_AccountKey",
           "dw_SDPKey",
           "dw_MeterKey",
           "dw_ChannelKey",
           "dw_OriginConsumptionKey",
           3,
           "dw_ServiceTypeKey",
           "dw_ParentIntervalKey",
           2,
           "dw_EndDateLocalKey",
           "dw_EndTimeLocalKey",
           "dw_EndDateUTCKey",
           "dw_EndTimeUTCKey",
           "dw_RecordedDateUTCKey"
   FROM public.facts_temp_sett fct
   WHERE    fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;




  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('027_DW_MergeDailyFacts_SETT_Create_Scripts');CREATE SCHEMA IF NOT EXISTS etl ;

CREATE OR REPLACE FUNCTION etl."GetNextStreamId"()
RETURNS TABLE
(
  "_StreamId" BIGINT
)
LANGUAGE plpgsql
AS $$
BEGIN
	
	RETURN QUERY
	SELECT 
		"StreamId"
	FROM ct."LoadStream"
	WHERE  "ProcessStartDateTime" IS NULL AND "ProcessEndDateTime" IS NULL 
	ORDER  BY  "StreamId" DESC
	LIMIT 1;

END 
$$;



CREATE OR REPLACE FUNCTION etl."CreateNewStream" () 
RETURNS void AS $$
BEGIN
   
   INSERT INTO ct."LoadStream"("FromSyncDateUTC","ToSyncDateUTC","ProcessStartDateTime","ProcessEndDateTime","Status") 
   VALUES (date_trunc('day', now())::timestamp without time zone, date_trunc('day', now())::timestamp without time zone  ,NULL, NULL, NULL);

END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."GetStreamToProcess"()
RETURNS TABLE
(
  "StreamId" BIGINT,
  "FromSyncDateUTC" TIMESTAMP,
  "ToSyncDateUTC" TIMESTAMP
)
LANGUAGE plpgsql
AS $$
BEGIN	
	RETURN QUERY
	(
	  SELECT 
		ct."LoadStream"."StreamId",
        ct."LoadStream"."FromSyncDateUTC",
        ct."LoadStream"."ToSyncDateUTC"
	  FROM ct."LoadStream"
	  ORDER BY "StreamId" DESC
	  LIMIT 1
	);
END 
$$;

CREATE OR REPLACE FUNCTION etl."UpdateStreamStartProcess" ("streamId" integer) 
RETURNS void AS $$
BEGIN
   
   UPDATE 
   	 ct."LoadStream"
   SET "ProcessStartDateTime"= now()::timestamp
   WHERE "StreamId" = "streamId";

END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION etl."UpdateStreamFinalStatus" ("streamId" integer, "statusETL" text) 
RETURNS void AS $$
BEGIN   
    UPDATE ct."LoadStream"
	SET "ProcessEndDateTime"= now()::timestamp,
		"Status"= "statusETL"
	WHERE "StreamId" = "streamId" ;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."GetStagingTableListToTruncate"()
RETURNS TABLE
(
  "table_name" text
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
	SELECT T.table_name::text
	FROM  information_schema.tables T
	WHERE table_schema= 'stg'
	   AND table_type='BASE TABLE';
END 
$$;



CREATE OR REPLACE FUNCTION etl."InsertNewLoadCycle" ("_streamId" integer, "_envCode" text , "_sourceSchema" text , "_destSchema" text, "_loadType" text) 
RETURNS void AS $$
BEGIN
   
 INSERT INTO ct."LoadCycle"
 (
	 "EnvCode",
	 "SourceSchema",
	 "DestinationSchema",
	 "LoadType",
	 "StartingDateTime",
	 "EndDateTime",
	 "Status",
	 "StreamId"
 )
 VALUES ("_envCode","_sourceSchema", "_destSchema", "_loadType", now()::timestamp, NULL, NULL,"_streamId" );

END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."GetCurrentLoadCycleIdByStreamId"("currentStreamId" integer)
RETURNS TABLE
(
  "LoadCycleId" bigint
)
LANGUAGE plpgsql
AS $$
BEGIN
	
	RETURN QUERY
	(
		SELECT 
				L."LoadCycleId"
		FROM ct."LoadCycle" L
		WHERE "StreamId" = "currentStreamId"
		ORDER BY  "StartingDateTime" DESC
		LIMIT 1
	);

END 
$$;



CREATE OR REPLACE FUNCTION etl."UpdateLoadCycleStatus" ("_LoadCycleId" BIGINT, "_LoadCycleStatus" text) 
RETURNS void AS $$
BEGIN

	UPDATE ct."LoadCycle"
	SET 
	 "EndDateTime"= now()::timestamp,
	 "Status" = "_LoadCycleStatus"
	WHERE "LoadCycleId" = "_LoadCycleId" ;

END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION etl."GetDateData"()
RETURNS TABLE
(
	date_dim_id INTEGER,
	date_actual DATE,
	date_actual_Timestamp TIMESTAMP,
	day_of_week DOUBLE PRECISION,
	day_name TEXT,
	day_name1 TEXT,
	day_of_month DOUBLE PRECISION,
	day_of_year DOUBLE PRECISION,
	week_of_year DOUBLE PRECISION,
	month_name TEXT,
	month_name1 TEXT,
	month_actual DOUBLE PRECISION,
	quarter_actual DOUBLE PRECISION,
	year_actual DOUBLE PRECISION,
	semester INTEGER,
	style101 TEXT,
	style103 TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
		SELECT TO_CHAR(datum,'yyyymmdd')::INT AS date_dim_id,
		   datum AS date_actual,
		   TO_CHAR(datum,'yyyymmdd')::TIMESTAMP AS date_actual_Timestamp,
		   EXTRACT(isodow FROM datum) AS day_of_week,
		   TO_CHAR(datum,'Day') AS day_name,
		   TO_CHAR(datum,'Day') AS day_name,
		   EXTRACT(DAY FROM datum) AS day_of_month,
		   EXTRACT(doy FROM datum) AS day_of_year,
		   EXTRACT(week FROM datum) AS week_of_year,
		   TO_CHAR(datum,'Month') AS month_name,
		   TO_CHAR(datum,'Month') AS month_name,
		   EXTRACT(MONTH FROM datum) AS month_actual,
		   EXTRACT(quarter FROM datum) AS quarter_actual,
		   EXTRACT(isoyear FROM datum) AS year_actual,
		   CASE
			 WHEN EXTRACT(MONTH FROM datum) <= 6 THEN 1
			   ELSE 2
		   END AS semester,
		   TO_CHAR(datum,'mm/dd/yyyy') AS style101,
		   TO_CHAR(datum,'dd/mm/yyyy') AS style103
	FROM (SELECT '2015-01-01'::DATE+ SEQUENCE.DAY AS datum
		  FROM GENERATE_SERIES (0,3287) AS SEQUENCE (DAY)
		  GROUP BY SEQUENCE.DAY
		  order by datum) DQ
	ORDER BY 1
;
	
END 
$$;


CREATE OR REPLACE FUNCTION etl."GetTimeData"()
RETURNS TABLE
(
	time_value text,
	hour_12 text,
	hour_24 text ,
	am_pm text,
	day_minutes double precision,
	time05min double precision,
	time10min integer,
	time15min integer ,
    time30min integer ,
	time60min double precision,
	time_value1 text
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
	SELECT
        to_char(minute, 'hh24mi') AS time_value,
        to_char(minute, 'hh12') hour_12,
        to_char(minute, 'hh24') AS hour_24,
        case
            when to_char(minute, 'hh24:mi') BETWEEN '00:00' AND '11:59' then 'AM'
            else 'PM'
        end AS am_pm,
        extract(minute FROM minute) day_minutes,
        case
            when extract(minute FROM minute) in(0) then 11
            else (extract(minute FROM minute) / 5) -1
        end AS time05Min,
        case
            when extract(minute FROM minute) in(5,10) then 0
            when extract(minute FROM minute) in(15,20) then 1
            when extract(minute FROM minute) in(25,30) then 2
            when extract(minute FROM minute) in(35,40) then 3
            when extract(minute FROM minute) in(45,50) then 4
            else 5
        end AS time10Min,
        case
            when extract(minute FROM minute) in(5,10,15) then 0
            when extract(minute FROM minute) in(20,25,30) then 1
            when extract(minute FROM minute) in(35,40,45) then 2
            else 3
        end AS time15Min,
        case
            when extract(minute FROM minute) in(5,10,15,20,25,30) then 0
            else 1
        end AS time30Min,
        case
            when extract(minute FROM minute) in(0) and to_char(minute, 'hh12') in ('12')  then 23
            when extract(minute FROM minute) in(0) then extract(HOUR FROM minute) - 1
            else extract(HOUR FROM minute)
        end AS time60Min,
        to_char(minute, 'hh24:mi') AS time_value
	FROM
	  (
			SELECT '0:00'::time + 5*(sequence.minute || ' minutes')::interval AS minute
			FROM generate_series(0,287) AS sequence(minute)
	  ) DQ;	

	
END 
$$;





CREATE OR REPLACE FUNCTION etl."GetServiceTypeData"()
RETURNS TABLE
(
  serviceTypeId INTEGER,
  code TEXT,
  description TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
	SELECT 
		1 as serviceTypeId,
		'OMDA' as code,
		'Olameter Meter Data Analyser' as description

	UNION 

	 SELECT 
		2 as serviceTypeId,
		'SETT' as code,
		'Settlement' as description
				
				;

END 
$$;



CREATE OR REPLACE FUNCTION etl."GetOriginFactData"()
RETURNS TABLE
(
  orignFactId INTEGER,
  code TEXT,
  englishDescription TEXT,
  spanishDescription TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
	SELECT 
		1 as orignFactId,
		'CALC' as code,
		'Calculated' as englishDescription,
		'Calculado' as spanishDescription

	UNION 

	 SELECT 
		2 as orignFactId,
		'ESTI' as code,
		'Estimated' as englishDescription,
		'Estimado' as spanishDescription

	UNION 

	SELECT 
		3 as orignFactId,
		'REAL' as code,
		'Real' as englishDescription,
		'Real' as spanishDescription

    ;
END 
$$;



CREATE OR REPLACE FUNCTION etl."GetFactValueGoalData"()
RETURNS TABLE
(
  factValueGoalId INTEGER,
  code TEXT,
  englishDescription TEXT,
  spanishDescription TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
	SELECT 
		1 as factValueGoalId,
		'INIT' as code,
		'Initial' as englishDescription,
		'Inicial' as spanishDescription

	UNION 

	 SELECT 
		2 as factValueGoalId,
		'NEW' as code,
		'New' as englishDescription,
		'Nuevo' as spanishDescription

	UNION 

	 SELECT 
		3 as factValueGoalId,
		'CANCEL' as code,
		'Cancelled' as englishDescription,
		'Cancelado' as spanishDescription

	UNION

	 SELECT 
		4 as factValueGoalId,
		'CORR' as code,
		'Correction' as englishDescription,
		'Correccion' as spanishDescription

    ;
END 
$$;



CREATE OR REPLACE FUNCTION etl."GetFactStatusData"()
RETURNS TABLE
(
  factStatusKey INTEGER,
  code TEXT,
  englishDescription TEXT,
  spanishDescription TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY 
	
	SELECT 
		1 as FactStatusKey,
		'CURRENT' as code,
		'Current value' as EnglishFactStatusDescription,
		'Valor actual' as SpanishFactStatusDescription

	UNION 

	SELECT 
		2 as FactStatusKey,
		'OLD' as code,
		'Old value' as EnglishFactStatusDescription,
		'Valor antiguo' as SpanishFactStatusDescription

    ;
END 
$$;



CREATE OR REPLACE FUNCTION etl."MergeLocationData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimLocation"("LocationAlternateKey", "City", "StateProvinceAbbr", "StateProvinceName", "CountryAbbr", "EnglishCountryName", "SpanishCountryName")
	SELECT "CityId", "CityName", "StateAbbreviation", "StateName", "CountryAbbreviation", "CountryName","CountryName"
	FROM stg."Location"
	ON CONFLICT ("LocationAlternateKey") 
	DO UPDATE SET  
	"City"               =  EXCLUDED."City",
	"StateProvinceAbbr"  =  EXCLUDED."StateProvinceAbbr",
	"StateProvinceName"  =  EXCLUDED."StateProvinceName",
	"CountryAbbr"        =  EXCLUDED."CountryAbbr",
	"EnglishCountryName" =  EXCLUDED."EnglishCountryName",
	"SpanishCountryName" =  EXCLUDED."EnglishCountryName";

END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION etl."MergeStationData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimWeatherStation"("StationAlternateKey", "Name")
	SELECT "ObservationStationId", "Name"
	FROM stg."ObservationStation"
	ON CONFLICT ("StationAlternateKey") 
	DO UPDATE SET  
	"Name" =  EXCLUDED."Name" ;

END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION etl."MergeTimezoneData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimTimeZone"("TimeZoneAlternateKey", "Abbreviation", "EnglishName", "SpanishName", "OffsetToGMT")
	SELECT "TimeZoneId","Abbreviation", "Name", "Name","OffsetToGMT"
	FROM stg."TimeZone"
	ON CONFLICT ("TimeZoneAlternateKey") 
	DO UPDATE SET  
	"Abbreviation"       =  EXCLUDED."Abbreviation",
	"EnglishName"  		 =  EXCLUDED."EnglishName",
	"SpanishName"  		 =  EXCLUDED."EnglishName",
	"OffsetToGMT"        =  EXCLUDED."OffsetToGMT" ;

END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION etl."MergeISOData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimISO"("ISOAlternateKey", "ISOName", "ISOEnglishDescription", "ISOSpanishDescription", "ISODefaultFormat")	
	SELECT "IndSysOperatorId", "Name", "Description","Description", 'N/A'
	FROM stg."IndSysOperator"   
	ON CONFLICT ("ISOAlternateKey") 
	DO UPDATE SET  
	"ISOName"                =  EXCLUDED."ISOName",
	"ISOEnglishDescription"  =  EXCLUDED."ISOEnglishDescription",
	"ISOSpanishDescription"  =  EXCLUDED."ISOEnglishDescription",
	"ISODefaultFormat"      =  'N/A' ;

END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION etl."MergePowerTypeData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimEnergyPowerType"("EnergyPowerTypeAlternateKey", "EnglishEnergyPowerTypeDescription", "SpanishPowerTypeDescription")
	SELECT "EnergyPowerTypeId", "Description", "Description"
	FROM stg."EnergyPowerType"
	ON CONFLICT ("EnergyPowerTypeAlternateKey") 
	DO UPDATE SET  
	"EnglishEnergyPowerTypeDescription"     =  EXCLUDED."EnglishEnergyPowerTypeDescription",
	"SpanishPowerTypeDescription"           =  EXCLUDED."EnglishEnergyPowerTypeDescription" ;

END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION etl."MergeSDPData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimSDP"("SDPAlternateKey", "Address", "Address1", "PostalCode", "Longitude", "Latitude", "Name", "IsVirtual", "LoadReductionPriceCode", "CustomerBaseLineAdjLoadReduction", "CustomerBaseLineAdjType", "LocationKey", "StationKey", "StartDateTime", "EndDateTime", "Current")
	SELECT "SDPId", "Address", "Address1", "PostalCode", "Longitude", "Latitude", S."Name",  "IsVirtual", "LoadReductionPriceCode", "CustomerBaseLineAdjustmentLoadReduction", "CustomerBaseLineAdjustmentType",  "LocationKey",  "StationKey", "StartDateTime", NULL, True 
	FROM stg."SDP" S
	LEFT JOIN dw."DimLocation" L 
	ON S."CityId" = L."LocationAlternateKey"
	LEFT JOIN  dw."DimWeatherStation" W
	ON W."StationAlternateKey" = S."ObservationStationId"
	ON CONFLICT ("SDPAlternateKey") 
	DO UPDATE SET  
	"Address"                				=  EXCLUDED."Address",
	"Address1"               			=  EXCLUDED."Address1",
	"PostalCode"             			=  EXCLUDED."PostalCode",
	"Longitude"              				=  EXCLUDED."Longitude",
	"Latitude"               				=  EXCLUDED."Latitude",
	"Name"                   				=  EXCLUDED."Name",
	"IsVirtual"              				    =  EXCLUDED."IsVirtual",
	"LoadReductionPriceCode" 				=  EXCLUDED."LoadReductionPriceCode",
	"CustomerBaseLineAdjLoadReduction" 	=  EXCLUDED."CustomerBaseLineAdjLoadReduction",
	"CustomerBaseLineAdjType" 			=  EXCLUDED."CustomerBaseLineAdjType",
	"LocationKey"             			=  EXCLUDED."LocationKey",
	"StationKey"              			=  EXCLUDED."StationKey" ;

END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION etl."MergeClientData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimClient"("ClientAlternateKey", "ClientName", "LogoFileName", "LogoFileBinaryContent", "ClientUrl", "MonthsToRetain","Duns" , "StartDateTime", "EndDateTime", "Current")
	SELECT  "ClientId", "Name","LogoFileName",NULL , "ClientUrl", "MonthsToRetain", "Duns" ,"StartDateTime", NULL, True
	FROM stg."Client"
	ON CONFLICT ("ClientAlternateKey") 
	DO UPDATE SET  
	"ClientName"        =  EXCLUDED."ClientName",
	"LogoFileName"      =  EXCLUDED."LogoFileName",
	"ClientUrl"         =  EXCLUDED."ClientUrl",
	"MonthsToRetain"    =  EXCLUDED."MonthsToRetain",
	"Duns"    =  EXCLUDED."Duns";

END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."MergeCustomerData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimCustomer"("CustomerAlternateKey", "ApplicationCode", "Name", "StartDateTime", "EndDateTime", "Current")
	SELECT 
		CASE 
			WHEN "ApplicationCode" = 'OMDA' THEN "CustomerId"::text 
			WHEN "ApplicationCode" = 'SETT' THEN "Name"
		END AS "CustomerAlternateKey",
		"ApplicationCode",
		"Name",
		"StartDateTime",
		NULL as "EndDateTime" ,
		TRUE as "Current"
	FROM stg."Customer"
	ON CONFLICT ("CustomerAlternateKey","ApplicationCode") 
	DO UPDATE SET  
	"Name"  =  EXCLUDED."Name" ;

END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."MergeControlAreaData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimControlArea"("ControlAreaAlternateKey", "Name", "Abbreviation", "Duns", "ISOKey")
	SELECT "ControlAreaId", "Name", "Abbreviation", "Duns", "ISOKey"
	FROM stg."ControlArea" C
	LEFT JOIN dw."DimISO" I
	ON I."ISOAlternateKey" = C."IndSysOperatorId"

	ON CONFLICT ("ControlAreaAlternateKey") 
	DO UPDATE SET  
	"Name"          =  EXCLUDED."Name",
	"Abbreviation"  =  EXCLUDED."Abbreviation",
	"Duns"          =  EXCLUDED."Duns",
	"ISOKey"        =  EXCLUDED."ISOKey";

END;
$$ LANGUAGE plpgsql;






CREATE OR REPLACE FUNCTION etl."MergeUomData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimUOM"("UomAlternateKey", "EnglishDescription", "SpanishDescription", "Code", "UomFromMV90", "ConversionKey", "EnglishUomTypeDescription", "SpanishUomTypeDescription", "EnergyPowerTypeKey","EDI867Code")
	SELECT "UnitOfMeasureId", "Description","Description","Code", "UomFromMV90","UnitOfMeasureConversionId","UomTypeDescription","UomTypeDescription", "EnergyPowerTypeKey","EDI867Code"
	FROM stg."UnitOfMeasure" U
	LEFT JOIN dw."DimEnergyPowerType" E
	ON E."EnergyPowerTypeAlternateKey" = U."EnergyPowerTypeId"

	ON CONFLICT ("UomAlternateKey") 
	DO UPDATE SET  
	"EnglishDescription"               =  EXCLUDED."EnglishDescription",
	"SpanishDescription"               =  EXCLUDED."EnglishDescription",
	"Code"                             =  EXCLUDED."Code",
	"UomFromMV90"                      =  EXCLUDED."UomFromMV90",
	"ConversionKey"                    =  EXCLUDED."ConversionKey",
	"EnglishUomTypeDescription"        =  EXCLUDED."EnglishUomTypeDescription",
	"SpanishUomTypeDescription"        =  EXCLUDED."EnglishUomTypeDescription",
	"EnergyPowerTypeKey"               =  EXCLUDED."EnergyPowerTypeKey",
	"EDI867Code"                                   =  EXCLUDED."EDI867Code" ;
	
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."MergeChannelData" () 
RETURNS void AS $$
BEGIN

	-- INSERT NEW CHANNELS
	INSERT INTO dw."DimChannel"("ChannelAlternateKey","ApplicationCode", "ChannelNumber", "SetNumber", "NumberOfDials", "MeterMultiplier", "PulseMultiplier", "PulseOffset", "BillingMultiplier", "EnglishChannelTypeDescription", "SpanishChannelTypeDescription", "IntervalsPerHour", "IsDelivered", "IsVirtual", "UomKey", "PowerFctConfigKey", "StartDateTime", "EndDateTime", "Current")
	SELECT 
			"ChannelId",
			C."ApplicationCode",
			C."ChannelNumber",
			C."SetNumber",
			C."NumberOfDials",
			C."MeterMultiplier",
			C."PulseMultiplier",
			C."PulseOffset",
			C."BillingMultiplier",
			C."ChannelTypeDescription",
			C."ChannelTypeDescription",
			C."IntervalsPerHour",
			C."IsDelivered",
			C."IsVirtual",
			M."UomKey",
			NULL,
			C."StartDateTime",
			NULL,
			True

	FROM stg."Channel" C
	LEFT JOIN dw."DimUOM" M 
	ON M."UomAlternateKey" = C."UnitOfMeasureId"
	LEFT JOIN dw."DimChannel" dimChan
	ON dimChan."ChannelAlternateKey" = C."ChannelId"  AND dimChan."ApplicationCode" = C."ApplicationCode" AND dimChan."Current" = True
	WHERE dimChan."ChannelKey" IS NULL ;

	-- UPDATE EXISTING CHANNELS
	UPDATE dw."DimChannel"
	SET 
		"ChannelNumber"        		   =  C."ChannelNumber",
		"SetNumber"             		   =  C."SetNumber",
		"NumberOfDials"         		   =  C."NumberOfDials",
		"MeterMultiplier"    			   =  C."MeterMultiplier",
		"PulseMultiplier"      		   =  C."PulseMultiplier",
		"PulseOffset"      			   =  C."PulseOffset",
		"BillingMultiplier"        	   =  C."BillingMultiplier",
		"EnglishChannelTypeDescription"  =  C."ChannelTypeDescription",
		"SpanishChannelTypeDescription"  =  C."ChannelTypeDescription",
		"IntervalsPerHour"      		   =  C."IntervalsPerHour",
		"IsDelivered"				       =  C."IsDelivered",
		"IsVirtual"    				   =  C."IsVirtual",
		"UomKey"         				   =  M."UomKey"

	FROM stg."Channel" C
	LEFT JOIN dw."DimUOM" M 
	ON M."UomAlternateKey" = C."UnitOfMeasureId"
	WHERE 		dw."DimChannel"."ChannelAlternateKey" = C."ChannelId"  
			AND dw."DimChannel"."ApplicationCode" = C."ApplicationCode"
			AND dw."DimChannel"."Current" = True 
			;
	
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."MergeUomConversionData" () 
RETURNS void AS $$
BEGIN

	INSERT INTO dw."DimUOM"("UomAlternateKey", "EnglishDescription", "SpanishDescription", "Code", "UomFromMV90", "ConversionKey", "EnglishUomTypeDescription", "SpanishUomTypeDescription", "EnergyPowerTypeKey","EDI867Code")
	SELECT  U."UnitOfMeasureId", U."Description",U."Description",U."Code", U."UomFromMV90",U2."UomKey",U."UomTypeDescription",U."UomTypeDescription", E."EnergyPowerTypeKey",U."EDI867Code"
	FROM stg."UnitOfMeasure" U
	LEFT JOIN dw."DimEnergyPowerType" E
	ON E."EnergyPowerTypeAlternateKey" = U."EnergyPowerTypeId"
	LEFT JOIN dw."DimUOM" U2 
	ON U2."UomAlternateKey" = U."UnitOfMeasureConversionId"

	ON CONFLICT ("UomAlternateKey") 
	DO UPDATE SET  
	"EnglishDescription"               =  EXCLUDED."EnglishDescription",
	"SpanishDescription"               =  EXCLUDED."EnglishDescription",
	"Code"                             =  EXCLUDED."Code",
	"UomFromMV90"                      =  EXCLUDED."UomFromMV90",
	"ConversionKey"                    =  EXCLUDED."ConversionKey",
	"EnglishUomTypeDescription"        =  EXCLUDED."EnglishUomTypeDescription",
	"SpanishUomTypeDescription"        =  EXCLUDED."EnglishUomTypeDescription",
	"EnergyPowerTypeKey"               =  EXCLUDED."EnergyPowerTypeKey",
	"EDI867Code"                                   =  EXCLUDED."EDI867Code";
	
END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION etl."MergeMeterData" () 
RETURNS void AS $$
BEGIN


	INSERT INTO METER_TEMP  
	SELECT 
				"MeterId",
				"MeterTypeId",
				MS."Name",
				"DeviceCode",
				MS."IntervalsPerHour",
				MS."IsDSTEnabled",
				MS."TimeZoneId",
				TZ."TimeZoneKey" as "InsertionTimeZoneKey",
				MS."IsVirtual",
				"DSTRegionId",
				MS."FirstEndDateTimeUTC",
				MS."LastEndDateTimeUTC",
				MS."Manufacturer",
				"Type",
				MS."ApplicationCode",
				MS."MeterSDP",
				MS."MeterSDPStartDateTime",
				MS."MeterSDPStopDateTime",								
				MS."StartDateTime",
				MD."MeterKey",
				MD."Current",
				MD."TimeZoneKey"
	FROM  stg."Meter" MS
	LEFT JOIN dw."DimTimeZone" TZ
	ON TZ."TimeZoneAlternateKey" = MS."TimeZoneId"
	LEFT JOIN dw."DimMeter" MD
	ON MD."MeterAlternateKey" = MS."DeviceCode" AND  MD."ApplicationCode" = MS."ApplicationCode" AND MD."Current" = TRUE ;

	-- INSERT NEW ROWS
	INSERT INTO 
		 dw."DimMeter"(
		"MeterAlternateKey",
		"ApplicationCode",
		"Name",
		"IntervalsPerHour",
		"IsDSTEnabled",
		"IsVirtual",
		"MeterType",
		"Manufacturer",
		"FirstEndDateTimeUTC",
		"LastEndDateTimeUTC",
		"MeterSDP",
		"MeterSDPStartDateTime",
		"MeterSDPStopDateTime",	
		"TimeZoneKey",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
		"DeviceCode",
		"ApplicationCode",
		"Name",
		"IntervalsPerHour",
		"IsDSTEnabled",
		"IsVirtual",
		"Type",
		"Manufacturer",
		"FirstEndDateTimeUTC",
		"LastEndDateTimeUTC",
		"MeterSDP",
		"MeterSDPStartDateTime",
		"MeterSDPStopDateTime",	
		"InsertionTimeZoneKey",
		"StartDateTime",
		NULL,
		TRUE 
	FROM METER_TEMP
	WHERE "MeterKey" IS NULL ;

	-- UPDATE ROWS WITH NO HISTORICAL
	UPDATE dw."DimMeter" 
	SET 
		"Name" = METER_TEMP."Name",
		"IntervalsPerHour" = METER_TEMP."IntervalsPerHour",
		"IsDSTEnabled" = METER_TEMP."IsDSTEnabled",
		"IsVirtual" = METER_TEMP."IsVirtual",
		"MeterType" = METER_TEMP."Type",
		"Manufacturer" = METER_TEMP."Manufacturer",
		"FirstEndDateTimeUTC" = METER_TEMP."FirstEndDateTimeUTC",
		"LastEndDateTimeUTC" = METER_TEMP."LastEndDateTimeUTC",
		"MeterSDP" = METER_TEMP."MeterSDP",
		"MeterSDPStartDateTime" = METER_TEMP."MeterSDPStartDateTime",
		"MeterSDPStopDateTime" = METER_TEMP."MeterSDPStopDateTime"		
	FROM METER_TEMP 
	WHERE     METER_TEMP."MeterKey" IS NOT NULL 
	     AND  METER_TEMP."MeterKey" =  dw."DimMeter"."MeterKey"
		 AND  COALESCE(METER_TEMP."InsertionTimeZoneKey",0) = COALESCE(dw."DimMeter"."TimeZoneKey",0)
		 AND  COALESCE(METER_TEMP."MeterSDP",'-1') = COALESCE(dw."DimMeter"."MeterSDP",'-1')		 
		 AND  METER_TEMP."Current" = TRUE;


	-- UPDATE ROWS WITH HISTORICAL (ENDDATETIME UPDATE)
	UPDATE dw."DimMeter" 
	SET 
		"EndDateTime" = now()::timestamp,
		"Current" = FALSE                  
	FROM METER_TEMP 
	WHERE     METER_TEMP."MeterKey" IS NOT NULL 
		 AND  METER_TEMP."MeterKey" = dw."DimMeter"."MeterKey"
		 AND  (
			 	COALESCE(METER_TEMP."InsertionTimeZoneKey",0) != COALESCE(dw."DimMeter"."TimeZoneKey",0)
			    OR 
			    COALESCE(METER_TEMP."MeterSDP",'-1')          != COALESCE(dw."DimMeter"."MeterSDP",'-1')
			   )
		 AND  METER_TEMP."Current" = TRUE;

	-- INSERT HISTORICAL ROWS
	INSERT INTO 
		dw."DimMeter"(
		"MeterAlternateKey",
		"ApplicationCode",
		"Name",
		"IntervalsPerHour",
		"IsDSTEnabled",
		"IsVirtual",
		"MeterType",
		"Manufacturer",
		"FirstEndDateTimeUTC",
		"LastEndDateTimeUTC",
		"MeterSDP",
		"MeterSDPStartDateTime",
		"MeterSDPStopDateTime",	
		"TimeZoneKey",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
		MTemp."DeviceCode",
		MTemp."ApplicationCode",
		MTemp."Name",
		MTemp."IntervalsPerHour",
		MTemp."IsDSTEnabled",
		MTemp."IsVirtual",
		MTemp."Type",
		MTemp."Manufacturer",
		MTemp."FirstEndDateTimeUTC",
		MTemp."LastEndDateTimeUTC",
		MTemp."MeterSDP",
		MTemp."MeterSDPStartDateTime",
		MTemp."MeterSDPStopDateTime",	
		MTemp."InsertionTimeZoneKey",
		now()::timestamp as "StartDateTime",
		NULL,
		TRUE 
	FROM      METER_TEMP MTemp
	JOIN  dw."DimMeter" MSrc 
	ON MSrc."MeterKey" = MTemp."MeterKey"
	WHERE     MTemp."MeterKey" IS NOT NULL 
		  AND  (
			 	COALESCE(MTemp."InsertionTimeZoneKey",0) != COALESCE(MSrc."TimeZoneKey",0)
			    OR 
			    COALESCE(MTemp."MeterSDP",'-1')          != COALESCE(MSrc."MeterSDP",'-1')
			   )
		 AND  MTemp."Current" = TRUE;    

  
  	
END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION etl."MergeAccountData" () 
RETURNS void AS $$
BEGIN

INSERT INTO  ACCOUNT_TEMP  
	SELECT ACC_TEMP.*, Cust."CustomerKey" as "InsertionCustomerKey"
	FROM 
	(
			SELECT 
				"AccountId",
				"CustomerId",
				"CustomerName",
				CASE 
					WHEN  ASrc."ApplicationCode"= 'OMDA'  THEN "CustomerId"::text
					ELSE "CustomerName"
				END AS "CustomerAlternateId",
				"ClientId",
				CL."ClientKey" as "InsertionClientKey",
				ASrc."AccountNumber",
				ASrc."PremiseNumber",
				"ControlAreaId",
				CA."ControlAreaKey" as "InsertionControlAreaKey",
				"TimeZoneId",
				TZ."TimeZoneKey" as "InsertionTimeZoneKey",
				ASrc."ClientAccountKey",
				ASrc."ApplicationCode",
				ASrc."StartActiveDateTimeUTC",
				ASrc."EndActiveDateTimeUTC",
				ASrc."StartActiveDateTimeLocal",
				ASrc."EndActiveDateTimeLocal",
				ASrc."StartDateTime",
				ADes."AccountKey",
				ADes."ClientKey"      

		FROM stg."Account" ASrc
		LEFT JOIN dw."DimAccount" ADes
		ON ASrc."AccountId" = ADes."AccountAlternateKey"  AND ASrc."ApplicationCode" = ADes."ApplicationCode" AND ADes."Current" = TRUE
		LEFT JOIN dw."DimClient" CL
		ON CL."ClientAlternateKey" = ASrc."ClientId" AND CL."Current" =  TRUE
		LEFT JOIN dw."DimControlArea" CA
		ON CA."ControlAreaAlternateKey" = ASrc."ControlAreaId"
		LEFT JOIN dw."DimTimeZone" TZ
		ON TZ."TimeZoneAlternateKey" =  ASrc."TimeZoneId"
	) ACC_TEMP
	LEFT JOIN dw."DimCustomer" Cust
	ON  Cust."CustomerAlternateKey" = ACC_TEMP."CustomerAlternateId" AND Cust."Current" =  TRUE ;

	-- INSERT NEW ROWS
	INSERT INTO dw."DimAccount"(
		"AccountAlternateKey",
		"ApplicationCode",
		"AccountNumber",
		"PremiseNumber",
		"TimeZoneKey",
		"ClientAccountKey",
		"ClientKey",
		"CustomerKey",
		"ControlAreaKey",
		"StartActiveDateTimeUTC",
		"EndActiveDateTimeUTC",
		"StartActiveDateTimeLocal",
		"EndActiveDateTimeLocal",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
			"AccountId",
			"ApplicationCode",
			"AccountNumber",
			"PremiseNumber",
			"InsertionTimeZoneKey",
			"ClientAccountKey",
			"InsertionClientKey",
			"InsertionCustomerKey",
			"InsertionControlAreaKey",
			"StartActiveDateTimeUTC",
			"EndActiveDateTimeUTC",
			"StartActiveDateTimeLocal",
			"EndActiveDateTimeLocal",
			"StartDateTime",
			NULL,
			TRUE
	FROM ACCOUNT_TEMP
	WHERE "AccountKey" IS NULL ;

	-- UPDATE ROWS WITH NO HISTORICAL
	UPDATE dw."DimAccount"

		SET     	
			"ApplicationCode"= ACCOUNT_TEMP."ApplicationCode",
			"AccountNumber"= ACCOUNT_TEMP."AccountNumber",
			"PremiseNumber"= ACCOUNT_TEMP."PremiseNumber",
			"TimeZoneKey"= ACCOUNT_TEMP."InsertionTimeZoneKey",
			"ClientAccountKey"= ACCOUNT_TEMP."ClientAccountKey",
			"ClientKey"= ACCOUNT_TEMP."InsertionClientKey",
			"CustomerKey"= ACCOUNT_TEMP."InsertionCustomerKey",
			"ControlAreaKey"= ACCOUNT_TEMP."InsertionControlAreaKey",
			"StartActiveDateTimeUTC"= ACCOUNT_TEMP."StartActiveDateTimeUTC",
			"EndActiveDateTimeUTC"= ACCOUNT_TEMP."EndActiveDateTimeUTC",
			"StartActiveDateTimeLocal"= ACCOUNT_TEMP."StartActiveDateTimeLocal",
			"EndActiveDateTimeLocal"= ACCOUNT_TEMP."EndActiveDateTimeLocal"

	FROM     ACCOUNT_TEMP
	WHERE    ACCOUNT_TEMP."AccountKey" IS NOT NULL  
	      AND     ACCOUNT_TEMP."AccountKey"              = dw."DimAccount"."AccountKey"
		  AND    COALESCE(ACCOUNT_TEMP."InsertionClientKey",0)      = COALESCE(dw."DimAccount"."ClientKey",0)
		  AND    COALESCE(ACCOUNT_TEMP."InsertionCustomerKey",0)    = COALESCE(dw."DimAccount"."CustomerKey",0)
		  AND    COALESCE(ACCOUNT_TEMP."InsertionControlAreaKey",0) = COALESCE(dw."DimAccount"."ControlAreaKey",0) ;


	-- UPDATE ROWS WITH HISTORICAL (ENDDATETIME UPDATE)
	UPDATE dw."DimAccount"
	SET 
		"EndDateTime" = now()::timestamp,
		"Current" = FALSE                  
	FROM  ACCOUNT_TEMP 
	WHERE    ACCOUNT_TEMP."AccountKey" IS NOT NULL 
	      AND  ACCOUNT_TEMP."AccountKey" = dw."DimAccount"."AccountKey"
		  AND  (
			  	COALESCE (ACCOUNT_TEMP."InsertionClientKey",-1)      != COALESCE (dw."DimAccount"."ClientKey",-1) 
			    OR 
				COALESCE (ACCOUNT_TEMP."InsertionCustomerKey",-1)    != COALESCE (dw."DimAccount"."CustomerKey",-1)
			    OR
			    COALESCE (ACCOUNT_TEMP."InsertionControlAreaKey",-1) != COALESCE (dw."DimAccount"."ControlAreaKey",-1)
		       );

	-- INSERT HISTORICAL ROWS
	INSERT INTO dw."DimAccount"(
		"AccountAlternateKey",
		"ApplicationCode",
		"AccountNumber",
		"PremiseNumber",
		"TimeZoneKey",
		"ClientAccountKey",
		"ClientKey",
		"CustomerKey",
		"ControlAreaKey",
		"StartActiveDateTimeUTC",
		"EndActiveDateTimeUTC",
		"StartActiveDateTimeLocal",
		"EndActiveDateTimeLocal",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
			ATemp."AccountId",
			ATemp."ApplicationCode",
			ATemp."AccountNumber",
			ATemp."PremiseNumber",
			ATemp."InsertionTimeZoneKey",
			ATemp."ClientAccountKey",
			ATemp."InsertionClientKey",
			ATemp."InsertionCustomerKey",
			ATemp."InsertionControlAreaKey",
			ATemp."StartActiveDateTimeUTC",
			ATemp."EndActiveDateTimeUTC",
			ATemp."StartActiveDateTimeLocal",
			ATemp."EndActiveDateTimeLocal",
			now()::timestamp as "StartDateTime",
			NULL,
			TRUE
	FROM ACCOUNT_TEMP ATemp
	JOIN dw."DimAccount" ASrc 
	ON ASrc."AccountKey" = ATemp."AccountKey"
	WHERE         ATemp."AccountKey" IS NOT NULL  
			 AND  (
					COALESCE (ATemp."InsertionClientKey",-1)      != COALESCE (ASrc."ClientKey",-1) 
					OR 
					COALESCE (ATemp."InsertionCustomerKey",-1)    != COALESCE (ASrc."CustomerKey",-1)
				    OR
				    COALESCE (ATemp."InsertionControlAreaKey",-1) != COALESCE (ASrc."ControlAreaKey",-1)
				   );
	
END;
$$ LANGUAGE plpgsql;
































INSERT INTO public."DatabaseVersionHistory" VALUES ('028_DW_ETL_Create_Scripts');drop function dw."stpGetOMARNewData"(integer, timestamp, timestamp);

create or REPLACE function dw."stpGetOMARNewData"("ClientId" integer, "TradeDayUTC" timestamp without time zone, "TransactionDateTimeUTC" timestamp without time zone, "IsoId" integer)
  returns TABLE("CONTROLAREA" int, "CHANNEL" text, "DATE" text, "TIME" text, "VALUE" numeric, "UOM" text, "INTERVAL" text, "STATUS" text, "DSTFLAG" text)
language plpgsql
as $$
DECLARE
    "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("TradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("TradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTC"        TIMESTAMP := "TradeDayUTC" + interval '1' day;
BEGIN

   RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "TradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "ClientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "IsoId"
              AND
                (
                  ("TransactionDateTimeUTC" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("TransactionDateTimeUTC" IS NOT NULL AND (fct."InsertionDateTime" <= "TransactionDateTimeUTC" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "TransactionDateTimeUTC")))
                )
		),
    omar_CTE as
    (
        SELECT
             fct."ControlAreaAlternateKey",
             '1' AS "Channel",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             '1' AS "UOM",
             '60' AS "_INTERVAL",
             'A' as "STATUS",
             'N' AS "DSTFLAG"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM omar_CTE;
END
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('029_DW_Update_OMARNewData_Scripts');

DROP FUNCTION IF EXISTS public."stpMergeDailyFactWeather";

CREATE OR REPLACE FUNCTION public."stpMergeDailyFactWeather"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN



  WITH dw_facts_CTE as
  (
      SELECT
                 "WeatherKey"                    as "dw_WeatherKey",
                 "InsertionDateTime"             as "dw_InsertionDateTime" ,
                 "AgingDateTime"                 as "dw_AgingDateTime",
                 "WeatherObservationId"          as "dw_WeatherObservationId",
                 "StationKey"                    as "dw_StationKey",
                 "FactValueGoalKey"              as "dw_FactValueGoalKey",
                 fct."FactStatusKey"             as "dw_FactStatusKey",
                 "ParentWeatherKey"              as "dw_ParentWeatherkey",
                 "EndDateTimeUTC"                as "dw_EndDateTimeUTC",
                 "EndDateUTCKey"                 as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"                 as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey"            as "dw_RecorderdDateUTCKey",
	             "oC"                            as "dw_oC",
	             "oF"                            as "dw_oF",
	             "Humidity"                      as "dw_Humidity"
	  
      FROM dw."FactWeather" fct
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
	  
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "WeatherObservationId"           as "stg_WeatherObservationId",
            "EndDateTimeUTC"                 as "stg_EndDateTimeUTC",
            "oC"                             as "stg_oC",
            "oF"                             as "stg_oF",
	        "Humidity"                       as "stg_Humidity",
            "StationKey"                     as "stg_StationKey",           
            dateUTC."DateKey"                as "stg_EndDateUTCKey",         
            timeUTC."TimeKey"                as "stg_EndTimeUTCKey",
            recordedDate."DateKey"           as "stg_RecordedDateKey"

      FROM stg."FactWeather" fct      
      JOIN dw."DimWeatherStation" station
        ON station."StationAlternateKey" = fct."ObservationStationId"     
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"     
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" 
  )
  
  INSERT INTO public.facts_temp_weather
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON     dw_fact."dw_WeatherObservationId"       = stg_fact."stg_WeatherObservationId"          
        AND dw_fact."dw_StationKey"                 = stg_fact."stg_StationKey"
        AND dw_fact."dw_EndDateUTCKey"              = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"              = stg_fact."stg_EndTimeUTCKey"
    ;
	
    -- INSERT NEW FACTS
	INSERT INTO dw."FactWeather"(
		"InsertionDateTime",
		"AgingDateTime",
		"WeatherObservationId",
		"StationKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentWeatherKey",
		"EndDateTimeUTC",
		"EndDateUTCKey",
		"EndTimeUTCKey",
		"RecordedDateUTCKey",
		"oC",
		"oF",
		"Humidity"
	)		
    SELECT
           now()::timestamp,
           NULL,
           "stg_WeatherObservationId",
           "stg_StationKey",
           1, --INIT
           1, --CURRENT
           NULL, -- PARENT WEATHER KEY
           "stg_EndDateTimeUTC",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_oC",
           "stg_oF",
	       "stg_Humidity"
		   
    FROM public.facts_temp_weather fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_WeatherKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactWeather" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM public.facts_temp_weather fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."WeatherKey" = fct."dw_WeatherKey"
        AND fct."dw_WeatherKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_oC",-1)        != COALESCE (fct."dw_oC",-1)
               OR COALESCE (fct."stg_oF",-1)        != COALESCE (fct."dw_oF",-1)
               OR COALESCE (fct."stg_Humidity",-1)  != COALESCE (fct."dw_Humidity",-1)
            );

    -- INSERT NEW FACTS
	INSERT INTO dw."FactWeather"(
		"InsertionDateTime",
		"AgingDateTime",
		"WeatherObservationId",
		"StationKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentWeatherKey",
		"EndDateTimeUTC",
		"EndDateUTCKey",
		"EndTimeUTCKey",
		"RecordedDateUTCKey",
		"oC",
		"oF",
		"Humidity"
	)
        SELECT
           now()::timestamp,
           NULL,
           "stg_WeatherObservationId",
           "stg_StationKey",
           2, --INIT
           1, --CURRENT
           fct."dw_WeatherKey", -- PARENT WEATHER KEY
           "stg_EndDateTimeUTC",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_oC",
           "stg_oF",
	       "stg_Humidity"

    FROM public.facts_temp_weather fct
    WHERE   fct."dw_WeatherKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
         AND (
                  COALESCE (fct."stg_oC",-1)        != COALESCE (fct."dw_oC",-1)
               OR COALESCE (fct."stg_oF",-1)        != COALESCE (fct."dw_oF",-1)
               OR COALESCE (fct."stg_Humidity",-1)  != COALESCE (fct."dw_Humidity",-1)
            );

  

  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;



INSERT INTO public."DatabaseVersionHistory" VALUES ('030_DW_MergeDailyFactWeather_Create_Script');


create or REPLACE function dw."stpGetOMARNewData"("ClientId" integer, "TradeDayUTC" timestamp without time zone, "TransactionDateTimeUTC" timestamp without time zone, "IsoId" integer)
  returns TABLE("CONTROLAREA" int, "CHANNEL" text, "DATE" text, "TIME" text, "VALUE" numeric, "UOM" text, "INTERVAL" text, "STATUS" text, "DSTFLAG" text)
language plpgsql
as $$
DECLARE
    "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("TradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("TradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTC"        TIMESTAMP := "TradeDayUTC" + interval '1' day;
BEGIN

   RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "TradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "ClientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "IsoId"
              AND
                (
                  ("TransactionDateTimeUTC" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("TransactionDateTimeUTC" IS NOT NULL AND (fct."InsertionDateTime" <= "TransactionDateTimeUTC" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "TransactionDateTimeUTC")))
                )
		),
    omar_CTE as
    (
        SELECT
             fct."ControlAreaAlternateKey",
             '1' AS "Channel",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF"),0) AS "_UsageDLF",
             '1' AS "UOM",
             '60' AS "_INTERVAL",
             'A' as "STATUS",
             'N' AS "DSTFLAG"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM omar_CTE;
END
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('031_DW_Update_OMARNew_Script');

CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	)
    RETURNS TABLE("IntervalId" bigint, 
				  "InsertionDateTime" timestamp without time zone, 
				  "MonthlyRead" numeric, 
				  "Usage" numeric, 
				  "UsageDLF" numeric, 
				  "Demand" numeric, 
				  "DemandDLF" numeric, 
				  "DLP" numeric, 
				  "DLPSum" numeric, 
				  "DLPRation" numeric, 
				  "DLF" numeric, 
				  "StartDateTimeUTC" timestamp without time zone, 
				  "TradeDay" timestamp without time zone, 
				  "StartDateTimeLocal" timestamp without time zone, 
				  "EndDateTimeLocal" timestamp without time zone, 
				  "AccountNumber" integer, 
				  "MeterName" character varying, 
				  "ClientName" character varying,
				  "CustomerName" character varying,
				  "ControlAreaName" character varying,
				  "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
		FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"()
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('032_DW_AddFunction_GetSettlementIntervals');CREATE SCHEMA IF NOT EXISTS etl ;

CREATE OR REPLACE FUNCTION etl."MergeAccountSDPData" () 
RETURNS void AS $$
BEGIN


	INSERT INTO etl.ACCOUNTSDP_TEMP  
	SELECT 
	     ASDPSource."AccountSDPId",
		 AccDest."AccountKey",
		 SDPDest."SDPKey",
		 ASDPSource."StatusDateTime",
		 ASDPSource."StatusId",
		 ASDPSource."StartDateTime",
		 "AccountSDPKey"
		 				
	FROM  stg."AccountSDP" ASDPSource
	LEFT JOIN dw."DimAccount" AccDest
	ON AccDest."AccountAlternateKey" = ASDPSource."AccountId" AND AccDest."ApplicationCode" = 'OMDA' AND AccDest."Current" = TRUE
	LEFT JOIN dw."DimSDP" SDPDest 
	ON SDPDest."SDPAlternateKey" = ASDPSource."SDPId" AND SDPDest."Current" = TRUE		
	LEFT JOIN dw."DimAccountSDPBridge" ASDPDest
	ON ASDPDest."AccountSDPAlternateKey" = ASDPSource."AccountSDPId"  AND ASDPDest."Current" = TRUE ;

   -- INSERT NEW ROWS
	INSERT INTO 
	dw."DimAccountSDPBridge"
	(
		"AccountSDPAlternateKey",
		"StatusDateTime",
		"StatusId",
		"AccountKey",
		"SDPKey",
		"StartDateTime",
		"EndDateTime",
		"Current"
	)
	SELECT 
        "AccountSDPId",
		"StatusDateTime",
		"StatusId",
		"AccountKey",
		"SDPKey",
		"StartDateTime",
		NULL,
		TRUE 
	FROM etl.ACCOUNTSDP_TEMP
	WHERE "AccountSDPKey" IS NULL ;


	-- UPDATE ROWS WITH NO HISTORICAL (NO NEED FOR NOW SINCE WE NEED TO SCD2 ALL CHANGING FIELD)


    -- UPDATE ROWS WITH HISTORICAL (ENDDATETIME UPDATE)
	UPDATE dw."DimAccountSDPBridge" 
	SET 
		"EndDateTime" = now()::timestamp,
		"Current" = FALSE                  
	FROM      etl.ACCOUNTSDP_TEMP 
	WHERE     etl.ACCOUNTSDP_TEMP."AccountSDPKey" IS NOT NULL 
		 AND  etl.ACCOUNTSDP_TEMP."AccountSDPKey" = dw."DimAccountSDPBridge"."AccountSDPKey"
		 AND  (
			 	etl.ACCOUNTSDP_TEMP."StatusDateTime" != dw."DimAccountSDPBridge"."StatusDateTime"
			    OR 
			    etl.ACCOUNTSDP_TEMP."StatusId"       != dw."DimAccountSDPBridge"."StatusId"
			    OR 
			    etl.ACCOUNTSDP_TEMP."AccountKey"     != dw."DimAccountSDPBridge"."AccountKey"
			    OR 
			    etl.ACCOUNTSDP_TEMP."SDPKey"         != dw."DimAccountSDPBridge"."SDPKey"
			   );


	-- INSERT HISTORICAL ROWS
	INSERT INTO 
	dw."DimAccountSDPBridge"
	(
		"AccountSDPAlternateKey",
		"StatusDateTime",
		"StatusId",
		"AccountKey",
		"SDPKey",
		"StartDateTime",
		"EndDateTime",
		"Current"
	)
	SELECT 
	    ASDPTemp."AccountSDPId",
		ASDPTemp."StatusDateTime",
		ASDPTemp."StatusId",
		ASDPTemp."AccountKey",
		ASDPTemp."SDPKey",
		now()::timestamp as "StartDateTime",
		NULL,
		TRUE 
	FROM  etl.ACCOUNTSDP_TEMP ASDPTemp
	JOIN  dw."DimAccountSDPBridge" ASDPSrc 
	ON ASDPSrc."AccountSDPKey" = ASDPTemp."AccountSDPKey"
	WHERE     ASDPTemp."AccountSDPKey" IS NOT NULL 
		  AND  (
			 	ASDPTemp."StatusDateTime" != ASDPSrc."StatusDateTime"
			    OR 
			    ASDPTemp."StatusId"       != ASDPSrc."StatusId"
			    OR
			    ASDPTemp."AccountKey"     != ASDPSrc."AccountKey"
			    OR 
			    ASDPTemp."SDPKey"         != ASDPSrc."SDPKey"
			   );  

END;
$$ LANGUAGE plpgsql;








-- DW TABLES

-- DimAccountSDPBridge
CREATE TABLE dw."DimAccountSDPBridge"
(
    "AccountSDPKey" BIGSERIAL ,
	"AccountSDPAlternateKey" INTEGER NOT NULL,
	"StatusDateTime" TIMESTAMP NOT NULL,
	"StatusId" INTEGER NOT NULL,	
	"AccountKey" INTEGER NOT NULL,
    "SDPKey" INTEGER NOT NULL,
    "StartDateTime" TIMESTAMP NOT NULL,
    "EndDateTime" TIMESTAMP,
    "Current" boolean NOT NULL	
);
COMMENT ON TABLE dw."DimAccountSDPBridge" IS 'AccountSDP Bridge Dimension Table';
CREATE INDEX DimAccountSDPBridge_SDP_Account_1_index ON dw."DimAccountSDPBridge"("SDPKey", "AccountKey", "StatusId", "Current");
CREATE INDEX DimAccountSDPBridge_SDP_Account_2_index ON dw."DimAccountSDPBridge"("AccountSDPAlternateKey", "Current");
CREATE INDEX DimAccountSDPBridge_SDP_Account_3_index ON dw."DimAccountSDPBridge"("AccountSDPAlternateKey", "SDPKey", "AccountKey", "Current");
ALTER TABLE dw."DimAccountSDPBridge" ADD CONSTRAINT FK_AccountSDPBridge_Account FOREIGN KEY ("AccountKey") REFERENCES dw."DimAccount" ("AccountKey");
ALTER TABLE dw."DimAccountSDPBridge" ADD CONSTRAINT FK_AccountSDPBridge_SDP     FOREIGN KEY ("SDPKey")     REFERENCES dw."DimSDP" ("SDPKey");



-- FactVirtualEntities
CREATE TABLE dw."FactVirtualEntities"
(
    "VirtualEntityKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"VirtualEntityConfigId" INT ,
    "VirtualSDPKey" INT ,
    "VirtualMeterKey" INT,
    "SourceChannelKey" INT,
	"VirtualChannelKey" INT,
    "FactValueGoalKey" SMALLINT,
	"FactStatusKey" SMALLINT,
	"ParentVirtualEntityKey" BIGINT,		
    "IsNegative" BOOLEAN,
    "Factor" NUMERIC(18,2)
);
COMMENT ON TABLE dw."FactVirtualEntities" IS 'VirtualEntities Fact Table';
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_SDP           FOREIGN KEY ("VirtualSDPKey")       REFERENCES dw."DimSDP" ("SDPKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_METER         FOREIGN KEY ("VirtualMeterKey")     REFERENCES dw."DimMeter" ("MeterKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_ChanSource    FOREIGN KEY ("SourceChannelKey")    REFERENCES dw."DimChannel" ("ChannelKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_ChanVirtual   FOREIGN KEY ("VirtualChannelKey")   REFERENCES dw."DimChannel" ("ChannelKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_FactValueGoal FOREIGN KEY ("FactValueGoalKey")    REFERENCES dw."DimFactValueGoal" ("FactValueGoalKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_FactStatus    FOREIGN KEY ("FactStatusKey")       REFERENCES dw."DimFactStatus" ("FactStatusKey");

CREATE INDEX VirtualEntities_1_index ON dw."FactVirtualEntities"("VirtualEntityConfigId", "FactStatusKey");
CREATE INDEX VirtualEntities_2_index ON dw."FactVirtualEntities"("VirtualSDPKey", "VirtualMeterKey", "SourceChannelKey", "VirtualChannelKey", "FactStatusKey");
CREATE INDEX VirtualEntities_3_index ON dw."FactVirtualEntities"("VirtualEntityConfigId", "VirtualSDPKey", "VirtualMeterKey", "FactStatusKey");



-- STAGING TABLES

-- Stg_AccountSDP
CREATE TABLE stg."AccountSDP"
(    
	"AccountSDPId" INTEGER,
	"AccountId" INTEGER,
    "SDPId" INTEGER,
	"StatusDateTime" TIMESTAMP,
	"StatusId" INTEGER,		
    "StartDateTime" TIMESTAMP       
);

-- FactVirtualEntities
CREATE TABLE stg."FactVirtualEntities"
(    
	"VirtualEntityConfigId" INT ,
    "VirtualSDPId" INT ,
    "VirtualMeterId" TEXT,
    "SourceChannelId" TEXT,
	"VirtualChannelId" TEXT,    		
    "IsNegative" BOOLEAN,
    "Factor" NUMERIC(18,2)
);



-- TEMPORARY TABLES 

CREATE TABLE etl.ACCOUNTSDP_TEMP
(
    "AccountSDPId" INTEGER,
    "AccountKey" INTEGER,
    "SDPKey" INTEGER,
    "StatusDateTime" TIMESTAMP,
    "StatusId" INTEGER,
    "StartDateTime" TIMESTAMP,
    "AccountSDPKey" BIGINT    
);
CREATE INDEX ON etl.ACCOUNTSDP_TEMP ("AccountSDPKey");
CREATE INDEX ON etl.ACCOUNTSDP_TEMP ("AccountSDPKey","StatusDateTime","StatusId","AccountKey","SDPKey");





CREATE TABLE etl.facts_temp_virtual
(
    "dw_VirtualEntityKey" bigint,
    "dw_VirtualEntityConfigId" INTEGER,
    "stg_VirtualEntityConfigId" INTEGER,
    "stg_SDPKey" INTEGER,
    "stg_MeterKey" INTEGER,
    "stg_SourceChannelKey" BIGINT,
    "stg_VirtualChannelKey" BIGINT,
    "stg_IsNegative" BOOLEAN,
    "stg_Factor" numeric(18,2)     
) ;
CREATE INDEX ON etl.facts_temp_virtual ("stg_VirtualEntityConfigId","dw_VirtualEntityKey","dw_VirtualEntityConfigId");



CREATE OR REPLACE FUNCTION etl."stpMergeVirtualFactEntities"()
RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
BEGIN
   
  WITH dw_facts_CTE as
  (
      SELECT 
			"VirtualEntityKey"       as "dw_VirtualEntityKey",
			"VirtualEntityConfigId"  as "dw_VirtualEntityConfigId"
		FROM dw."FactVirtualEntities" fct
	    JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'	  
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "VirtualEntityConfigId"  as "stg_VirtualEntityConfigId",
            "SDPKey"                 as "stg_SDPKey",
            "MeterKey"               as "stg_MeterKey",
            chanSource."ChannelKey"  as "stg_SourceChannelKey",
	        chanVirtual."ChannelKey" as "stg_VirtualChannelKey",
            "IsNegative"             as "stg_IsNegative",           
            "Factor"                 as "stg_Factor"     
          

      FROM stg."FactVirtualEntities" fct      
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey"     = fct."VirtualSDPId"    AND sdp."Current" = True   -- AND sdp."IsVirtual" =  True    
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."VirtualMeterId"  AND meter."ApplicationCode" = 'OMDA' AND meter."Current" = True -- AND meter."IsVirtual" = True     
      JOIN dw."DimChannel" chanSource
        ON chanSource."ChannelAlternateKey" = fct."SourceChannelId" AND chanSource."ApplicationCode" = 'OMDA'  AND chanSource."Current" = True -- AND chanSource."IsVirtual" = False
      JOIN dw."DimChannel" chanVirtual
        ON chanVirtual."ChannelAlternateKey" = fct."VirtualChannelId" AND chanVirtual."ApplicationCode" = 'OMDA'  AND chanVirtual."Current" = True -- AND chanVirtual."IsVirtual" = True	  
  )
  INSERT INTO etl.facts_temp_virtual
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON  dw_fact."dw_VirtualEntityConfigId"  = stg_fact."stg_VirtualEntityConfigId" ;



   -- INSERT NEW FACTS
    INSERT INTO dw."FactVirtualEntities"(
		"InsertionDateTime",
		"AgingDateTime",
		"VirtualEntityConfigId",
		"VirtualSDPKey",
		"VirtualMeterKey",
		"SourceChannelKey",
		"VirtualChannelKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentVirtualEntityKey",
		"IsNegative",
		"Factor"
	)
    SELECT
           now()::timestamp,
           NULL,
           "stg_VirtualEntityConfigId",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_SourceChannelKey",
           "stg_VirtualChannelKey",
           1, -- INIT
		   1, -- STATUS,
		   NULL,
		   "stg_IsNegative",
		   "stg_Factor"

    FROM etl.facts_temp_virtual fct
    WHERE     fct."stg_VirtualEntityConfigId"  IS NOT NULL
          AND fct."dw_VirtualEntityKey"   IS NULL ;


 -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactVirtualEntities" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_virtual fct
   WHERE    dw_fct."VirtualEntityKey"   = fct."dw_VirtualEntityKey"
        AND fct."stg_VirtualEntityConfigId" IS NOT NULL
        AND fct."dw_VirtualEntityKey"       IS NOT NULL
        AND (
                             fct."stg_SDPKey"              !=  dw_fct."VirtualSDPKey"
               OR            fct."stg_MeterKey"            !=  dw_fct."VirtualMeterKey"
               OR            fct."stg_SourceChannelKey"    !=  dw_fct."SourceChannelKey"			
               OR            fct."stg_VirtualChannelKey"   !=  dw_fct."VirtualChannelKey"
               OR  COALESCE (fct."stg_IsNegative",FALSE)   != COALESCE (dw_fct."IsNegative",FALSE)
               OR  COALESCE (fct."stg_Factor",0)           != COALESCE (dw_fct."Factor",0)
            );


    -- INSERT NEW FACTS
    INSERT INTO dw."FactVirtualEntities"(
		"InsertionDateTime",
		"AgingDateTime",
		"VirtualEntityConfigId",
		"VirtualSDPKey",
		"VirtualMeterKey",
		"SourceChannelKey",
		"VirtualChannelKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentVirtualEntityKey",
		"IsNegative",
		"Factor"
	)
    SELECT
           now()::timestamp,
           NULL,
           "stg_VirtualEntityConfigId",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_SourceChannelKey",
           "stg_VirtualChannelKey",
           2, -- NEW
		   1, -- STATUS,
		   dw_fct."VirtualEntityKey",
		   "stg_IsNegative",
		   "stg_Factor"

    FROM etl.facts_temp_virtual fct
    JOIN dw."FactVirtualEntities" dw_fct
	ON dw_fct."VirtualEntityKey"   = fct."dw_VirtualEntityKey"
	WHERE fct."stg_VirtualEntityConfigId" IS NOT NULL
	  AND fct."dw_VirtualEntityKey"       IS NOT NULL
      AND (
                             fct."stg_SDPKey"              !=  dw_fct."VirtualSDPKey"
               OR            fct."stg_MeterKey"            !=  dw_fct."VirtualMeterKey"
               OR            fct."stg_SourceChannelKey"    !=  dw_fct."SourceChannelKey"			
               OR            fct."stg_VirtualChannelKey"   !=  dw_fct."VirtualChannelKey"
               OR  COALESCE (fct."stg_IsNegative",FALSE)   != COALESCE (dw_fct."IsNegative",FALSE)
               OR  COALESCE (fct."stg_Factor",0)           != COALESCE (dw_fct."Factor",0)
            );
    

    -- CANCEL NOT FOUND VIRTUAL ENTITIES
	UPDATE dw."FactVirtualEntities" dw_fct
	      SET "FactStatusKey" = 2,
		      "AgingDateTime" = now()::timestamp			  
	FROM   etl.facts_temp_virtual fct
	WHERE    dw_fct."VirtualEntityKey"   = fct."dw_VirtualEntityKey"
        AND fct."dw_VirtualEntityKey"        IS NOT NULL
		AND fct."dw_VirtualEntityConfigId"   IS NOT NULL
        AND fct."stg_VirtualEntityConfigId"  IS  NULL;

    -- INSERT CANCELLED NEW FACTS
    INSERT INTO dw."FactVirtualEntities"(
		"InsertionDateTime",
		"AgingDateTime",
		"VirtualEntityConfigId",
		"VirtualSDPKey",
		"VirtualMeterKey",
		"SourceChannelKey",
		"VirtualChannelKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentVirtualEntityKey",
		"IsNegative",
		"Factor"
	)
    SELECT
           now()::timestamp,
           NULL,
           "VirtualEntityConfigId",
           "VirtualSDPKey",
           "VirtualMeterKey",
           "SourceChannelKey",
           "VirtualChannelKey",
           3, -- CANCEL
		   2, -- OLD,
		   "VirtualEntityKey",
		   "IsNegative",
		   "Factor"
    FROM etl.facts_temp_virtual fct
    JOIN dw."FactVirtualEntities" dw_fct
	  ON dw_fct."VirtualEntityKey"   = fct."dw_VirtualEntityKey"
	WHERE   fct."dw_VirtualEntityKey"        IS NOT NULL
		AND fct."dw_VirtualEntityConfigId"   IS NOT NULL
        AND fct."stg_VirtualEntityConfigId"  IS  NULL;
	

  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;











INSERT INTO public."DatabaseVersionHistory" VALUES ('033_DW_ETL_Virtuals_Entities_Create_Scripts');CREATE SCHEMA IF NOT EXISTS etl ;


-- TEMPORARY TABLES

DROP TABLE IF EXISTS public.account_temp;
DROP TABLE IF EXISTS public.facts_temp_sett;
DROP TABLE IF EXISTS public.facts_temp_weather;
DROP TABLE IF EXISTS public.meter_temp;


CREATE TABLE etl.account_temp
(
    "AccountId" integer,
    "CustomerId" integer,
    "CustomerName" character varying(256) COLLATE pg_catalog."default",
    "CustomerAlternateId" character varying COLLATE pg_catalog."default",
    "ClientId" integer,
    "InsertionClientKey" integer,
    "AccountNumber" character varying(50) COLLATE pg_catalog."default",
    "PremiseNumber" character varying(5) COLLATE pg_catalog."default",
    "ControlAreaId" integer,
    "InsertionControlAreaKey" smallint,
    "TimeZoneId" integer,
    "InsertionTimeZoneKey" smallint,
    "ClientAccountKey" character varying(100) COLLATE pg_catalog."default",
    "ApplicationCode" character varying(4) COLLATE pg_catalog."default",
    "StartActiveDateTimeUTC" timestamp without time zone,
    "EndActiveDateTimeUTC" timestamp without time zone,
    "StartActiveDateTimeLocal" timestamp without time zone,
    "EndActiveDateTimeLocal" timestamp without time zone,
    "StartDateTime" timestamp without time zone,
    "AccountKey" integer,
    "ClientKey" integer,
    "InsertionCustomerKey" integer
)
WITH (
    OIDS = FALSE
)
TABLESPACE pg_default;

ALTER TABLE etl.account_temp
    OWNER to postgres;

CREATE INDEX ON etl.account_temp ("AccountKey","InsertionClientKey","InsertionCustomerKey","InsertionControlAreaKey");



CREATE TABLE etl.meter_temp
(
    "MeterId" integer,
    "MeterTypeId" integer,
    "Name" character varying(50) COLLATE pg_catalog."default",
    "DeviceCode" character varying(50) COLLATE pg_catalog."default",
	"MeterAlternateKey" character varying(50) COLLATE pg_catalog."default",
    "IntervalsPerHour" integer,
    "IsDSTEnabled" boolean,
    "TimeZoneId" integer,    
    "IsVirtual" boolean,
    "DSTRegionId" integer,
    "FirstEndDateTimeUTC" timestamp without time zone,
    "LastEndDateTimeUTC" timestamp without time zone,
    "Manufacturer" character varying(50) COLLATE pg_catalog."default",
    "Type" character varying(50) COLLATE pg_catalog."default",
    "ApplicationCode" character varying(4) COLLATE pg_catalog."default",
    "MeterSDP" character varying(100) COLLATE pg_catalog."default",
    "MeterSDPStartDateTime" timestamp without time zone,
    "MeterSDPStopDateTime" timestamp without time zone,
    "StartDateTime" timestamp without time zone,    
	"InsertionTimeZoneKey" smallint,
	"MeterKey" integer,
    "Current" boolean,
    "TimeZoneKey" smallint
)
WITH (
    OIDS = FALSE
)
TABLESPACE pg_default;

ALTER TABLE etl.meter_temp
    OWNER to postgres;


CREATE INDEX ON etl.meter_temp ("MeterKey","InsertionTimeZoneKey","MeterSDP");





CREATE TABLE etl.facts_temp_sett
(
    "dw_IntervalKey" bigint,
    "dw_InsertionDateTime" timestamp without time zone,
    "dw_MonthlyRead" numeric(28,4),
    "dw_Usage" numeric(28,4),
    "dw_UsageDLF" numeric(28,4),
    "dw_Demand" numeric(28,4),
    "dw_DemandDLF" numeric(28,4),
    "dw_DLP" numeric(18,6),
    "dw_DLPSum" numeric(18,6),
    "dw_DLPRation" numeric(18,6),
    "dw_DLF" numeric(18,7),
    "dw_StartDateTimeUTC" timestamp without time zone,
    "dw_EndDateTimeUTC" timestamp without time zone,
    "dw_StartDateTimeLocal" timestamp without time zone,
    "dw_EndDateTimeLocal" timestamp without time zone,
    "dw_AccountKey" integer,
    "dw_SDPKey" integer,
    "dw_MeterKey" integer,
    "dw_ChannelKey" integer,
    "dw_OriginConsumptionKey" smallint,
    "dw_FactValueGoalKey" smallint,
    "dw_ServiceTypeKey" smallint,
    "dw_ParentIntervalKey" bigint,
    "dw_FactStatusKey" smallint,
    "dw_EndDateLocalKey" integer,
    "dw_EndTimeLocalKey" smallint,
    "dw_EndDateUTCKey" integer,
    "dw_EndTimeUTCKey" smallint,
    "dw_RecordedDateUTCKey" integer,
    "dw_ClientKey" integer,
    "stg_MonthlyRead" numeric(28,4),
    "stg_Usage" numeric(28,4),
    "stg_UsageDLF" numeric(28,4),
    "stg_Demand" numeric(28,4),
    "stg_DemandDLF" numeric(28,4),
    "stg_DLP" numeric(18,6),
    "stg_DLPSum" numeric(18,6),
    "stg_DLPRation" numeric(18,6),
    "stg_DLF" numeric(18,7),
    "stg_StartDateTimeUTC" timestamp without time zone,
    "stg_EndDateTimeUTC" timestamp without time zone,
    "stg_StartDateTimeLocal" timestamp without time zone,
    "stg_EndDateTimeLocal" timestamp without time zone,
    "stg_ClientKey" integer,
    "stg_AccountKey" integer,
    "stg_SDPKey" integer,
    "stg_MeterKey" integer,
    "stg_ChannelKey" integer,
    "stg_OriginConsumptionKey" smallint,
    "stg_OriginConsumptionCode" character varying(8) COLLATE pg_catalog."default",
    "stg_ServiceTypeKey" smallint,
    "stg_EndDateLocalKey" integer,
    "stg_EndDateUTCKey" integer,
    "stg_EndTimeLocalKey" smallint,
    "stg_EndTimeUTCKey" smallint,
    "stg_RecordedDateKey" integer
)
WITH (
    OIDS = FALSE
)
TABLESPACE pg_default;

ALTER TABLE etl.facts_temp_sett
    OWNER to postgres;


CREATE INDEX "facts_temp_sett_stg_EndDateUTCKey_dw_IntervalKey_idx"
    ON etl.facts_temp_sett USING btree
    ("stg_EndDateUTCKey", "dw_IntervalKey")
    TABLESPACE pg_default;




CREATE TABLE etl.facts_temp_weather
(
    "dw_WeatherKey" bigint,
    "dw_InsertionDateTime" timestamp without time zone,
    "dw_AgingDateTime" timestamp without time zone,
    "dw_WeatherObservationId" bigint,
    "dw_StationKey" integer,
    "dw_FactValueGoalKey" smallint,
    "dw_FactStatusKey" smallint,
    "dw_ParentWeatherkey" bigint,
    "dw_EndDateTimeUTC" timestamp without time zone,
    "dw_EndDateUTCKey" integer,
    "dw_EndTimeUTCKey" smallint,
    "dw_RecorderdDateUTCKey" integer,
    "dw_oC" integer,
    "dw_oF" integer,
    "dw_Humidity" integer,
    "stg_WeatherObservationId" bigint,
    "stg_EndDateTimeUTC" timestamp without time zone,
    "stg_oC" integer,
    "stg_oF" integer,
    "stg_Humidity" integer,
    "stg_StationKey" integer,
    "stg_EndDateUTCKey" integer,
    "stg_EndTimeUTCKey" smallint,
    "stg_RecordedDateKey" integer
)
WITH (
    OIDS = FALSE
)
TABLESPACE pg_default;

ALTER TABLE etl.facts_temp_weather
    OWNER to postgres;


CREATE INDEX "facts_temp_weather_stg_EndDateUTCKey_dw_WeatherKey_idx"
    ON etl.facts_temp_weather USING btree
    ("stg_EndDateUTCKey", "dw_WeatherKey")
    TABLESPACE pg_default;







---------------------------------------------------------------------------------------------------------------------------------
DROP FUNCTION IF EXISTS public."stpMergeDailyFactWeather";
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactWeather";

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactWeather"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN



  WITH dw_facts_CTE as
  (
      SELECT
                 "WeatherKey"                    as "dw_WeatherKey",
                 "InsertionDateTime"             as "dw_InsertionDateTime" ,
                 "AgingDateTime"                 as "dw_AgingDateTime",
                 "WeatherObservationId"          as "dw_WeatherObservationId",
                 "StationKey"                    as "dw_StationKey",
                 "FactValueGoalKey"              as "dw_FactValueGoalKey",
                 fct."FactStatusKey"             as "dw_FactStatusKey",
                 "ParentWeatherKey"              as "dw_ParentWeatherkey",
                 "EndDateTimeUTC"                as "dw_EndDateTimeUTC",
                 "EndDateUTCKey"                 as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"                 as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey"            as "dw_RecorderdDateUTCKey",
	             "oC"                            as "dw_oC",
	             "oF"                            as "dw_oF",
	             "Humidity"                      as "dw_Humidity"
	  
      FROM dw."FactWeather" fct
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
	  
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "WeatherObservationId"           as "stg_WeatherObservationId",
            "EndDateTimeUTC"                 as "stg_EndDateTimeUTC",
            "oC"                             as "stg_oC",
            "oF"                             as "stg_oF",
	        "Humidity"                       as "stg_Humidity",
            "StationKey"                     as "stg_StationKey",           
            dateUTC."DateKey"                as "stg_EndDateUTCKey",         
            timeUTC."TimeKey"                as "stg_EndTimeUTCKey",
            recordedDate."DateKey"           as "stg_RecordedDateKey"

      FROM stg."FactWeather" fct      
      JOIN dw."DimWeatherStation" station
        ON station."StationAlternateKey" = fct."ObservationStationId"     
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"     
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" 
  )
  
  INSERT INTO etl.facts_temp_weather
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON     dw_fact."dw_WeatherObservationId"       = stg_fact."stg_WeatherObservationId"          
        AND dw_fact."dw_StationKey"                 = stg_fact."stg_StationKey"
        AND dw_fact."dw_EndDateUTCKey"              = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"              = stg_fact."stg_EndTimeUTCKey"
    ;
	
    -- INSERT NEW FACTS
	INSERT INTO dw."FactWeather"(
		"InsertionDateTime",
		"AgingDateTime",
		"WeatherObservationId",
		"StationKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentWeatherKey",
		"EndDateTimeUTC",
		"EndDateUTCKey",
		"EndTimeUTCKey",
		"RecordedDateUTCKey",
		"oC",
		"oF",
		"Humidity"
	)		
    SELECT
           now()::timestamp,
           NULL,
           "stg_WeatherObservationId",
           "stg_StationKey",
           1, --INIT
           1, --CURRENT
           NULL, -- PARENT WEATHER KEY
           "stg_EndDateTimeUTC",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_oC",
           "stg_oF",
	       "stg_Humidity"
		   
    FROM etl.facts_temp_weather fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_WeatherKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactWeather" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_weather fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."WeatherKey" = fct."dw_WeatherKey"
        AND fct."dw_WeatherKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_oC",-1)        != COALESCE (fct."dw_oC",-1)
               OR COALESCE (fct."stg_oF",-1)        != COALESCE (fct."dw_oF",-1)
               OR COALESCE (fct."stg_Humidity",-1)  != COALESCE (fct."dw_Humidity",-1)
            );

    -- INSERT NEW FACTS
	INSERT INTO dw."FactWeather"(
		"InsertionDateTime",
		"AgingDateTime",
		"WeatherObservationId",
		"StationKey",
		"FactValueGoalKey",
		"FactStatusKey",
		"ParentWeatherKey",
		"EndDateTimeUTC",
		"EndDateUTCKey",
		"EndTimeUTCKey",
		"RecordedDateUTCKey",
		"oC",
		"oF",
		"Humidity"
	)
        SELECT
           now()::timestamp,
           NULL,
           "stg_WeatherObservationId",
           "stg_StationKey",
           2, --INIT
           1, --CURRENT
           fct."dw_WeatherKey", -- PARENT WEATHER KEY
           "stg_EndDateTimeUTC",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_oC",
           "stg_oF",
	       "stg_Humidity"

    FROM etl.facts_temp_weather fct
    WHERE   fct."dw_WeatherKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
         AND (
                  COALESCE (fct."stg_oC",-1)        != COALESCE (fct."dw_oC",-1)
               OR COALESCE (fct."stg_oF",-1)        != COALESCE (fct."dw_oF",-1)
               OR COALESCE (fct."stg_Humidity",-1)  != COALESCE (fct."dw_Humidity",-1)
            );

  

  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;


-----------------------------------------------------------------------

DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals_SETT";
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT";


CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

  -- CANCEL UNEXISTANTS FACTS
  UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;

   INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
   SELECT
           now()::timestamp,
	   now()::timestamp,
           "dw_MonthlyRead",
           "dw_Usage",
           "dw_UsageDLF",
           "dw_Demand",
           "dw_DemandDLF",
           "dw_DLP",
           "dw_DLPSum",
           "dw_DLPRation",
           "dw_DLF",
           "dw_StartDateTimeUTC",
           "dw_EndDateTimeUTC",
           "dw_StartDateTimeLocal",
           "dw_EndDateTimeLocal",
           "dw_AccountKey",
           "dw_SDPKey",
           "dw_MeterKey",
           "dw_ChannelKey",
           "dw_OriginConsumptionKey",
           3,
           "dw_ServiceTypeKey",
           "dw_ParentIntervalKey",
           2,
           "dw_EndDateLocalKey",
           "dw_EndTimeLocalKey",
           "dw_EndDateUTCKey",
           "dw_EndTimeUTCKey",
           "dw_RecordedDateUTCKey"
   FROM etl.facts_temp_sett fct
   WHERE    fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NULL;




  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

---------------------------------------------------------------

CREATE OR REPLACE FUNCTION etl."MergeAccountData"()
RETURNS void
LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
AS $BODY$

BEGIN

INSERT INTO  etl.ACCOUNT_TEMP  
	SELECT ACC_TEMP.*, Cust."CustomerKey" as "InsertionCustomerKey"
	FROM 
	(
			SELECT 
				"AccountId",
				"CustomerId",
				"CustomerName",
				CASE 
					WHEN  ASrc."ApplicationCode"= 'OMDA'  THEN "CustomerId"::text
					ELSE "CustomerName"
				END AS "CustomerAlternateId",
				"ClientId",
				CL."ClientKey" as "InsertionClientKey",
				ASrc."AccountNumber",
				ASrc."PremiseNumber",
				"ControlAreaId",
				CA."ControlAreaKey" as "InsertionControlAreaKey",
				"TimeZoneId",
				TZ."TimeZoneKey" as "InsertionTimeZoneKey",
				ASrc."ClientAccountKey",
				ASrc."ApplicationCode",
				ASrc."StartActiveDateTimeUTC",
				ASrc."EndActiveDateTimeUTC",
				ASrc."StartActiveDateTimeLocal",
				ASrc."EndActiveDateTimeLocal",
				ASrc."StartDateTime",
				ADes."AccountKey",
				ADes."ClientKey"      

		FROM stg."Account" ASrc
		LEFT JOIN dw."DimAccount" ADes
		ON ASrc."AccountId" = ADes."AccountAlternateKey"  AND ASrc."ApplicationCode" = ADes."ApplicationCode" AND ADes."Current" = TRUE
		LEFT JOIN dw."DimClient" CL
		ON CL."ClientAlternateKey" = ASrc."ClientId" AND CL."Current" =  TRUE
		LEFT JOIN dw."DimControlArea" CA
		ON CA."ControlAreaAlternateKey" = ASrc."ControlAreaId"
		LEFT JOIN dw."DimTimeZone" TZ
		ON TZ."TimeZoneAlternateKey" =  ASrc."TimeZoneId"
	) ACC_TEMP
	LEFT JOIN dw."DimCustomer" Cust
	ON  Cust."CustomerAlternateKey" = ACC_TEMP."CustomerAlternateId" AND Cust."Current" =  TRUE ;

	-- INSERT NEW ROWS
	INSERT INTO dw."DimAccount"(
		"AccountAlternateKey",
		"ApplicationCode",
		"AccountNumber",
		"PremiseNumber",
		"TimeZoneKey",
		"ClientAccountKey",
		"ClientKey",
		"CustomerKey",
		"ControlAreaKey",
		"StartActiveDateTimeUTC",
		"EndActiveDateTimeUTC",
		"StartActiveDateTimeLocal",
		"EndActiveDateTimeLocal",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
			"AccountId",
			"ApplicationCode",
			"AccountNumber",
			"PremiseNumber",
			"InsertionTimeZoneKey",
			"ClientAccountKey",
			"InsertionClientKey",
			"InsertionCustomerKey",
			"InsertionControlAreaKey",
			"StartActiveDateTimeUTC",
			"EndActiveDateTimeUTC",
			"StartActiveDateTimeLocal",
			"EndActiveDateTimeLocal",
			"StartDateTime",
			NULL,
			TRUE
	FROM etl.ACCOUNT_TEMP
	WHERE "AccountKey" IS NULL ;

	-- UPDATE ROWS WITH NO HISTORICAL
	UPDATE dw."DimAccount"

		SET     	
			"ApplicationCode"= etl.ACCOUNT_TEMP."ApplicationCode",
			"AccountNumber"= etl.ACCOUNT_TEMP."AccountNumber",
			"PremiseNumber"= etl.ACCOUNT_TEMP."PremiseNumber",
			"TimeZoneKey"= etl.ACCOUNT_TEMP."InsertionTimeZoneKey",
			"ClientAccountKey"= etl.ACCOUNT_TEMP."ClientAccountKey",
			"ClientKey"= etl.ACCOUNT_TEMP."InsertionClientKey",
			"CustomerKey"= etl.ACCOUNT_TEMP."InsertionCustomerKey",
			"ControlAreaKey"= etl.ACCOUNT_TEMP."InsertionControlAreaKey",
			"StartActiveDateTimeUTC"= etl.ACCOUNT_TEMP."StartActiveDateTimeUTC",
			"EndActiveDateTimeUTC"= etl.ACCOUNT_TEMP."EndActiveDateTimeUTC",
			"StartActiveDateTimeLocal"= etl.ACCOUNT_TEMP."StartActiveDateTimeLocal",
			"EndActiveDateTimeLocal"= etl.ACCOUNT_TEMP."EndActiveDateTimeLocal"

	FROM     etl.ACCOUNT_TEMP
	WHERE    etl.ACCOUNT_TEMP."AccountKey" IS NOT NULL  
	      AND     etl.ACCOUNT_TEMP."AccountKey"              = dw."DimAccount"."AccountKey"
		  AND    COALESCE(etl.ACCOUNT_TEMP."InsertionClientKey",0)      = COALESCE(dw."DimAccount"."ClientKey",0)
		  AND    COALESCE(etl.ACCOUNT_TEMP."InsertionCustomerKey",0)    = COALESCE(dw."DimAccount"."CustomerKey",0)
		  AND    COALESCE(etl.ACCOUNT_TEMP."InsertionControlAreaKey",0) = COALESCE(dw."DimAccount"."ControlAreaKey",0) ;

	-- UPDATE ROWS WITH HISTORICAL (ENDDATETIME UPDATE)
	UPDATE dw."DimAccount"
	SET 
		"EndDateTime" = now()::timestamp,
		"Current" = FALSE                  
	FROM  etl.ACCOUNT_TEMP 
	WHERE    etl.ACCOUNT_TEMP."AccountKey" IS NOT NULL 
	      AND  etl.ACCOUNT_TEMP."AccountKey" = dw."DimAccount"."AccountKey"
		  AND  (
			  	COALESCE (etl.ACCOUNT_TEMP."InsertionClientKey",-1)      != COALESCE (dw."DimAccount"."ClientKey",-1) 
			    OR 
				COALESCE (etl.ACCOUNT_TEMP."InsertionCustomerKey",-1)    != COALESCE (dw."DimAccount"."CustomerKey",-1)
			    OR
			    COALESCE (etl.ACCOUNT_TEMP."InsertionControlAreaKey",-1) != COALESCE (dw."DimAccount"."ControlAreaKey",-1)
		       );

	-- INSERT HISTORICAL ROWS
	INSERT INTO dw."DimAccount"(
		"AccountAlternateKey",
		"ApplicationCode",
		"AccountNumber",
		"PremiseNumber",
		"TimeZoneKey",
		"ClientAccountKey",
		"ClientKey",
		"CustomerKey",
		"ControlAreaKey",
		"StartActiveDateTimeUTC",
		"EndActiveDateTimeUTC",
		"StartActiveDateTimeLocal",
		"EndActiveDateTimeLocal",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
			ATemp."AccountId",
			ATemp."ApplicationCode",
			ATemp."AccountNumber",
			ATemp."PremiseNumber",
			ATemp."InsertionTimeZoneKey",
			ATemp."ClientAccountKey",
			ATemp."InsertionClientKey",
			ATemp."InsertionCustomerKey",
			ATemp."InsertionControlAreaKey",
			ATemp."StartActiveDateTimeUTC",
			ATemp."EndActiveDateTimeUTC",
			ATemp."StartActiveDateTimeLocal",
			ATemp."EndActiveDateTimeLocal",
			now()::timestamp as "StartDateTime",
			NULL,
			TRUE
	FROM etl.ACCOUNT_TEMP ATemp
	JOIN dw."DimAccount" ASrc 
	ON ASrc."AccountKey" = ATemp."AccountKey"
	WHERE         ATemp."AccountKey" IS NOT NULL  
			 AND  (
					COALESCE (ATemp."InsertionClientKey",-1)      != COALESCE (ASrc."ClientKey",-1) 
					OR 
					COALESCE (ATemp."InsertionCustomerKey",-1)    != COALESCE (ASrc."CustomerKey",-1)
				    OR
				    COALESCE (ATemp."InsertionControlAreaKey",-1) != COALESCE (ASrc."ControlAreaKey",-1)
				   );
	
END;
$BODY$;

ALTER FUNCTION etl."MergeAccountData"()
    OWNER TO postgres;




CREATE OR REPLACE FUNCTION etl."MergeMeterData"()
    RETURNS void
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
AS $BODY$

BEGIN
	    INSERT INTO etl.METER_TEMP  	
	    SELECT MS.*, TZ."TimeZoneKey" as "InsertionTimeZoneKey", MD."MeterKey", MD."Current",MD."TimeZoneKey"
		FROM 
	    (
			 SELECT 
						"MeterId",
						"MeterTypeId",
						MS."Name",
						MS."DeviceCode",
						CASE 
							WHEN MS."ApplicationCode" = 'OMDA' THEN MS."MeterId"::text 
							WHEN MS."ApplicationCode" = 'SETT' THEN MS."DeviceCode"
						END AS "MeterAlternateKey",
						MS."IntervalsPerHour",
						MS."IsDSTEnabled",
						MS."TimeZoneId",
						MS."IsVirtual",
						"DSTRegionId",
						MS."FirstEndDateTimeUTC",
						MS."LastEndDateTimeUTC",
						MS."Manufacturer",
						"Type",
						MS."ApplicationCode",
						MS."MeterSDP",
						MS."MeterSDPStartDateTime",
						MS."MeterSDPStopDateTime",								
						MS."StartDateTime"
			FROM  stg."Meter" MS
		) AS  MS
		LEFT JOIN dw."DimTimeZone" TZ
		ON TZ."TimeZoneAlternateKey" = MS."TimeZoneId"
		LEFT JOIN dw."DimMeter" MD
		ON MD."MeterAlternateKey" = MS."MeterAlternateKey" AND  MD."ApplicationCode" = MS."ApplicationCode" AND MD."Current" = TRUE ;


	-- INSERT NEW ROWS
	INSERT INTO 
	
	dw."DimMeter"(
		"MeterAlternateKey",
		"ApplicationCode",
		"Name",
		"DeviceCode",
		"IntervalsPerHour",
		"IsDSTEnabled",
		"IsVirtual",
		"MeterType",
		"Manufacturer",
		"FirstEndDateTimeUTC",
		"LastEndDateTimeUTC",
		"MeterSDP",
		"MeterSDPStartDateTime",
		"MeterSDPStopDateTime",	
		"TimeZoneKey",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
		"MeterAlternateKey",
		"ApplicationCode",
		"Name",
		"DeviceCode",
		"IntervalsPerHour",
		"IsDSTEnabled",
		"IsVirtual",
		"Type",
		"Manufacturer",
		"FirstEndDateTimeUTC",
		"LastEndDateTimeUTC",
		"MeterSDP",
		"MeterSDPStartDateTime",
		"MeterSDPStopDateTime",	
		"InsertionTimeZoneKey",
		"StartDateTime",
		NULL,
		TRUE 
	FROM etl.METER_TEMP
	WHERE "MeterKey" IS NULL ;

	-- UPDATE ROWS WITH NO HISTORICAL
	UPDATE dw."DimMeter" 
	SET 
		"Name" = etl.METER_TEMP."Name",
		"DeviceCode" = etl.METER_TEMP."DeviceCode",
		"IntervalsPerHour" = etl.METER_TEMP."IntervalsPerHour",
		"IsDSTEnabled" = etl.METER_TEMP."IsDSTEnabled",
		"IsVirtual" = etl.METER_TEMP."IsVirtual",
		"MeterType" = etl.METER_TEMP."Type",
		"Manufacturer" = etl.METER_TEMP."Manufacturer",
		"FirstEndDateTimeUTC" = etl.METER_TEMP."FirstEndDateTimeUTC",
		"LastEndDateTimeUTC" = etl.METER_TEMP."LastEndDateTimeUTC",
		"MeterSDP" = etl.METER_TEMP."MeterSDP",
		"MeterSDPStartDateTime" = etl.METER_TEMP."MeterSDPStartDateTime",
		"MeterSDPStopDateTime" = etl.METER_TEMP."MeterSDPStopDateTime"		
	FROM etl.METER_TEMP 
	WHERE     etl.METER_TEMP."MeterKey" IS NOT NULL 
	     AND  etl.METER_TEMP."MeterKey" =  dw."DimMeter"."MeterKey"
		 AND  COALESCE(etl.METER_TEMP."InsertionTimeZoneKey",0) = COALESCE(dw."DimMeter"."TimeZoneKey",0)
		 AND  COALESCE(etl.METER_TEMP."MeterSDP",'-1') = COALESCE(dw."DimMeter"."MeterSDP",'-1')		 
		 AND  etl.METER_TEMP."Current" = TRUE;

	-- UPDATE ROWS WITH HISTORICAL (ENDDATETIME UPDATE)
	UPDATE dw."DimMeter" 
	SET 
		"EndDateTime" = now()::timestamp,
		"Current" = FALSE                  
	FROM etl.METER_TEMP 
	WHERE     etl.METER_TEMP."MeterKey" IS NOT NULL 
		 AND  etl.METER_TEMP."MeterKey" = dw."DimMeter"."MeterKey"
		 AND  (
			 	COALESCE(etl.METER_TEMP."InsertionTimeZoneKey",0) != COALESCE(dw."DimMeter"."TimeZoneKey",0)
			    OR 
			    COALESCE(etl.METER_TEMP."MeterSDP",'-1')          != COALESCE(dw."DimMeter"."MeterSDP",'-1')
			   )
		 AND  etl.METER_TEMP."Current" = TRUE;

	-- INSERT HISTORICAL ROWS
	INSERT INTO 
		dw."DimMeter"(
		"MeterAlternateKey",
		"ApplicationCode",
		"Name",
	    "DeviceCode",
		"IntervalsPerHour",
		"IsDSTEnabled",
		"IsVirtual",
		"MeterType",
		"Manufacturer",
		"FirstEndDateTimeUTC",
		"LastEndDateTimeUTC",
		"MeterSDP",
		"MeterSDPStartDateTime",
		"MeterSDPStopDateTime",	
		"TimeZoneKey",
		"StartDateTime",
		"EndDateTime",
		"Current")
	SELECT 
		MTemp."MeterAlternateKey",
		MTemp."ApplicationCode",
		MTemp."Name",
		MTemp."DeviceCode",
		MTemp."IntervalsPerHour",
		MTemp."IsDSTEnabled",
		MTemp."IsVirtual",
		MTemp."Type",
		MTemp."Manufacturer",
		MTemp."FirstEndDateTimeUTC",
		MTemp."LastEndDateTimeUTC",
		MTemp."MeterSDP",
		MTemp."MeterSDPStartDateTime",
		MTemp."MeterSDPStopDateTime",	
		MTemp."InsertionTimeZoneKey",
		now()::timestamp as "StartDateTime",
		NULL,
		TRUE 
	FROM      etl.METER_TEMP MTemp
	JOIN  dw."DimMeter" MSrc 
	ON MSrc."MeterKey" = MTemp."MeterKey"
	WHERE     MTemp."MeterKey" IS NOT NULL 
		  AND  (
			 	COALESCE(MTemp."InsertionTimeZoneKey",0) != COALESCE(MSrc."TimeZoneKey",0)
			    OR 
			    COALESCE(MTemp."MeterSDP",'-1')          != COALESCE(MSrc."MeterSDP",'-1')
			   )
		 AND  MTemp."Current" = TRUE;     
	
END;

$BODY$;

ALTER FUNCTION etl."MergeMeterData"()
    OWNER TO postgres;








-----------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('034_DW_ETL_SchemaChange_Create_Scripts');CREATE SCHEMA IF NOT EXISTS etl ;

--DROP TABLE
DROP TABLE dw."FactIntervals_SETT";
DROP TABLE dw."DimMeter" CASCADE ;


-- DimMeter
CREATE TABLE dw."DimMeter"
(
    "MeterKey" SERIAL PRIMARY KEY NOT NULL,
    "MeterAlternateKey" character varying(50) COLLATE pg_catalog."default" NOT NULL,
    "ApplicationCode" character varying(4) COLLATE pg_catalog."default" NOT NULL,
    "Name" character varying(50) COLLATE pg_catalog."default" NOT NULL,
	"DeviceCode" character varying(50) COLLATE pg_catalog."default" NOT NULL,
    "IntervalsPerHour" smallint NOT NULL,
    "IsDSTEnabled" boolean NOT NULL,
    "IsVirtual" boolean NOT NULL,
    "MeterType" character varying(50) COLLATE pg_catalog."default",
    "Manufacturer" character varying(50) COLLATE pg_catalog."default",
    "FirstEndDateTimeUTC" timestamp without time zone,
    "LastEndDateTimeUTC" timestamp without time zone,
    "MeterSDP" character varying(100) COLLATE pg_catalog."default",
    "MeterSDPStartDateTime" timestamp without time zone,
    "MeterSDPStopDateTime" timestamp without time zone,
    "TimeZoneKey" smallint,
    "StartDateTime" timestamp without time zone NOT NULL,
    "EndDateTime" timestamp without time zone,
    "Current" boolean NOT NULL,
    CONSTRAINT fk_meter_timezone FOREIGN KEY ("TimeZoneKey")
        REFERENCES dw."DimTimeZone" ("TimeZoneKey") MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)
WITH (
    OIDS = FALSE
)
TABLESPACE pg_default;

ALTER TABLE dw."DimMeter"
    OWNER to postgres;
COMMENT ON TABLE dw."DimMeter"
    IS 'Meter, MeterType and MeterManufacturer Dimension';


CREATE INDEX dimmeter_alternatekey_appcode_device_name_current_index
    ON dw."DimMeter" USING btree
    ("MeterAlternateKey" COLLATE pg_catalog."default", "ApplicationCode" COLLATE pg_catalog."default", "DeviceCode" COLLATE pg_catalog."default", "Name" COLLATE pg_catalog."default", "Current")
    TABLESPACE pg_default;





-- FactIntervals
CREATE TABLE dw."FactIntervals_SETT"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"MonthlyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,	
	"UsageDLF" NUMERIC(28,4),	
    "Demand" NUMERIC(28,4) ,    
	"DemandDLF" NUMERIC(28,4) ,        
    "DLP" NUMERIC(18,6),	
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),	
    "DLF" NUMERIC(18,7),    
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
    "AccountKey" INT,
    "SDPKey" INT ,
    "MeterKey" INT,
    "ChannelKey" INT,    
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
	"ServiceTypeKey" SMALLINT,
	"ParentIntervalKey" BIGINT,
	"FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactIntervals_SETT" IS 'Intervals Fact Table';

--2015
CREATE TABLE dw.intervals_y2015m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2015m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2015m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2015m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2015m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2015m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2015m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey");



--2016
CREATE TABLE dw.intervals_y2016m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2016m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


--2017
CREATE TABLE dw.intervals_y2017m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2017m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


--2018
CREATE TABLE dw.intervals_y2018m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2018m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


--2019
CREATE TABLE dw.intervals_y2019m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey");


CREATE TABLE dw.intervals_y2019m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey");































-----------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('035_DW_FactSETT_Indexes_Create_Scripts');DROP TABLE dw."FactWeather";

-- FactWeather
CREATE TABLE dw."FactWeather"
(
    "WeatherKey" BIGSERIAL,
    "InsertionDateTime" TIMESTAMP,
    "AgingDateTime" TIMESTAMP,	
	"WeatherObservationId" BIGINT,
    "StationKey" INT,
	"FactValueGoalKey" SMALLINT,	
	"FactStatusKey" SMALLINT,
	"ParentWeatherKey" BIGINT,	
	"EndDateTimeUTC" TIMESTAMP ,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT,
    "oC" INT,
    "oF" INT,
    "Humidity" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactWeather" IS 'Weather Fact Table';


--2015
CREATE TABLE dw.weather_y2015m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.weather_y2015m06 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2015m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.weather_y2015m07 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2015m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.weather_y2015m08 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2015m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.weather_y2015m09 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2015m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.weather_y2015m10 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2015m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.weather_y2015m11 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");







CREATE TABLE dw.weather_y2015m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.weather_y2015m12 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2015m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");






--2016
CREATE TABLE dw.weather_y2016m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.weather_y2016m01 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.weather_y2016m02 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2016m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.weather_y2016m03 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.weather_y2016m04 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.weather_y2016m05 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.weather_y2016m06 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.weather_y2016m07 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.weather_y2016m08 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.weather_y2016m09 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2016m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.weather_y2016m10 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");






CREATE TABLE dw.weather_y2016m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.weather_y2016m11 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");






CREATE TABLE dw.weather_y2016m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.weather_y2016m12 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2016m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





--2017
CREATE TABLE dw.weather_y2017m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.weather_y2017m01 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");






CREATE TABLE dw.weather_y2017m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.weather_y2017m02 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.weather_y2017m03 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.weather_y2017m04 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.weather_y2017m05 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.weather_y2017m06 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.weather_y2017m07 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.weather_y2017m08 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.weather_y2017m09 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.weather_y2017m10 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.weather_y2017m11 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2017m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.weather_y2017m12 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2017m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





--2018
CREATE TABLE dw.weather_y2018m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.weather_y2018m01 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2018m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.weather_y2018m02 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");



CREATE TABLE dw.weather_y2018m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.weather_y2018m03 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2018m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.weather_y2018m04 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.weather_y2018m05 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.weather_y2018m06 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.weather_y2018m07 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.weather_y2018m08 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.weather_y2018m09 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.weather_y2018m10 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.weather_y2018m11 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2018m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.weather_y2018m12 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2018m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





--2019
CREATE TABLE dw.weather_y2019m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.weather_y2019m01 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m01 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2019m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.weather_y2019m02 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m02 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.weather_y2019m03 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m03 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.weather_y2019m04 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m04 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.weather_y2019m05 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m05 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.weather_y2019m06 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m06 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.weather_y2019m07 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m07 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.weather_y2019m08 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m08 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");




CREATE TABLE dw.weather_y2019m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.weather_y2019m09 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m09 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.weather_y2019m10 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m10 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.weather_y2019m11 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m11 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





CREATE TABLE dw.weather_y2019m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.weather_y2019m12 ("EndDateUTCKey", "EndDateTimeUTC", "EndTimeUTCKey","FactStatusKey");
CREATE INDEX ON dw.weather_y2019m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m12 ("StationKey", "EndDateUTCKey" , "EndDateTimeUTC","FactStatusKey");





INSERT INTO public."DatabaseVersionHistory" VALUES ('036_DW_FactWeather_Create_Scripts');ALTER TABLE ct."LoadStream" ADD ClientId INTEGER;
ALTER TABLE ct."LoadStream" ADD LoadStreamETLConfigId INTEGER;

INSERT INTO public."DatabaseVersionHistory" VALUES ('037_DW_AddClientId_LoadStream_Table_Script');DROP FUNCTION IF EXISTS ct."stpGetLastLoadStreamInfo";

CREATE or REPLACE FUNCTION ct."stpGetLastLoadStreamInfo" ()
RETURNS
  TABLE
      (
        "StreamId" bigint,
		"ClientId" INTEGER,
		"LoadStreamETLConfigId" INTEGER,
		"FromSyncDateUTC" timestamp,
		"ToSyncDateUTC" timestamp,
		"ProcessStartDateTime" timestamp,
		"ProcessEndDateTime" timestamp,
		"Status" character varying(10)		  
      ) AS $$      
BEGIN

    RETURN  QUERY
    SELECT  
		str."StreamId",
		str."ClientId",
		str."LoadStreamETLConfigId",
		str."FromSyncDateUTC",
		str."ToSyncDateUTC",
		str."ProcessStartDateTime",
		str."ProcessEndDateTime",
		str."Status"		  
    FROM ct."LoadStream" str
	ORDER BY "StreamId" DESC
	LIMIT 1;

END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('038_DW_AddClientId_Func_stpGetLastLoadStreamInfo_Script');
ALTER TABLE ct."LoadStream"
DROP COLUMN IF EXISTS ClientId;

ALTER TABLE ct."LoadStream"
DROP COLUMN IF EXISTS LoadStreamETLConfigId;


ALTER TABLE ct."LoadStream" ADD "ClientId" INTEGER;
ALTER TABLE ct."LoadStream" ADD "LoadStreamETLConfigId" INTEGER;

INSERT INTO public."DatabaseVersionHistory" VALUES ('039_DW_AddClientId_LoadStream_Table_Script');CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	)
    RETURNS TABLE("IntervalId" bigint, 
				  "InsertionDateTime" timestamp without time zone, 
				  "MonthlyRead" numeric, 
				  "Usage" numeric, 
				  "UsageDLF" numeric, 
				  "Demand" numeric, 
				  "DemandDLF" numeric, 
				  "DLP" numeric, 
				  "DLPSum" numeric, 
				  "DLPRation" numeric, 
				  "DLF" numeric, 
				  "StartDateTimeUTC" timestamp without time zone, 
				  "TradeDay" timestamp without time zone, 
				  "StartDateTimeLocal" timestamp without time zone, 
				  "EndDateTimeLocal" timestamp without time zone, 
				  "AccountNumber" integer, 
				  "MeterName" character varying, 
				  "ClientName" character varying,
				  "CustomerName" character varying,
				  "ControlAreaName" character varying,
				  "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
		FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		LEFT JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"()
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('040_DW_FixGetSettlementIntervalsWithoutCustomer_Script');-- FACTS WEATHER
DROP TABLE dw."FactWeather";


CREATE TABLE dw."FactWeather"
(
    "WeatherKey" BIGSERIAL,
    "InsertionDateTime" TIMESTAMP,
    "AgingDateTime" TIMESTAMP,	
	"WeatherObservationId" BIGINT,
    "StationKey" INT,
	"FactValueGoalKey" SMALLINT,	
	"FactStatusKey" SMALLINT,
	"ParentWeatherKey" BIGINT,	
	"EndDateTimeUTC" TIMESTAMP ,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT,
    "oC" INT,
    "oF" INT,
    "Humidity" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactWeather" IS 'Weather Fact Table';


--2015
CREATE TABLE dw.weather_y2015m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.weather_y2015m06 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m06 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m06 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2015m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.weather_y2015m07 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m07 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m07 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2015m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.weather_y2015m08 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m08 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m08 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2015m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.weather_y2015m09 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m09 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m09 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2015m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.weather_y2015m10 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m10 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m10 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2015m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.weather_y2015m11 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m11 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m11 ("EndDateUTCKey");






CREATE TABLE dw.weather_y2015m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.weather_y2015m12 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2015m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2015m12 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2015m12 ("EndDateUTCKey");





--2016
CREATE TABLE dw.weather_y2016m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.weather_y2016m01 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m01 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m01 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.weather_y2016m02 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m02 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m02 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2016m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.weather_y2016m03 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m03 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m03 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.weather_y2016m04 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m04 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m04 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.weather_y2016m05 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m05 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m05 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.weather_y2016m06 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m06 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m06 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.weather_y2016m07 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m07 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m07 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.weather_y2016m08 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m08 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m08 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.weather_y2016m09 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m09 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m09 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2016m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.weather_y2016m10 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m10 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m10 ("EndDateUTCKey");





CREATE TABLE dw.weather_y2016m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.weather_y2016m11 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m11 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m11 ("EndDateUTCKey");





CREATE TABLE dw.weather_y2016m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.weather_y2016m12 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2016m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2016m12 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2016m12 ("EndDateUTCKey");




--2017
CREATE TABLE dw.weather_y2017m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.weather_y2017m01 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m01 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m01 ("EndDateUTCKey");





CREATE TABLE dw.weather_y2017m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.weather_y2017m02 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m02 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m02 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.weather_y2017m03 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m03 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m03 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.weather_y2017m04 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m04 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m04 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.weather_y2017m05 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m05 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m05 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.weather_y2017m06 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m06 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m06 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.weather_y2017m07 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m07 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m07 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.weather_y2017m08 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m08 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m08 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.weather_y2017m09 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m09 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m09 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.weather_y2017m10 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m10 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m10 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.weather_y2017m11 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m11 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m11 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2017m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.weather_y2017m12 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2017m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2017m12 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2017m12 ("EndDateUTCKey");




--2018
CREATE TABLE dw.weather_y2018m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.weather_y2018m01 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m01 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m01 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2018m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.weather_y2018m02 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m02 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m02 ("EndDateUTCKey");


CREATE TABLE dw.weather_y2018m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.weather_y2018m03 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m03 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m03 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2018m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.weather_y2018m04 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m04 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m04 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.weather_y2018m05 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m05 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m05 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.weather_y2018m06 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m06 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m06 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.weather_y2018m07 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m07 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m07 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.weather_y2018m08 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m08 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m08 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.weather_y2018m09 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m09 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m09 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.weather_y2018m10 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m10 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m10 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.weather_y2018m11 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m11 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m11 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2018m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.weather_y2018m12 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2018m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2018m12 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2018m12 ("EndDateUTCKey");




--2019
CREATE TABLE dw.weather_y2019m01 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.weather_y2019m01 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m01 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m01 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m01 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2019m02 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.weather_y2019m02 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m02 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m02 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m02 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m03 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.weather_y2019m03 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m03 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m03 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m03 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m04 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.weather_y2019m04 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m04 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m04 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m04 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m05 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.weather_y2019m05 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m05 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m05 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m05 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m06 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.weather_y2019m06 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m06 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m06 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m06 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m07 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.weather_y2019m07 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m07 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m07 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m07 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m08 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.weather_y2019m08 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m08 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m08 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m08 ("EndDateUTCKey");



CREATE TABLE dw.weather_y2019m09 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.weather_y2019m09 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m09 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m09 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m09 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m10 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.weather_y2019m10 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m10 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m10 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m10 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m11 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.weather_y2019m11 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m11 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m11 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m11 ("EndDateUTCKey");




CREATE TABLE dw.weather_y2019m12 PARTITION OF dw."FactWeather"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.weather_y2019m12 ("EndDateUTCKey", "EndDateTimeUTC","FactStatusKey", "EndTimeUTCKey");
CREATE INDEX ON dw.weather_y2019m12 ("WeatherObservationId", "EndDateTimeUTC", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.weather_y2019m12 ("EndDateUTCKey" , "EndDateTimeUTC" , "StationKey" , "FactStatusKey");
CREATE INDEX ON dw.weather_y2019m12 ("EndDateUTCKey");



---------------------------------------------------------------------------------------------------------------------------------------------

-- FACT SETTLEMENT
DROP TABLE dw."FactIntervals_SETT";

CREATE TABLE dw."FactIntervals_SETT"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"MonthlyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,	
	"UsageDLF" NUMERIC(28,4),	
    "Demand" NUMERIC(28,4) ,    
	"DemandDLF" NUMERIC(28,4) ,        
    "DLP" NUMERIC(18,6),	
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),	
    "DLF" NUMERIC(18,7),    
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
    "AccountKey" INT,
    "SDPKey" INT ,
    "MeterKey" INT,
    "ChannelKey" INT,    
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
	"ServiceTypeKey" SMALLINT,
	"ParentIntervalKey" BIGINT,
	"FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateUTCKey" INT
)PARTITION BY RANGE ("EndDateUTCKey");
COMMENT ON TABLE dw."FactIntervals_SETT" IS 'Intervals Fact Table';


--2015
CREATE TABLE dw.intervals_y2015m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m06 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2015m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m07 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2015m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m08 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2015m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m09 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2015m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m10 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2015m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m11 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2015m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2015m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2015m12 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




--2016
CREATE TABLE dw.intervals_y2016m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m01 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m02 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m03 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m04 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m05 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m06 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m07 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m08 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m09 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m10 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m11 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2016m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2016m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2016m12 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



--2017
CREATE TABLE dw.intervals_y2017m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m01 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2017m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m02 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2017m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m03 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2017m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m04 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2017m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m05 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2017m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m06 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2017m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m07 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2017m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m08 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2017m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m09 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2017m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m10 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2017m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m11 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2017m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2017m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2017m12 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


--2018
CREATE TABLE dw.intervals_y2018m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m01 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m02 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m03 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m04 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m05 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m06 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m07 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m08 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m09 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");


CREATE TABLE dw.intervals_y2018m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m10 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2018m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m11 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2018m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2018m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2018m12 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



--2019
CREATE TABLE dw.intervals_y2019m01 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m01 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m01 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m02 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m02 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m02 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m03 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m03 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m03 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m04 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m04 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m04 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2019m05 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m05 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m05 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m06 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m06 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m06 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m07 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m07 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m07 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2019m08 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m08 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m08 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2019m09 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m09 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m09 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m10 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m10 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m10 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



CREATE TABLE dw.intervals_y2019m11 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m11 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m11 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");




CREATE TABLE dw.intervals_y2019m12 PARTITION OF dw."FactIntervals_SETT"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey", "EndTimeUTCKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateTimeUTC", "StartDateTimeUTC");
CREATE INDEX ON dw.intervals_y2019m12 ("SDPKey", "MeterKey","AccountKey","ChannelKey","FactStatusKey");
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey");
CREATE INDEX ON dw.intervals_y2019m12 ("EndDateUTCKey","EndDateTimeUTC","FactStatusKey","InsertionDateTime", "AgingDateTime");



---------------------------------------------------------------------------------------------------------------------------------------------

-- FACT OMDA
DROP TABLE dw."FactIntervals_OMDA";


-- FactIntervals
CREATE TABLE dw."FactIntervals_OMDA"
(
    "IntervalKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"IntervalTimeId" BIGINT,
    "Usage" NUMERIC(28,4) ,		
    "Demand" NUMERIC(28,4) ,    	   
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
	"Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
	"IsFirm" BOOLEAN,	
    "MarginalUsage" NUMERIC(28,4),
    "MarginalUsageCost" NUMERIC(28,4),	
	"MarginalDemand" NUMERIC(28,4),
    "MarginalDemandCost" NUMERIC(28,4),
	"ShowTotal" BOOLEAN,
	"StartAvail" TIMESTAMP,
    "LastAvail" TIMESTAMP,
	"IsDSTEnabled" BOOLEAN,
	"Back" TIMESTAMP,
    "Forward" TIMESTAMP,	
    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,    
    "SDPKey" INT ,
    "MeterKey" INT,
	"MeterSDPId" INT,
    "ChannelKey" INT,
    "CurrencyKey" SMALLINT,
    "OriginConsumptionKey" SMALLINT,
    "FactValueGoalKey" SMALLINT,
	"ServiceTypeKey" SMALLINT,
	"ParentIntervalKey" BIGINT,
	"FactStatusKey" SMALLINT,	
    "EndDateLocalKey" INT,
    "EndTimeLocalKey" SMALLINT,
    "EndDateUTCKey" INT,
    "EndTimeUTCKey" SMALLINT,
	"RecordedDateLocalKey" INT
	
)PARTITION BY RANGE ("EndDateLocalKey");
COMMENT ON TABLE dw."FactIntervals_OMDA" IS 'Intervals Fact Table';




--2015
CREATE TABLE dw.intervals_omda_y2015m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150601) TO (20150701);
CREATE INDEX ON dw.intervals_omda_y2015m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m06 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2015m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150701) TO (20150801);
CREATE INDEX ON dw.intervals_omda_y2015m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m07 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2015m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150801) TO (20150901);
CREATE INDEX ON dw.intervals_omda_y2015m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m08 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2015m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20150901) TO (20151001);
CREATE INDEX ON dw.intervals_omda_y2015m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m09 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2015m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20151001) TO (20151101);
CREATE INDEX ON dw.intervals_omda_y2015m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m10 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2015m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20151101) TO (20151201);
CREATE INDEX ON dw.intervals_omda_y2015m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m11 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2015m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20151201) TO (20160101);
CREATE INDEX ON dw.intervals_omda_y2015m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2015m12 ("EndDateLocalKey");





--2016
CREATE TABLE dw.intervals_omda_y2016m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160101) TO (20160201);
CREATE INDEX ON dw.intervals_omda_y2016m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m01 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2016m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160201) TO (20160301);
CREATE INDEX ON dw.intervals_omda_y2016m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m02 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2016m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160301) TO (20160401);
CREATE INDEX ON dw.intervals_omda_y2016m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m03 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2016m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160401) TO (20160501);
CREATE INDEX ON dw.intervals_omda_y2016m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m04 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2016m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160501) TO (20160601);
CREATE INDEX ON dw.intervals_omda_y2016m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m05 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2016m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160601) TO (20160701);
CREATE INDEX ON dw.intervals_omda_y2016m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m06 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2016m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160701) TO (20160801);
CREATE INDEX ON dw.intervals_omda_y2016m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m07 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2016m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160801) TO (20160901);
CREATE INDEX ON dw.intervals_omda_y2016m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m08 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2016m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20160901) TO (20161001);
CREATE INDEX ON dw.intervals_omda_y2016m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m09 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2016m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20161001) TO (20161101);
CREATE INDEX ON dw.intervals_omda_y2016m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m10 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2016m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20161101) TO (20161201);
CREATE INDEX ON dw.intervals_omda_y2016m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m11 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2016m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20161201) TO (20170101);
CREATE INDEX ON dw.intervals_omda_y2016m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2016m12 ("EndDateLocalKey");





--2017
CREATE TABLE dw.intervals_omda_y2017m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170101) TO (20170201);
CREATE INDEX ON dw.intervals_omda_y2017m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m01 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2017m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170201) TO (20170301);
CREATE INDEX ON dw.intervals_omda_y2017m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m02 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2017m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170301) TO (20170401);
CREATE INDEX ON dw.intervals_omda_y2017m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m03 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2017m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170401) TO (20170501);
CREATE INDEX ON dw.intervals_omda_y2017m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m04 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2017m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170501) TO (20170601);
CREATE INDEX ON dw.intervals_omda_y2017m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m05 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2017m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170601) TO (20170701);
CREATE INDEX ON dw.intervals_omda_y2017m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m06 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2017m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170701) TO (20170801);
CREATE INDEX ON dw.intervals_omda_y2017m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m07 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2017m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170801) TO (20170901);
CREATE INDEX ON dw.intervals_omda_y2017m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m08 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2017m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20170901) TO (20171001);
CREATE INDEX ON dw.intervals_omda_y2017m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m09 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2017m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20171001) TO (20171101);
CREATE INDEX ON dw.intervals_omda_y2017m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m10 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2017m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20171101) TO (20171201);
CREATE INDEX ON dw.intervals_omda_y2017m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m11 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2017m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20171201) TO (20180101);
CREATE INDEX ON dw.intervals_omda_y2017m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2017m12 ("EndDateLocalKey");






--2018
CREATE TABLE dw.intervals_omda_y2018m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180101) TO (20180201);
CREATE INDEX ON dw.intervals_omda_y2018m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m01 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180201) TO (20180301);
CREATE INDEX ON dw.intervals_omda_y2018m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m02 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2018m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180301) TO (20180401);
CREATE INDEX ON dw.intervals_omda_y2018m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m03 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180401) TO (20180501);
CREATE INDEX ON dw.intervals_omda_y2018m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m04 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180501) TO (20180601);
CREATE INDEX ON dw.intervals_omda_y2018m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m05 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180601) TO (20180701);
CREATE INDEX ON dw.intervals_omda_y2018m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m06 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180701) TO (20180801);
CREATE INDEX ON dw.intervals_omda_y2018m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m07 ("EndDateLocalKey");






CREATE TABLE dw.intervals_omda_y2018m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180801) TO (20180901);
CREATE INDEX ON dw.intervals_omda_y2018m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m08 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20180901) TO (20181001);
CREATE INDEX ON dw.intervals_omda_y2018m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m09 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2018m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20181001) TO (20181101);
CREATE INDEX ON dw.intervals_omda_y2018m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m10 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2018m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20181101) TO (20181201);
CREATE INDEX ON dw.intervals_omda_y2018m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m11 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2018m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20181201) TO (20190101);
CREATE INDEX ON dw.intervals_omda_y2018m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2018m12 ("EndDateLocalKey");




--2019
CREATE TABLE dw.intervals_omda_y2019m01 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190101) TO (20190201);
CREATE INDEX ON dw.intervals_omda_y2019m01 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m01 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2019m02 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190201) TO (20190301);
CREATE INDEX ON dw.intervals_omda_y2019m02 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m02 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m03 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190301) TO (20190401);
CREATE INDEX ON dw.intervals_omda_y2019m03 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m03 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m04 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190401) TO (20190501);
CREATE INDEX ON dw.intervals_omda_y2019m04 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m04 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2019m05 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190501) TO (20190601);
CREATE INDEX ON dw.intervals_omda_y2019m05 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m05 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m06 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190601) TO (20190701);
CREATE INDEX ON dw.intervals_omda_y2019m06 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m06 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m07 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190701) TO (20190801);
CREATE INDEX ON dw.intervals_omda_y2019m07 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m07 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m08 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190801) TO (20190901);
CREATE INDEX ON dw.intervals_omda_y2019m08 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m08 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m09 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20190901) TO (20191001);
CREATE INDEX ON dw.intervals_omda_y2019m09 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m09 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m10 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20191001) TO (20191101);
CREATE INDEX ON dw.intervals_omda_y2019m10 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m10 ("EndDateLocalKey");





CREATE TABLE dw.intervals_omda_y2019m11 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20191101) TO (20191201);
CREATE INDEX ON dw.intervals_omda_y2019m11 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m11 ("EndDateLocalKey");




CREATE TABLE dw.intervals_omda_y2019m12 PARTITION OF dw."FactIntervals_OMDA"
FOR VALUES FROM (20191201) TO (20200101);
CREATE INDEX ON dw.intervals_omda_y2019m12 ("EndDateLocalKey", "EndTimeLocalKey", "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("EndDateLocalKey", "EndDateTimeLocal" , "FactStatusKey" , "InsertionDateTime", "AgingDateTime");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("EndDateTimeLocal", "StartDateTimeLocal");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("SDPKey", "MeterKey","ChannelKey", "FactStatusKey");
CREATE INDEX ON dw.intervals_omda_y2019m12 ("EndDateLocalKey");


INSERT INTO public."DatabaseVersionHistory" VALUES ('041_DW_FactsTables_Indexes_Updated_Script');-- FactIntervals
DROP TABLE stg."FactIntervals";
CREATE TABLE stg."FactIntervals"
(
    "Omda_IntervalTimeId" BIGINT,
	"MonthlyRead" NUMERIC(28,4),
    "Usage" NUMERIC(28,4) ,
	"UsageDLF" NUMERIC(28,4),
    "Demand" NUMERIC(28,4) ,
	"DemandDLF" NUMERIC(28,4) ,
    "TCC" NUMERIC(28,4),
    "CBL" NUMERIC(28,4),
    "DLP" NUMERIC(18,6),
	"DLPSum" NUMERIC(18,6),
	"DLPRation" NUMERIC(18,6),
    "DLF" NUMERIC(18,7),
	"Price" NUMERIC(28,4),
    "PriceReduction" NUMERIC(28,4),
    "MarginalUsage" NUMERIC(28,4),
    "MarginalUsageCost" NUMERIC(28,4),

	"MarginalDemand" NUMERIC(28,4),
    "MarginalDemandCost" NUMERIC(28,4),

	"IsFirm" BOOLEAN ,
	"ShowTotal" BOOLEAN,
	"StartAvail" TIMESTAMP,
    "LastAvail" TIMESTAMP,
	"IsDSTEnabled" BOOLEAN,
	"Back" TIMESTAMP,
    "Forward" TIMESTAMP,	
    "MeterSDPId" INT,


    "StartDateTimeUTC" TIMESTAMP ,
    "EndDateTimeUTC" TIMESTAMP ,
	"StartDateTimeLocal" TIMESTAMP ,
    "EndDateTimeLocal" TIMESTAMP ,
	"ClientId" INT,
    "AccountId" INT,
    "SDPId" INT ,
    "DeviceCode" character varying(50),

	"MeterId"  character varying(50),

    "ChannelId" VARCHAR(100),
    "CurrencyCode" VARCHAR(3),
	"OriginConsumptionCode" VARCHAR(8),
	"ApplicationCode" varchar(4),
    "EndDateLocal" TIMESTAMP,
    "EndTimeLocal" VARCHAR(10),
    "EndDateUTC" TIMESTAMP,
    "EndTimeUTC" VARCHAR(10),
	"RecordedDateUTC" TIMESTAMP,
	"RecordedDateLocal" TIMESTAMP
);
COMMENT ON TABLE stg."FactIntervals" IS 'Intervals Staging Fact Table';
CREATE INDEX ON stg."FactIntervals" ("EndDateTimeUTC", "ApplicationCode");
CREATE INDEX ON stg."FactIntervals" ("EndDateTimeLocal", "ApplicationCode");
CREATE INDEX ON stg."FactIntervals" ("Omda_IntervalTimeId","EndDateTimeUTC", "ApplicationCode");
CREATE INDEX ON stg."FactIntervals" ("EndDateTimeUTC","SDPId","MeterId", "ChannelId","ApplicationCode");
CREATE INDEX ON stg."FactIntervals" ("EndDateTimeLocal","SDPId","MeterId", "ChannelId","ApplicationCode");




-- STP MERGE FACT OMDA - INITIAL LOADING ONLY
CREATE OR REPLACE FUNCTION etl."stpInitialLoadMergeFactIntervals"(
	"dailyStartDateLocal" timestamp without time zone,
	"dailyEndDateLocal" timestamp without time zone)
    RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
   dailyStartDateLocalKey INTEGER   := CAST (TO_CHAR("dailyStartDateLocal"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateLocalKey   INTEGER   := CAST (TO_CHAR("dailyEndDateLocal"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT     "IntervalKey"            as "dw_IntervalKey",
	  			 "SDPKey"                 as "dw_SDPKey",
                 "MeterKey"               as "dw_MeterKey",
                 "ChannelKey"             as "dw_ChannelKey",                 
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",                 
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"        as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"        as "dw_EndTimeLocalKey"                 
      FROM dw."FactIntervals_OMDA" fct     
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'	  
      WHERE     fct."EndDateLocalKey"   >= dailyStartDateLocalKey
            AND fct."EndDateLocalKey"   <= dailyEndDateLocalKey
            AND fct."EndDateTimeLocal"  >  "dailyStartDateLocal"
            AND fct."EndDateTimeLocal"  <= "dailyEndDateLocal"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
	        "Omda_IntervalTimeId"  as "stg_Omda_IntervalTimeId",
            "Usage"                as "stg_Usage",            
            "Demand"               as "stg_Demand",
            "TCC"                  as "stg_TCC",
            "CBL"                  as "stg_CBL",
            "Price"                as "stg_Price",
            "PriceReduction"       as "stg_PriceReduction",
            "IsFirm"      		   as "stg_IsFirm",
	  
            "MarginalUsage"        as "stg_MarginalUsage",
            "MarginalUsageCost"    as "stg_MarginalUsageCost",
            "MarginalDemand"       as "stg_MarginalDemand",
            "MarginalDemandCost"   as "stg_MarginalDemandCost",
            "ShowTotal"            as "stg_ShowTotal",
            "StartAvail"           as "stg_StartAvail",
            "LastAvail"            as "stg_LastAvail",
            fct."IsDSTEnabled"         as "stg_IsDSTEnabled",
            "Back"                 as "stg_Back",
            "Forward"              as "stg_Forward",
	  
	  
	  		"StartDateTimeUTC"     as "stg_StartDateTimeUTC",
	  	  	"EndDateTimeUTC"       as "stg_EndDateTimeUTC",
	  	  	"StartDateTimeLocal"   as "stg_StartDateTimeLocal",	  
	  	  	"EndDateTimeLocal"     as "stg_EndDateTimeLocal",
	  
	  	  	"SDPKey"               as "stg_SDPKey",
	  	  	"MeterKey"             as "stg_MeterKey",
	  	  	"MeterSDPId"           as "stg_MeterSDPId",
	  		"ChannelKey"           as "stg_ChannelKey",
	  	  	"CurrencyKey"          as "stg_CurrencyKey",	  		
	  	  	"ServiceTypeKey"       as "stg_ServiceTypeKey",	 
	  		"OriginConsumptionKey" as "stg_OriginConsumptionKey",
	  
			dateLocal."DateKey"    as "stg_EndDateLocalKey",
            dateUTC."DateKey"      as "stg_EndDateUTCKey",
            timeLocal."TimeKey"    as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"      as "stg_EndTimeUTCKey",
            recordedDate."DateKey" as "stg_RecordedDateKey"
	  
      FROM stg."FactIntervals" fct
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."MeterId" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE	  
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE           
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
	  JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
	  JOIN dw."DimPriceCurrency" currency
	    ON currency."CurrencyCode" = fct."CurrencyCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateLocal"
	  
      WHERE "EndDateTimeLocal"  > "dailyStartDateLocal" AND "EndDateTimeLocal" <= "dailyEndDateLocal" AND fct."ApplicationCode" = 'OMDA'
  )

    -- INSERT NEW FACTS
	  INSERT INTO dw."FactIntervals_OMDA"(		
		"InsertionDateTime",
		"AgingDateTime",
		"IntervalTimeId",
		"Usage",
		"Demand",
		"TCC",
		"CBL",
		"Price",
		"PriceReduction",
		"IsFirm",
		"MarginalUsage",
		"MarginalUsageCost",
		"MarginalDemand",
		"MarginalDemandCost",
		"ShowTotal",
		"StartAvail",
		"LastAvail",
		"IsDSTEnabled",
		"Back",
		"Forward",
		"StartDateTimeUTC",
		"EndDateTimeUTC",
		"StartDateTimeLocal",
		"EndDateTimeLocal",
		"SDPKey",
		"MeterKey",
		"MeterSDPId",
		"ChannelKey",
		"CurrencyKey",
		"OriginConsumptionKey",
		"FactValueGoalKey",
		"ServiceTypeKey",
		"ParentIntervalKey",
		"FactStatusKey",
		"EndDateLocalKey",
		"EndTimeLocalKey",
		"EndDateUTCKey",
		"EndTimeUTCKey",
		"RecordedDateLocalKey"
	)
    SELECT 
			  now()::timestamp,
			  NULL,
			  "stg_Omda_IntervalTimeId",
			  "stg_Usage",
			  "stg_Demand",
              "stg_TCC",
              "stg_CBL",
              "stg_Price",
              "stg_PriceReduction",
              "stg_IsFirm",	  
              "stg_MarginalUsage",
              "stg_MarginalUsageCost",
              "stg_MarginalDemand",
              "stg_MarginalDemandCost",
              "stg_ShowTotal",
              "stg_StartAvail",
              "stg_LastAvail",
              "stg_IsDSTEnabled",
              "stg_Back",
              "stg_Forward",	 	  
	  		  "stg_StartDateTimeUTC",
	  	  	  "stg_EndDateTimeUTC",
	  	  	  "stg_StartDateTimeLocal",	  
	  	  	  "stg_EndDateTimeLocal",	  
	  	  	  "stg_SDPKey",
	  	  	  "stg_MeterKey",
	  	  	  "stg_MeterSDPId",
	  		  "stg_ChannelKey",
	  	  	  "stg_CurrencyKey",	
			  "stg_OriginConsumptionKey",
			  1, --FACTVALUEGOALKEY(INITIAL),
			  "stg_ServiceTypeKey",
			  NULL, --PARENTINTERVALKEY,
			  1,--FACTSTATUSKEY(CURRENT),
			  "stg_EndDateLocalKey",
			  "stg_EndTimeLocalKey",
			  "stg_EndDateUTCKey",
			  "stg_EndTimeUTCKey",
			  "stg_RecordedDateKey"	  			  
    FROM      stg_facts_CTE fct_new
	LEFT JOIN dw_facts_CTE  fct_old
	ON        fct_new."stg_EndDateLocalKey" = fct_old."dw_EndDateLocalKey"
	      AND fct_new."stg_EndTimeLocalKey" = fct_old."dw_EndTimeLocalKey"
		  AND fct_new."stg_SDPKey"          = fct_old."dw_SDPKey"
		  AND fct_new."stg_MeterKey"        = fct_old."dw_MeterKey"
		  AND fct_new."stg_ChannelKey"      = fct_old."dw_ChannelKey"
    WHERE fct_old."dw_IntervalKey" IS NULL ;
	
	
	

  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$BODY$;
ALTER FUNCTION etl."stpInitialLoadMergeFactIntervals"(timestamp without time zone, timestamp without time zone)
OWNER TO postgres;





INSERT INTO public."DatabaseVersionHistory" VALUES ('042_DW_Staging_Facts_Script');CREATE OR REPLACE FUNCTION etl."MergeLocationData" () 
RETURNS void AS $$
BEGIN

   --UPDATE DATA 
   UPDATE dw."DimLocation" 
   SET 
   "City"  = stg_location."CityName",
   "StateProvinceAbbr" = stg_location."StateAbbreviation", 
   "StateProvinceName" = stg_location."StateName",
   "CountryAbbr" = stg_location."CountryAbbreviation",
   "EnglishCountryName" = stg_location."CountryName",
   "SpanishCountryName" = stg_location."CountryName"
  FROM stg."Location" stg_location
  WHERE stg_location."CityId" = dw."DimLocation"."LocationAlternateKey" ;
  
  
   -- INSERT NEW DATA
   INSERT INTO dw."DimLocation"("LocationAlternateKey", "City", "StateProvinceAbbr", "StateProvinceName", "CountryAbbr", "EnglishCountryName", "SpanishCountryName")
   SELECT "CityId", "CityName", "StateAbbreviation", "StateName", "CountryAbbreviation", "CountryName","CountryName"
   FROM stg."Location" stg_location
   LEFT JOIN dw."DimLocation" dw_location
   ON stg_location."CityId" = dw_location."LocationAlternateKey"
   WHERE dw_location."LocationAlternateKey" IS NULL ;

END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION etl."MergeStationData" () 
RETURNS void AS $$
BEGIN


    -- UPDATE DATA
	UPDATE dw."DimWeatherStation"
	SET 
	"Name" = stg_weather."Name"
	FROM stg."ObservationStation" stg_weather
	WHERE stg_weather."ObservationStationId" = dw."DimWeatherStation"."StationAlternateKey" ;
	
	-- INSERT NEW DATA
	INSERT INTO dw."DimWeatherStation"("StationAlternateKey", "Name")
	SELECT stg_weather."ObservationStationId", stg_weather."Name"
	FROM stg."ObservationStation" stg_weather
	LEFT JOIN dw."DimWeatherStation" dw_weather
	ON stg_weather."ObservationStationId" = dw_weather."StationAlternateKey" 
	WHERE dw_weather."StationAlternateKey" IS NULL ;


END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION etl."MergeTimezoneData" () 
RETURNS void AS $$
BEGIN

	--UPDATE DATA
	UPDATE dw."DimTimeZone"
	SET 
	"Abbreviation" = stg_Tz."Abbreviation", 
	"EnglishName"  = stg_Tz."Name",
	"SpanishName"  = stg_Tz."Name",
	"OffsetToGMT"  = stg_Tz."OffsetToGMT"	
	FROM stg."TimeZone" stg_Tz
	WHERE stg_Tz."TimeZoneId" = dw."DimTimeZone"."TimeZoneAlternateKey" ;
	
	
	
	--INSERT NEW DATA	
	INSERT INTO dw."DimTimeZone"("TimeZoneAlternateKey", "Abbreviation", "EnglishName", "SpanishName", "OffsetToGMT")
	SELECT stg_Tz."TimeZoneId",stg_Tz."Abbreviation", stg_Tz."Name", stg_Tz."Name",stg_Tz."OffsetToGMT"
	FROM stg."TimeZone" stg_Tz
	LEFT JOIN dw."DimTimeZone" dw_Tz
	ON dw_Tz."TimeZoneAlternateKey" = stg_Tz."TimeZoneId"
	WHERE dw_Tz."TimeZoneAlternateKey" IS NULL ;


END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION etl."MergeISOData" () 
RETURNS void AS $$
BEGIN
	
    --UPDATE DATA
	UPDATE dw."DimISO"
	SET  
	"ISOName" = stg_Ind."Name",
	"ISOEnglishDescription" = stg_Ind."Description" ,
	"ISOSpanishDescription" = stg_Ind."Description",
	"ISODefaultFormat" = 'N/A'
	FROM stg."IndSysOperator" stg_Ind 
	WHERE stg_Ind."IndSysOperatorId" = dw."DimISO"."ISOAlternateKey" ;
	
		
	--INSERT NEW DATA
	INSERT INTO dw."DimISO"("ISOAlternateKey", "ISOName", "ISOEnglishDescription", "ISOSpanishDescription", "ISODefaultFormat")	
	SELECT stg_Ind."IndSysOperatorId", stg_Ind."Name", stg_Ind."Description",stg_Ind."Description", 'N/A'
	FROM stg."IndSysOperator"  stg_Ind
	LEFT JOIN dw."DimISO" dw_Ind
	ON stg_Ind."IndSysOperatorId" = dw_Ind."ISOAlternateKey"
	WHERE dw_Ind."ISOAlternateKey" IS NULL ;


END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION etl."MergePowerTypeData" () 
RETURNS void AS $$
BEGIN

   --UPDATE DATA
   UPDATE dw."DimEnergyPowerType"
   SET 
   "EnglishEnergyPowerTypeDescription" = stg_Energ."Description",
   "SpanishPowerTypeDescription" = stg_Energ."Description"
   FROM stg."EnergyPowerType" stg_Energ
   WHERE stg_Energ."EnergyPowerTypeId" = dw."DimEnergyPowerType"."EnergyPowerTypeAlternateKey" ;
   
      
   --INSERT NEW DATA
	INSERT INTO dw."DimEnergyPowerType"("EnergyPowerTypeAlternateKey", "EnglishEnergyPowerTypeDescription", "SpanishPowerTypeDescription")
	SELECT "EnergyPowerTypeId", "Description", "Description"
	FROM stg."EnergyPowerType" stg_Energ
	LEFT JOIN dw."DimEnergyPowerType" dw_Energ
	ON stg_Energ."EnergyPowerTypeId" = dw_Energ."EnergyPowerTypeAlternateKey"
	WHERE dw_Energ."EnergyPowerTypeAlternateKey" IS NULL ;

END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION etl."MergeSDPData" () 
RETURNS void AS $$
BEGIN

	-- UPDATE DATA
	UPDATE dw."DimSDP"
	SET 
	"Address"                              = S."Address" ,
	"Address1"                             = S."Address1",
	"PostalCode"                           = S."PostalCode",
	"Longitude"                            = S."Longitude",
	"Latitude"                             = S."Latitude",
	"Name"                                 = S."Name",
	"IsVirtual"                            = S."IsVirtual",
	"LoadReductionPriceCode"               = S."LoadReductionPriceCode",
	"CustomerBaseLineAdjLoadReduction"     = S."CustomerBaseLineAdjustmentLoadReduction",
	"CustomerBaseLineAdjType"              = S."CustomerBaseLineAdjustmentType",
	"LocationKey"                          = L."LocationKey",
	"StationKey"                           = W."StationKey",
	"StartDateTime"                        = S."StartDateTime",
	"EndDateTime"                          = NULL,
	"Current"                              = TRUE
	FROM stg."SDP" S
	LEFT JOIN dw."DimLocation" L 
	ON S."CityId" = L."LocationAlternateKey"
	LEFT JOIN  dw."DimWeatherStation" W
	ON W."StationAlternateKey" = S."ObservationStationId"
	WHERE S."SDPId" = dw."DimSDP"."SDPAlternateKey" ;
	
	-- INSERT NEW DATA
	INSERT INTO dw."DimSDP"("SDPAlternateKey", "Address", "Address1", "PostalCode", "Longitude", "Latitude", "Name", "IsVirtual", "LoadReductionPriceCode", "CustomerBaseLineAdjLoadReduction", "CustomerBaseLineAdjType", "LocationKey", "StationKey", "StartDateTime", "EndDateTime", "Current")
	SELECT S."SDPId", S."Address", S."Address1", S."PostalCode", S."Longitude", S."Latitude", S."Name",  S."IsVirtual", S."LoadReductionPriceCode", S."CustomerBaseLineAdjustmentLoadReduction", S."CustomerBaseLineAdjustmentType",  L."LocationKey",  W."StationKey", S."StartDateTime", NULL, True 
	FROM stg."SDP" S
	LEFT JOIN dw."DimLocation" L 
	ON S."CityId" = L."LocationAlternateKey"
	LEFT JOIN  dw."DimWeatherStation" W
	ON W."StationAlternateKey" = S."ObservationStationId"
	LEFT JOIN dw."DimSDP" dw_Sdp
	ON S."SDPId" = dw_Sdp."SDPAlternateKey"
	WHERE dw_Sdp."SDPAlternateKey" IS NULL ;

END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION etl."MergeClientData" () 
RETURNS void AS $$
BEGIN

    --UPDATE DATA
	UPDATE dw."DimClient"
    SET 
	"ClientName"            = stg_client."Name",
	"LogoFileName"          = stg_client."LogoFileName",
	"LogoFileBinaryContent" = NULL ,
	"ClientUrl"             = stg_client."ClientUrl" ,
	"MonthsToRetain"        = stg_client."MonthsToRetain" , 
	"Duns"                  = stg_client."Duns"  ,
	"StartDateTime"         = stg_client."StartDateTime" ,
	"EndDateTime"           = NULL ,
	"Current"               = TRUE
	FROM stg."Client" stg_client
	WHERE stg_client."ClientId" = dw."DimClient"."ClientAlternateKey" ;

    --INSERT NEW DATA
	INSERT INTO dw."DimClient"("ClientAlternateKey", "ClientName", "LogoFileName", "LogoFileBinaryContent", "ClientUrl", "MonthsToRetain","Duns" , "StartDateTime", "EndDateTime", "Current")
	SELECT  stg_client."ClientId", stg_client."Name",stg_client."LogoFileName", NULL , stg_client."ClientUrl", stg_client."MonthsToRetain", stg_client."Duns" ,stg_client."StartDateTime", NULL, True
	FROM stg."Client" stg_client
	LEFT JOIN dw."DimClient" dw_client
	ON stg_client."ClientId" = dw_client."ClientAlternateKey"
	WHERE dw_client."ClientAlternateKey" IS NULL  ;

END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION etl."MergeCustomerData" () 
RETURNS void AS $$
BEGIN


	--UPDATE DATA
	UPDATE dw."DimCustomer"
	SET 
	"Name"            = stg_customer."Name",
	"StartDateTime"   = stg_customer."StartDateTime",
	"EndDateTime"     = NULL,
	"Current"         = TRUE
	FROM 
	(
			SELECT 
			CASE 
				WHEN "ApplicationCode" = 'OMDA' THEN "CustomerId"::text 
				WHEN "ApplicationCode" = 'SETT' THEN "Name"
			END AS "CustomerId",
			"ApplicationCode",
			"Name",
			"StartDateTime",
			NULL as "EndDateTime" ,
			TRUE as "Current"
		FROM stg."Customer"
	) stg_customer
	WHERE     stg_customer."CustomerId" = dw."DimCustomer"."CustomerAlternateKey" 
	      AND stg_customer."ApplicationCode" = dw."DimCustomer"."ApplicationCode" ;


   --INSERT NEW DATA
	INSERT INTO dw."DimCustomer"("CustomerAlternateKey", "ApplicationCode", "Name", "StartDateTime", "EndDateTime", "Current")
	SELECT stg_customer.*
	FROM 
	(
		SELECT 
			CASE 
				WHEN "ApplicationCode" = 'OMDA' THEN "CustomerId"::text 
				WHEN "ApplicationCode" = 'SETT' THEN "Name"
			END AS "CustomerId",
			"ApplicationCode",
			"Name",
			"StartDateTime",
			NULL::TIMESTAMP as "EndDateTime" ,
			TRUE as "Current"
		FROM stg."Customer" 
	) stg_customer	
	LEFT JOIN dw."DimCustomer" dw_customer
	ON      stg_customer."CustomerId" = dw_customer."CustomerAlternateKey"  
	    AND stg_customer."ApplicationCode" = dw_customer."ApplicationCode" 
	WHERE dw_customer."CustomerAlternateKey" IS NULL ;	



END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION etl."MergeControlAreaData" () 
RETURNS void AS $$
BEGIN


    -- UPDATE DATA
	UPDATE dw."DimControlArea"
	SET 
	"Name"          = C."Name",
	"Abbreviation"  = C."Abbreviation", 
	"Duns"          = C."Duns",
	"ISOKey"        = I."ISOKey"
	FROM stg."ControlArea" C
	LEFT JOIN dw."DimISO" I
	ON I."ISOAlternateKey" = C."IndSysOperatorId"
	WHERE C."ControlAreaId" = dw."DimControlArea"."ControlAreaAlternateKey" ;
	
			
	-- INSERT NEW DATA
	INSERT INTO dw."DimControlArea"("ControlAreaAlternateKey", "Name", "Abbreviation", "Duns", "ISOKey")
	SELECT C."ControlAreaId", C."Name", C."Abbreviation", C."Duns", I."ISOKey"
	FROM stg."ControlArea" C
	LEFT JOIN dw."DimISO" I
	ON I."ISOAlternateKey" = C."IndSysOperatorId"
	LEFT JOIN dw."DimControlArea" dw_controlArea
	ON C."ControlAreaId" =  dw_controlArea."ControlAreaAlternateKey"
	WHERE dw_controlArea."ControlAreaAlternateKey" IS NULL ;


END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION etl."MergeUomData" () 
RETURNS void AS $$
BEGIN


    -- UPDATE DATA
	UPDATE dw."DimUOM"
	SET 
	"EnglishDescription"        = U."Description",
	"SpanishDescription"        = U."Description",
	"Code"                      = U."Code",
	"UomFromMV90"               = U."UomFromMV90",
	"ConversionKey"             = U."UnitOfMeasureConversionId",
	"EnglishUomTypeDescription" = U."UomTypeDescription", 
	"SpanishUomTypeDescription" = U."UomTypeDescription",
	"EnergyPowerTypeKey"        = E."EnergyPowerTypeKey",
	"EDI867Code"                = U."EDI867Code"
	
	FROM stg."UnitOfMeasure" U
	LEFT JOIN dw."DimEnergyPowerType" E
	ON E."EnergyPowerTypeAlternateKey" = U."EnergyPowerTypeId"
	WHERE U."UnitOfMeasureId"  = dw."DimUOM"."UomAlternateKey" ;
	
	
	-- INSERT NEW DATA
	INSERT INTO dw."DimUOM"("UomAlternateKey", "EnglishDescription", "SpanishDescription", "Code", "UomFromMV90", "ConversionKey", "EnglishUomTypeDescription", "SpanishUomTypeDescription", "EnergyPowerTypeKey","EDI867Code")
	SELECT U."UnitOfMeasureId", U."Description",U."Description",U."Code", U."UomFromMV90",U."UnitOfMeasureConversionId",U."UomTypeDescription",U."UomTypeDescription", E."EnergyPowerTypeKey",U."EDI867Code"
	FROM stg."UnitOfMeasure" U
	LEFT JOIN dw."DimEnergyPowerType" E
	ON E."EnergyPowerTypeAlternateKey" = U."EnergyPowerTypeId"
    LEFT JOIN dw."DimUOM" dw_Uom
	ON U."UnitOfMeasureId" = dw_Uom."UomAlternateKey"
	WHERE dw_Uom."UomAlternateKey" IS NULL ;

	
END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION etl."MergeUomConversionData" () 
RETURNS void AS $$
BEGIN

	-- UPDATE DATA
	UPDATE dw."DimUOM"
	SET 
	"EnglishDescription"           =  U."Description",
	"SpanishDescription"           =  U."Description",
	"Code"                         =  U."Code",
	"UomFromMV90"                  =  U."UomFromMV90",
	"ConversionKey"                =  U2."UomKey",
	"EnglishUomTypeDescription"    =  U."UomTypeDescription",
	"SpanishUomTypeDescription"    =  U."UomTypeDescription",
	"EnergyPowerTypeKey"           =  E."EnergyPowerTypeKey",
	"EDI867Code"                   =  U."EDI867Code"	
	FROM stg."UnitOfMeasure" U
	LEFT JOIN dw."DimEnergyPowerType" E
	ON E."EnergyPowerTypeAlternateKey" = U."EnergyPowerTypeId"
	LEFT JOIN dw."DimUOM" U2 
	ON U2."UomAlternateKey" = U."UnitOfMeasureConversionId"
	WHERE U."UnitOfMeasureId" =  dw."DimUOM"."UomAlternateKey" ;
	
	
	-- INSERT NEW DATA
	INSERT INTO dw."DimUOM"("UomAlternateKey", "EnglishDescription", "SpanishDescription", "Code", "UomFromMV90", "ConversionKey", "EnglishUomTypeDescription", "SpanishUomTypeDescription", "EnergyPowerTypeKey","EDI867Code")
	SELECT  U."UnitOfMeasureId", U."Description",U."Description",U."Code", U."UomFromMV90",U2."UomKey",U."UomTypeDescription",U."UomTypeDescription", E."EnergyPowerTypeKey",U."EDI867Code"
	FROM stg."UnitOfMeasure" U
	LEFT JOIN dw."DimEnergyPowerType" E
	ON E."EnergyPowerTypeAlternateKey" = U."EnergyPowerTypeId"
	LEFT JOIN dw."DimUOM" U2 
	ON U2."UomAlternateKey" = U."UnitOfMeasureConversionId"
    LEFT JOIN dw."DimUOM" dw_Uom
	ON U."UnitOfMeasureId" = dw_Uom."UomAlternateKey"
	WHERE dw_Uom."UomAlternateKey" IS NULL ;

	
END;
$$ LANGUAGE plpgsql;




INSERT INTO public."DatabaseVersionHistory" VALUES ('043_DW_Merge_Dimensions_UpInsert_Script');--TRUNCATE ALL LOAD STREAM ENTITIES
TRUNCATE TABLE ct."Audit" CASCADE;
TRUNCATE TABLE ct."LoadCycle" CASCADE;
TRUNCATE TABLE ct."LoadStream" CASCADE;



-- ADD COLUMN STREAM_TYPE
ALTER TABLE ct."LoadStream"
DROP COLUMN IF EXISTS "StreamType";

ALTER TABLE ct."LoadStream" ADD "StreamType" VARCHAR (50);


ALTER TABLE ct."LoadStream"
DROP COLUMN IF EXISTS "IsInProgress";

ALTER TABLE ct."LoadStream" ADD "IsInProgress" boolean;



CREATE OR REPLACE FUNCTION etl."GetOrCreateDimensionStreamId"()
RETURNS TABLE
(
  "_StreamId" BIGINT
)
LANGUAGE plpgsql
AS $$
DECLARE "_nextDimStreamId" INTEGER  := 0;
BEGIN

	-- set default failedStatusId 
    SELECT  
			COALESCE ("StreamId", 0) into "_nextDimStreamId"  
	FROM ct."LoadStream" 
	where     "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime" IS NULL 
		  AND "StreamType" = 'Dimensions'
	ORDER BY "StreamId" DESC;


   IF "_nextDimStreamId" = 0 OR "_nextDimStreamId" IS NULL  THEN 
     RAISE NOTICE 'CREATE NEW STREAM';
	   INSERT INTO ct."LoadStream"("FromSyncDateUTC", "ToSyncDateUTC", "ProcessStartDateTime", "ProcessEndDateTime", "Status", "ClientId", "LoadStreamETLConfigId", "StreamType")
	   VALUES (date_trunc('day', now())::timestamp without time zone, date_trunc('day', now())::timestamp without time zone, NULL, NULL, NULL, NULL, NULL,'Dimensions'); 	
   ELSE
      RAISE NOTICE 'STREAM ALREADY EXISTS';
   END IF;

   	  	
	RETURN QUERY
	SELECT 
		"StreamId"
	FROM ct."LoadStream"
	where     "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime" IS NULL 
		  AND "StreamType" = 'Dimensions'
	ORDER BY "StreamId" DESC
	LIMIT 1;


END 
$$;






DROP FUNCTION IF EXISTS etl."GetStreamToProcess";

CREATE OR REPLACE FUNCTION etl."GetStreamToProcess"()
RETURNS TABLE("StreamId" bigint, "FromSyncDateUTC" timestamp without time zone, "ToSyncDateUTC" timestamp without time zone) 
LANGUAGE 'plpgsql'
COST 100
VOLATILE 
ROWS 1000
AS $BODY$

BEGIN	
	RETURN QUERY
	(
	  SELECT 
		ct."LoadStream"."StreamId",
        ct."LoadStream"."FromSyncDateUTC",
        ct."LoadStream"."ToSyncDateUTC"
	  FROM ct."LoadStream"
	  where   "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime"   IS NULL 
		  AND "StreamType" = 'Intervals'
		  AND "IsInProgress" = true

	  ORDER BY "StreamId" DESC
	);
END 

$BODY$;

ALTER FUNCTION etl."GetStreamToProcess"()
    OWNER TO postgres;




DROP FUNCTION IF EXISTS etl."UpdateStreamFinalStatusForAll";

CREATE OR REPLACE FUNCTION etl."UpdateStreamFinalStatusForAll"("statusETL" text)
RETURNS void
LANGUAGE 'plpgsql'

COST 100
VOLATILE 
AS $BODY$

BEGIN 

    UPDATE ct."LoadStream"
	SET "ProcessEndDateTime"= now()::timestamp,
		"Status"= "statusETL"
	WHERE 
		    ("Status" IS NULL OR "Status" = '')
		AND "IsInProgress" = true ;
	

END;

$BODY$;

ALTER FUNCTION etl."UpdateStreamFinalStatusForAll"(text)
    OWNER TO postgres;



INSERT INTO public."DatabaseVersionHistory" VALUES ('044_DW_ETL_Script');


DROP FUNCTION IF EXISTS etl."GetOrCreateDimensionStreamId";
CREATE OR REPLACE FUNCTION etl."GetOrCreateDimensionStreamId"()
RETURNS TABLE
(
  "_StreamId" BIGINT
)
LANGUAGE plpgsql
AS $$
DECLARE "_nextDimStreamId" INTEGER  := 0;
BEGIN

	-- set default failedStatusId 
    SELECT  
			COALESCE ("StreamId", 0) into "_nextDimStreamId"  
	FROM ct."LoadStream" 
	where     "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime" IS NULL 
		  AND "StreamType" = 'Dimensions'
	ORDER BY "StreamId" DESC;


   IF "_nextDimStreamId" = 0 OR "_nextDimStreamId" IS NULL  THEN 
     RAISE NOTICE 'CREATE NEW STREAM';
	   INSERT INTO ct."LoadStream"("FromSyncDateUTC", "ToSyncDateUTC", "ProcessStartDateTime", "ProcessEndDateTime", "Status", "ClientId", "LoadStreamETLConfigId", "StreamType", "IsInProgress")
	   VALUES (date_trunc('day', now())::timestamp without time zone, date_trunc('day', now())::timestamp without time zone, NULL, NULL, NULL, NULL, NULL,'Dimensions', true); 	
   ELSE
      RAISE NOTICE 'STREAM ALREADY EXISTS';
   END IF;

   	  	
	RETURN QUERY
	SELECT 
		"StreamId"
	FROM ct."LoadStream"
	where     "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime" IS NULL 
		  AND "StreamType" = 'Dimensions'
	ORDER BY "StreamId" DESC
	LIMIT 1;


END 
$$;






INSERT INTO public."DatabaseVersionHistory" VALUES ('045_DW_ETL_Script');--TRUNCATE ALL LOAD STREAM ENTITIES
TRUNCATE TABLE ct."Audit" CASCADE;
TRUNCATE TABLE ct."LoadCycle" CASCADE;
TRUNCATE TABLE ct."LoadStream" CASCADE;



ALTER TABLE ct."LoadStream"
DROP COLUMN IF EXISTS "ApplicationCode";

ALTER TABLE ct."LoadStream" ADD "ApplicationCode" varchar (4) NOT NULL DEFAULT 'SETT';


-- ADD COLUMN STREAM_TYPE
ALTER TABLE ct."LoadStream"
DROP COLUMN IF EXISTS "StreamType";

ALTER TABLE ct."LoadStream" ADD "StreamType" VARCHAR (50) NOT NULL DEFAULT 'Intervals';





DROP FUNCTION IF EXISTS etl."GetStreamToProcess";

CREATE OR REPLACE FUNCTION etl."GetIntervalsStreamToProcess"("_ApplicationCode" VARCHAR)
RETURNS TABLE
(
	"StreamId" bigint, 
	"FromSyncDateUTC" timestamp without time zone,
	"ToSyncDateUTC" timestamp without time zone,
	"ClientId" integer
) 
LANGUAGE 'plpgsql'
COST 100
VOLATILE 
ROWS 1000
AS $BODY$

BEGIN	
	RETURN QUERY
	(
	  SELECT 
		ct."LoadStream"."StreamId",
        ct."LoadStream"."FromSyncDateUTC",
        ct."LoadStream"."ToSyncDateUTC",
		ct."LoadStream"."ClientId"

	  FROM ct."LoadStream"
	  where   "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime"   IS NULL 
		  AND "StreamType" = 'Intervals'
		  AND "ApplicationCode" = "_ApplicationCode"
		  AND "IsInProgress" = true

	  ORDER BY "StreamId" DESC
	);
END 

$BODY$;



DROP FUNCTION IF EXISTS etl."GetOrCreateDimensionStreamId";
CREATE OR REPLACE FUNCTION etl."GetOrCreateStreamId"("_ApplicationCode" VARCHAR, "_StreamType" VARCHAR)
RETURNS TABLE
(
  "_StreamId" BIGINT
)
LANGUAGE plpgsql
AS $$
DECLARE "_nextStreamId" INTEGER  := 0;
BEGIN

    --Check for existing dimension stream
    SELECT  
			COALESCE ("StreamId", 0) into "_nextStreamId"  
	FROM ct."LoadStream" 
	where     "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime" IS NULL 
		  AND "StreamType" = "_StreamType"
		  AND "ApplicationCode" = "_ApplicationCode"

	ORDER BY "StreamId" DESC
	LIMIT 1;


   IF "_nextStreamId" = 0 OR "_nextStreamId" IS NULL  THEN 
     RAISE NOTICE 'CREATE NEW STREAM';
	   INSERT INTO ct."LoadStream"("FromSyncDateUTC", "ToSyncDateUTC", "ProcessStartDateTime", "ProcessEndDateTime", "Status", "ClientId", "LoadStreamETLConfigId", "StreamType", "IsInProgress","ApplicationCode")
	   VALUES (date_trunc('day', now())::timestamp without time zone, date_trunc('day', now())::timestamp without time zone, NULL, NULL, NULL, NULL, NULL,"_StreamType", true,"_ApplicationCode"); 	
   ELSE
      RAISE NOTICE 'STREAM ALREADY EXISTS';
   END IF;

   	  	
	RETURN QUERY
	SELECT 
		"StreamId"
	FROM ct."LoadStream"
	where     "ProcessStartDateTime" IS NULL 
	      AND "ProcessEndDateTime" IS NULL 
		  AND "StreamType" = "_StreamType"
	ORDER BY "StreamId" DESC
	LIMIT 1;


END 
$$;




DROP TABLE IF EXISTS dw."FactVirtualEntities" ;


-- FactVirtualEntities
CREATE TABLE dw."FactVirtualEntities"
(
    "VirtualEntityKey" BIGSERIAL ,
    "InsertionDateTime" TIMESTAMP ,		
	"AgingDateTime" TIMESTAMP ,	
	"VirtualEntityConfigId" INT ,
    "VirtualSDPKey" INT ,
    "VirtualMeterKey" INT,
    "SourceChannelKey" BIGINT,
	"VirtualChannelKey" BIGINT,
    "FactValueGoalKey" SMALLINT,
	"FactStatusKey" SMALLINT,
	"ParentVirtualEntityKey" BIGINT,		
    "IsNegative" BOOLEAN,
    "Factor" NUMERIC(18,2)
);
COMMENT ON TABLE dw."FactVirtualEntities" IS 'VirtualEntities Fact Table';
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_SDP           FOREIGN KEY ("VirtualSDPKey")       REFERENCES dw."DimSDP" ("SDPKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_METER         FOREIGN KEY ("VirtualMeterKey")     REFERENCES dw."DimMeter" ("MeterKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_ChanSource    FOREIGN KEY ("SourceChannelKey")    REFERENCES dw."DimChannel" ("ChannelKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_ChanVirtual   FOREIGN KEY ("VirtualChannelKey")   REFERENCES dw."DimChannel" ("ChannelKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_FactValueGoal FOREIGN KEY ("FactValueGoalKey")    REFERENCES dw."DimFactValueGoal" ("FactValueGoalKey");
ALTER TABLE dw."FactVirtualEntities" ADD CONSTRAINT FK_VirtualEntities_FactStatus    FOREIGN KEY ("FactStatusKey")       REFERENCES dw."DimFactStatus" ("FactStatusKey");

CREATE INDEX VirtualEntities_1_index ON dw."FactVirtualEntities"("VirtualEntityConfigId", "FactStatusKey");
CREATE INDEX VirtualEntities_2_index ON dw."FactVirtualEntities"("VirtualSDPKey", "VirtualMeterKey", "SourceChannelKey", "VirtualChannelKey", "FactStatusKey");
CREATE INDEX VirtualEntities_3_index ON dw."FactVirtualEntities"("VirtualEntityConfigId", "VirtualSDPKey", "VirtualMeterKey", "FactStatusKey");






INSERT INTO public."DatabaseVersionHistory" VALUES ('046_DW_ETL_Script');-- View: dw."vIntervals_SETT"

-- DROP VIEW dw."vIntervals_SETT";

CREATE OR REPLACE VIEW dw."vIntervals_SETT" AS
 SELECT "FactIntervals_SETT"."IntervalKey",
    "FactIntervals_SETT"."InsertionDateTime",
    "FactIntervals_SETT"."AgingDateTime",
    "FactIntervals_SETT"."MonthlyRead",
    "FactIntervals_SETT"."Usage",
    "FactIntervals_SETT"."UsageDLF",
    "FactIntervals_SETT"."Demand",
    "FactIntervals_SETT"."DemandDLF",
    "FactIntervals_SETT"."DLP",
    "FactIntervals_SETT"."DLPSum",
    "FactIntervals_SETT"."DLPRation",
    "FactIntervals_SETT"."DLF",
    "FactIntervals_SETT"."StartDateTimeUTC",
    "FactIntervals_SETT"."EndDateTimeUTC",
    "FactIntervals_SETT"."StartDateTimeLocal",
    "FactIntervals_SETT"."EndDateTimeLocal",
    "FactIntervals_SETT"."AccountKey",
    "FactIntervals_SETT"."SDPKey",
    "FactIntervals_SETT"."MeterKey",
    "FactIntervals_SETT"."ChannelKey",
    "FactIntervals_SETT"."OriginConsumptionKey",
    "FactIntervals_SETT"."FactValueGoalKey",
    "FactIntervals_SETT"."ServiceTypeKey",
    "FactIntervals_SETT"."ParentIntervalKey",
    "FactIntervals_SETT"."FactStatusKey",
    "FactIntervals_SETT"."EndDateLocalKey",
    "FactIntervals_SETT"."EndTimeLocalKey",
    "FactIntervals_SETT"."EndDateUTCKey",
    "FactIntervals_SETT"."EndTimeUTCKey",
    "FactIntervals_SETT"."RecordedDateUTCKey"
   FROM dw."FactIntervals_SETT";

ALTER TABLE dw."vIntervals_SETT"
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('047_vIntervals_Sett_Create_Scripts');
CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"("startDateTime" TIMESTAMP WITHOUT TIME ZONE, "endDateTime" TIMESTAMP WITHOUT TIME ZONE
	)
    RETURNS TABLE("IntervalId" bigint, 
				  "InsertionDateTime" timestamp without time zone, 
				  "MonthlyRead" numeric, 
				  "Usage" numeric, 
				  "UsageDLF" numeric, 
				  "Demand" numeric, 
				  "DemandDLF" numeric, 
				  "DLP" numeric, 
				  "DLPSum" numeric, 
				  "DLPRation" numeric, 
				  "DLF" numeric, 
				  "StartDateTimeUTC" timestamp without time zone, 
				  "TradeDay" timestamp without time zone, 
				  "StartDateTimeLocal" timestamp without time zone, 
				  "EndDateTimeLocal" timestamp without time zone, 
				  "AccountNumber" integer, 
				  "MeterName" character varying, 
				  "ClientName" character varying,
				  "CustomerName" character varying,
				  "ControlAreaName" character varying,
				  "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
		FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"()
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('048_DW_UpdateFunction_GetSettlementIntervals');
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals" ("startDateTime" timestamp without time zone,"endDateTime" timestamp without time zone);
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals" ();

CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"("startDateTime" timestamp without time zone,"endDateTime" timestamp without time zone)
RETURNS 
TABLE
(
	"IntervalId" bigint,
	"InsertionDateTime" timestamp without time zone,
	"MonthlyRead" numeric,
	"Usage" numeric,
	"UsageDLF" numeric,
	"Demand" numeric,
	"DemandDLF" numeric,
	"DLP" numeric,
	"DLPSum" numeric,
	"DLPRation" numeric,
	"DLF" numeric,
	"StartDateTimeUTC" timestamp without time zone,
	"TradeDay" timestamp without time zone,
	"StartDateTimeLocal" timestamp without time zone,
	"EndDateTimeLocal" timestamp without time zone,
	"AccountNumber" integer,
	"MeterName" character varying,
	"ClientName" character varying,
	"CustomerName" character varying,
	"ControlAreaName" character varying,
	"ChannelNumber" integer
) 
LANGUAGE 'plpgsql'
COST 100
VOLATILE 
ROWS 1000
AS $BODY$

DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startDateTime"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("endDateTime" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
BEGIN

	RETURN QUERY
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
		FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		LEFT JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
		
		WHERE     fis."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fis."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fis."EndDateTimeUTC"   >  "startDateTime"
              AND fis."EndDateTimeUTC"   <= "endDateTime"
	)
	SELECT * 
	FROM INTERVALS_DATA;
	
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone)
OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('049_DW_UpdateFunction_GetSettlementIntervals');-- FUNCTION: dw."procRptCompare2DaysByAllAccounts"(integer, character varying, timestamp without time zone, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccounts"(integer, character varying, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccounts"(
	"clientId" integer,
	"ISO_Name" character varying,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transDate1" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" timestamp without time zone, "TransDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" timestamp without time zone, "TransDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"tradeDayLocalBegin1"   Date   := "tradeDay1"::Date;  
"tradeDayLocalEnd1"     timestamp   := "tradeDay1"::timestamp + interval '1 day - 3ms';
"tradeDayLocalBegin2"   Date   := "tradeDay2"::Date;  
"tradeDayLocalEnd2"     timestamp   := "tradeDay2"::timestamp + interval '1 day - 3 ms';

BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   fct."EndDateTimeLocal",
       fct."InsertionDateTime",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."Usage") AS "hourlyUsageDLFApplied" 
	
	     FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
		WHERE fct."EndDateTimeLocal"::Date >= "tradeDayLocalBegin1"
              AND fct."EndDateTimeLocal" < "tradeDayLocalEnd1"
		      AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
	          AND iso."ISOName" = "ISO_Name"
	
			  AND status."Code" = 'CURRENT'
			  
			/*AND
                (
                  ("transDate1" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transDate1" IS NOT NULL AND (fct."InsertionDateTime"::Date <= "transDate1"::Date AND (status."Code" = 'CURRENT' OR fct."AgingDateTime"::Date <= "transDate1"::Date)))
				)*/	         
              	  
GROUP BY fct."EndDateTimeLocal",
       	 fct."InsertionDateTime",
       	 ca."Abbreviation",
         act."AccountNumber",
 	 	 fct."Usage"

),
tmp2 AS 
(																					  
SELECT
	   fct."EndDateTimeLocal",
       fct."InsertionDateTime",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."Usage") AS "hourlyUsageDLFApplied" 

	     FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	        WHERE fct."EndDateTimeLocal"::Date >= "tradeDayLocalBegin2"
              AND fct."EndDateTimeLocal" < "tradeDayLocalEnd2"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
		      AND iso."ISOName" = "ISO_Name"
	
			  AND status."Code" = 'CURRENT'
              
				/*AND
                (
                  ("transDate1" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transDate1" IS NOT NULL AND (fct."InsertionDateTime"::Date <= "transDate1"::Date AND (status."Code" = 'CURRENT' OR fct."AgingDateTime"::Date <= "transDate1"::Date)))
				)*/	      
	                
GROUP BY fct."EndDateTimeLocal",
       	 fct."InsertionDateTime",
       	 ca."Abbreviation",
         act."AccountNumber"			 
)

SELECT "clientId" as "ClientID",
	   TO_CHAR("day1"."EndDateTimeLocal",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "TradeDay1",
	   TO_CHAR("day1"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "TransDate1",
       day1."Abbreviation" AS ControlArea1, 
       day1."AccountNumber" AS Account1, 
       CAST(day1."hourlyUsageDLFApplied" / 1000 AS DECIMAL(28,7)) AS "Adj_Total1",
       CAST(day2."hourlyUsageDLFApplied" / 1000 AS DECIMAL(28,7)) AS "Adj_Total2",
	   TO_CHAR("day2"."EndDateTimeLocal",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "TransDate1", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
														         
       
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) / 1000 AS DECIMAL(28,7)) AS "Difference_Adj_"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
ORDER BY 11 DESC;

END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccounts"(integer, character varying, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;



INSERT INTO public."DatabaseVersionHistory" VALUES ('050_DW_procRptCompare2DaysByAllAccounts');-- FUNCTION: dw."procRptDailyTotals"(integer, character varying, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptDailyTotals"(integer, character varying, timestamp without time zone, timestamp without time zone);


-- FUNCTION: dw."procRptDailyTotals"(integer, character varying, timestamp without time zone, timestamp without time zone)

-- DROP FUNCTION dw."procRptDailyTotals"(integer, character varying, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptDailyTotals"(
	"clientId" integer,
	"ISO_Name" character varying,
	"tradeDayLocal" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Tradeday" Date, "TransactionDate" Date, "Account" character varying, "MeterID" character varying, "ControlArea" character varying, "RawDailyUsage" numeric(24,8), "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
  
"tradeDayLocalBegin"   Date   := "tradeDayLocal"::Date;  
"tradeDayLocalEnd"     timestamp   := "tradeDayLocal"::timestamp + interval '1 day - 3 ms';

BEGIN

    RETURN  QUERY
	
SELECT tmp."Tradeday"
	  ,tmp."TransactionDate" 
	  ,tmp."Account"
	  ,tmp."MeterID"
	  ,tmp."ControlArea"
	  ,SUM(tmp."RawDailyUsage")
	  ,tmp."IntervalReadings"
	  
	  
FROM (
SELECT "tradeDayLocal"::Date AS "Tradeday"
	  ,"transactionDate"::Date AS "TransactionDate" 
	  ,act."AccountNumber" AS "Account"
	  ,mt."DeviceCode" AS "MeterID"
	  ,ca."Abbreviation" AS "ControlArea"
	  ,fct."Usage" AS "RawDailyUsage"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings"
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"        
		JOIN dw."DimOriginFactValue" ofv
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"      
		JOIN dw."DimControlArea" ca																						
		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
		JOIN dw."DimMeter" mt
		  ON mt."MeterKey" = fct."MeterKey"  
			
	    WHERE cli."ClientAlternateKey" = "clientId"
      		AND fct."EndDateTimeLocal"::Date = "tradeDayLocalBegin"
	   		And fct."EndDateTimeLocal" < "tradeDayLocalEnd" 
			AND fct."InsertionDateTime"::Date = "transactionDate"::Date
            AND serv."Code" = 'SETT'
            AND act."ApplicationCode" = 'SETT'
			AND iso."ISOName" = "ISO_Name"
           
 			AND status."Code" = 'CURRENT'
)tmp			
			/*AND
            
              ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
              OR
              ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
            */
		GROUP BY tmp."Tradeday"
	  		 	 ,tmp."TransactionDate" 
	  		 	 ,tmp."Account"
	  		 	 ,tmp."MeterID"
	    	 	 ,tmp."ControlArea"
	  		 	 ,tmp."IntervalReadings"
			 
		ORDER BY tmp."Account"
	  			 ,tmp."MeterID"
	  			 ,tmp."ControlArea";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyTotals"(integer, character varying, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('051_DW_procRptDailyTotals');-- FUNCTION: dw."procRptMonthlyTotals"(integer, character varying, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptMonthlyTotals"(integer, character varying, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptMonthlyTotals"(
	"clientId" integer,
	"ISO_Name" character varying,
	"monthDate" timestamp without time zone)
    RETURNS TABLE("Account" character varying, "Adj_Consumption" numeric, "StartDate" timestamp without time zone, "EndDate" timestamp without time zone, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"som" Date := date_trunc('MONTH', "monthDate"::Date);
"eom" Date := date_trunc('MONTH', "monthDate"::Date) + INTERVAL '1 MONTH - 3 ms';

BEGIN

    RETURN  QUERY

SELECT act."AccountNumber" AS "Account"
	  ,SUM(fct."UsageDLF") AS "Adj_Consumption"
	  ,"som"::Timestamp AS "StartDate"
      ,"eom"::Timestamp AS "EndDate"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings" 

FROM dw."FactIntervals_SETT" fct 
		JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
		JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
		JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
	    JOIN dw."DimOriginFactValue" ofv
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"   
		JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" =  act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"   
		
WHERE	 fct."EndDateTimeLocal"::Date >= "som" 
			AND fct."EndDateTimeLocal"::Date <= "eom" 
			AND cli."ClientAlternateKey" = "clientId"
            AND serv."Code" = 'SETT'
            AND act."ApplicationCode" = 'SETT'
			AND iso."ISOName" = "ISO_Name"
	
 			AND status."Code" = 'CURRENT'
                  																	
												
GROUP BY act."AccountNumber", ofv."OriginValueEnglishDescription"
ORDER BY act."AccountNumber";
		
	
END;
$BODY$;

ALTER FUNCTION dw."procRptMonthlyTotals"(integer, character varying, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('052_DW_procRptMonthlyTotals');-- DROP FUNCTION dw."procRptDailyDetailData"(integer, character varying, timestamp without time zone, timestamp without time zone);
DROP FUNCTION IF EXISTS dw."procRptDailyDetailData"(integer, character varying, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptDailyDetailData"(
	"clientId" integer,
	"ISO_Name" character varying,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone)
    RETURNS TABLE("TradeDay1" Date, "TransDate1" Date, "Abbreviation1" character varying, "Adj_Consumption" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
BEGIN

    RETURN  QUERY

SELECT 
	   tmp."tradeDay1",
	   tmp."transDate1",
	   tmp."Abbreviation1",
       SUM(tmp."Adj_Consumption") 
	  
	FROM(
 SELECT   fct."EndDateTimeLocal"::Date  AS "tradeDay1",
	   		fct."InsertionDateTime"::Date AS "transDate1",
	   		ca."Abbreviation" AS "Abbreviation1",
       		fct."Usage" AS "Adj_Consumption"
   
   FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"   																									
	        
			WHERE cli."ClientAlternateKey" = "clientId"
			  AND fct."EndDateTimeLocal"::Date >= "tradeDay1"::Date
			  AND fct."EndDateTimeLocal"::Date <= "tradeDay2"::Date
			  AND serv."Code" = 'SETT'
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOName" = "ISO_Name"
			  	
			  AND status."Code" = 'CURRENT'
   
   )tmp
			 /* AND
                (
                  ("transDate1" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transDate1" IS NOT NULL AND (fct."InsertionDateTime"::Date <= "transDate1"::Date AND (status."Code" = 'CURRENT' OR fct."AgingDateTime"::Date >= "transDate1"::Date)))
				)*/						
	
GROUP BY tmp."tradeDay1",
	   	 tmp."transDate1",
	     tmp."Abbreviation1"
	     
ORDER BY tmp."tradeDay1",
	   	 tmp."transDate1",
	     tmp."Abbreviation1";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyDetailData"(integer, character varying, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('054_DW_procRptDailyDetailData');-- FUNCTION: dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptMonthlyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"monthDate" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Account" character varying, "Adj_Consumption" numeric, "StartDate" timestamp without time zone, "EndDate" timestamp without time zone, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("monthDate"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("monthDate" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "monthDate" + interval '1' day;	  

"som" Date := date_trunc('MONTH', "monthDate"::Date);
"eom" timestamp := date_trunc('MONTH', "monthDate"::timestamp) + INTERVAL '1 MONTH - 3 ms';

BEGIN

    RETURN  QUERY

SELECT act."AccountNumber" AS "Account"
	  ,SUM(fct."UsageDLF") AS "Adj_Consumption"
	  ,"som"::Timestamp AS "StartDate"
      ,"eom"::Timestamp AS "EndDate"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings" 

FROM dw."FactIntervals_SETT" fct 
		JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
		JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
		JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
	    JOIN dw."DimOriginFactValue" ofv 
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"   
		JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" =  act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"   
		
WHERE   fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "monthDate"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id" 
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )													 														
												
GROUP BY act."AccountNumber", ofv."OriginValueEnglishDescription"
ORDER BY act."AccountNumber";
		
	
END;
$BODY$;

ALTER FUNCTION dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

		
INSERT INTO public."DatabaseVersionHistory" VALUES ('055_DW_procRptMonthlyTotals');-- FUNCTION: dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptDailyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"startTradeDayUTC" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Tradeday" date, "TransactionDate" timestamp without time zone, "Account" character varying, "MeterID" character varying, "ControlArea" character varying, "RawDailyUsage" numeric, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
   
"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;	  

--"tradeDayBegin"   Date   := "startTradeDayUTC"::Date;  
--"tradeDayEnd"     timestamp   := "startTradeDayUTC"::timestamp + interval '1 day - 3 ms';

BEGIN

    RETURN  QUERY
	
SELECT tmp."Tradeday"
	  ,tmp."TransactionDate" 
	  ,tmp."Account"
	  ,tmp."MeterID"
	  ,tmp."ControlArea"
	  ,SUM(tmp."RawDailyUsage")
	  ,tmp."IntervalReadings"
	  
	  
FROM (
SELECT "startTradeDayUTC"::Date AS "Tradeday"
	  ,"transactionDate" AS "TransactionDate" 
	  ,act."AccountNumber" AS "Account"
	  ,mt."DeviceCode" AS "MeterID"
	  ,ca."Abbreviation" AS "ControlArea"
	  ,fct."Usage" AS "RawDailyUsage"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings"

FROM dw."FactIntervals_SETT" fct 
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"        
		JOIN dw."DimOriginFactValue" ofv
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"      
		JOIN dw."DimControlArea" ca																						
		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
		JOIN dw."DimMeter" mt
		  ON mt."MeterKey" = fct."MeterKey"  
			
	    WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
	
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
)tmp			
			
		GROUP BY tmp."Tradeday"
	  		 	 ,tmp."TransactionDate" 
	  		 	 ,tmp."Account"
	  		 	 ,tmp."MeterID"
	    	 	 ,tmp."ControlArea"
	  		 	 ,tmp."IntervalReadings"
			 
		ORDER BY tmp."Account"
	  			 ,tmp."MeterID"
	  			 ,tmp."ControlArea";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('056_DW_procRptDailyTotals');-- FUNCTION: dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccounts"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "tradeDay1"
			  AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey2"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey2"
              AND fct."EndDateTimeUTC"  >=  "tradeDay2"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC2"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
       	  fct."InsertionDateTime"::Date,
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   tmpResult."Account1",
				   SUM(tmpResult."Adj_Total1"),
				   SUM(tmpResult."Adj_Total2"),
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   tmpResult."Account2",
				   SUM(tmpResult."Difference_Adj_1")
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	   	 tmpResult."Account1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2",
	     tmpResult."Account2"
	    
				
ORDER BY tmpResult."Account1", tmpResult."Account2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('057_DW_procRptCompare2DaysByAllAccounts');--CREATE OR REPLACE FUNCTION dw."stpGetCommercialChannelsData"(
--"StartDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"EndDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"Skip" INTEGER,
--"Limit" INTEGER
--)
--    RETURNS TABLE("ChannelKey" INTEGER, "IntervalsPerHour" SMALLINT) 
--    LANGUAGE 'plpgsql'

--    COST 100
--    VOLATILE 
--    ROWS 1000
--AS $BODY$

--DECLARE
--    "_StartDateUTCKey" INTEGER := CAST (TO_CHAR("StartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
--    "_EndDateUTCKey" INTEGER   := CAST (TO_CHAR(("EndDateUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
--BEGIN
--	RETURN QUERY 
--	SELECT DISTINCT fct."ChannelKey", dc."IntervalsPerHour" FROM dw."FactIntervals_SETT" fct
--	JOIN dw."DimChannel" dc
--	  ON fct."ChannelKey" = dc."ChannelKey"
--	JOIN dw."DimFactStatus" status
--	  ON status."FactStatusKey" = fct."FactStatusKey"
--	WHERE  fct."EndDateUTCKey" >= "_StartDateUTCKey"
--	AND fct."EndDateUTCKey" <= "_EndDateUTCKey"
--	AND status."Code" = 'CURRENT'
--	ORDER BY "ChannelKey"
--	LIMIT "Limit" OFFSET "Skip";
--END;

--$BODY$;

--ALTER FUNCTION dw."stpGetCommercialChannelsData"()
--    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('058_DW_stpGetCommercialChannelsData');--CREATE OR REPLACE FUNCTION dw."stpGetResidentialChannelsData"(
--"StartDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"EndDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"Skip" INTEGER,
--"Limit" INTEGER
--)
--    RETURNS TABLE("ChannelKey" INTEGER, "IntervalsPerHour" SMALLINT) 
--    LANGUAGE 'plpgsql'

--    COST 100
--    VOLATILE 
--    ROWS 1000
--AS $BODY$

--DECLARE
--    "_StartDateUTCKey" INTEGER := CAST (TO_CHAR("StartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
--    "_EndDateUTCKey" INTEGER   := CAST (TO_CHAR(("EndDateUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
--BEGIN
--	RETURN QUERY 
--	SELECT DISTINCT fct."ChannelKey", dc."IntervalsPerHour" FROM dw."FactIntervals_SETT" fct
--	JOIN dw."DimChannel" dc
--	  ON fct."ChannelKey" = dc."ChannelKey"
--	JOIN dw."DimFactStatus" status
--	  ON status."FactStatusKey" = fct."FactStatusKey"
--	WHERE  fct."EndDateUTCKey" >= "_StartDateUTCKey"
--	AND fct."EndDateUTCKey" <= "_EndDateUTCKey"
--	AND status."Code" = 'CURRENT'
--	ORDER BY "ChannelKey"
--	LIMIT "Limit" OFFSET "Skip";
--END;

--$BODY$;

--ALTER FUNCTION dw."stpGetResidentialChannelsData"()
--    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('059_DW_stpGetResidentialChannelsData');--CREATE OR REPLACE FUNCTION dw."stpGetCommercialChannelIntervalsData"(
--"_StartDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"_EndDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"_LastExecutionDateUTC" TIMESTAMP WITHOUT TIME ZONE,
--"_ChannelKey" INTEGER
--)
--    RETURNS TABLE("EndDateTimeUTC" TIMESTAMP WITHOUT TIME ZONE,
--	"Value" numeric(28,4),
--	"Temperature" INTEGER,
--	"Humidity" INTEGER
--	) 
--    LANGUAGE 'plpgsql'

--    COST 100
--    VOLATILE 
--    ROWS 1000
--AS $BODY$

--DECLARE
--    "_StartDateUTCKey" INTEGER := CAST (TO_CHAR("_StartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
--    "_EndDateUTCKey" INTEGER   := CAST (TO_CHAR(("_EndDateUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
--BEGIN
--	RETURN QUERY 
--	SELECT fct."EndDateTimeUTC", fct."DemandDLF" AS "Value", null::INTEGER AS "Temperature", null::INTEGER AS "Humidity"
--	FROM dw."FactIntervals_SETT" fct
--	JOIN dw."DimFactStatus" status
--	  ON status."FactStatusKey" = fct."FactStatusKey"
--	WHERE  fct."EndDateUTCKey" >= "_StartDateUTCKey"
--	  AND fct."EndDateUTCKey" <= "_EndDateUTCKey"
--	  AND fct."EndDateTimeUTC" >  "_StartDateUTC"
--	  AND fct."EndDateTimeUTC" <=  "_EndDateUTC"
--	  AND fct."ChannelKey" = "_ChannelKey"
--	  AND status."Code" = 'CURRENT'
--	  AND (
--		   ("_LastExecutionDateUTC" IS NULL) OR 
--		   ( "_LastExecutionDateUTC" IS NOT NULL AND fct."ParentIntervalKey" IS NOT NULL) OR
--		   ( "_LastExecutionDateUTC" IS NOT NULL AND fct."ParentIntervalKey" IS NULL AND fct."EndDateTimeUTC" > "_LastExecutionDateUTC" AND fct."EndDateTimeUTC" <= "_EndDateUTC")
--		  )
--	ORDER BY fct."EndDateTimeUTC";
--END;

--$BODY$;


--ALTER FUNCTION dw."stpGetCommercialChannelIntervalsData"()
--    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('060_DW_stpGetCommercialChannelIntervalsData');--CREATE OR REPLACE FUNCTION dw."stpGetResidentialChannelIntervalsData"(
--"_StartDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"_EndDateUTC" TIMESTAMP WITHOUT TIME ZONE, 
--"_LastExecutionDateUTC" TIMESTAMP WITHOUT TIME ZONE,
--"_ChannelKey" INTEGER
--)
--    RETURNS TABLE("EndDateTimeUTC" TIMESTAMP WITHOUT TIME ZONE,
--	"Value" numeric(28,4),
--	"Temperature" INTEGER,
--	"Humidity" INTEGER
--	) 
--    LANGUAGE 'plpgsql'

--    COST 100
--    VOLATILE 
--    ROWS 1000
--AS $BODY$

--DECLARE
--    "_StartDateUTCKey" INTEGER := CAST (TO_CHAR("_StartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
--    "_EndDateUTCKey" INTEGER   := CAST (TO_CHAR(("_EndDateUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
--BEGIN
--	RETURN QUERY 
--	SELECT fct."EndDateTimeUTC", fct."DemandDLF" AS "Value", null::INTEGER AS "Temperature", null::INTEGER AS "Humidity"
--	FROM dw."FactIntervals_SETT" fct
--	JOIN dw."DimFactStatus" status
--	  ON status."FactStatusKey" = fct."FactStatusKey"
--	WHERE  fct."EndDateUTCKey" >= "_StartDateUTCKey"
--	  AND fct."EndDateUTCKey" <= "_EndDateUTCKey"
--	  AND fct."EndDateTimeUTC" >  "_StartDateUTC"
--	  AND fct."EndDateTimeUTC" <=  "_EndDateUTC"
--	  AND fct."ChannelKey" = "_ChannelKey"
--	  AND status."Code" = 'CURRENT'
--	  AND (
--		   ("_LastExecutionDateUTC" IS NULL) OR 
--		   ( "_LastExecutionDateUTC" IS NOT NULL AND fct."ParentIntervalKey" IS NOT NULL) OR
--		   ( "_LastExecutionDateUTC" IS NOT NULL AND fct."ParentIntervalKey" IS NULL AND fct."EndDateTimeUTC" > "_LastExecutionDateUTC" AND fct."EndDateTimeUTC" <= "_EndDateUTC")
--		  )
--	ORDER BY fct."EndDateTimeUTC";
--END;

--$BODY$;


--ALTER FUNCTION dw."stpGetCommercialChannelIntervalsData"()
--    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('061_DW_stpGetResidentialChannelIntervalsData');DROP FUNCTION IF EXISTS ct."stpGetLastLoadStreamInfo";

CREATE or REPLACE FUNCTION ct."stpGetLastLoadStreamInfo" ("_applicationCode" varchar, "_streamType" varchar)
RETURNS
  TABLE
      (
        "StreamId" bigint,
		"ClientId" INTEGER,
		"LoadStreamETLConfigId" INTEGER,
		"FromSyncDateUTC" timestamp,
		"ToSyncDateUTC" timestamp,
		"ProcessStartDateTime" timestamp,
		"ProcessEndDateTime" timestamp,
		"Status" character varying(10)		  
      ) AS $$      
BEGIN

    RETURN  QUERY
    SELECT  
		str."StreamId",
		str."ClientId",
		str."LoadStreamETLConfigId",
		str."FromSyncDateUTC",
		str."ToSyncDateUTC",
		str."ProcessStartDateTime",
		str."ProcessEndDateTime",
		str."Status"		  
    FROM  ct."LoadStream" str
	WHERE str."ApplicationCode" = "_applicationCode" 
	AND   str."StreamType"      = "_streamType" 

	ORDER BY "StreamId" DESC
	LIMIT 1;

END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('062_DW_AddClientId_Func_stpGetLastLoadStreamInfo_Script');

-----------------------------------------------------------------------
DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals_SETT";
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT";

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );


  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

---------------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('063_DW_ETL_SchemaChange_Create_Scripts');CREATE SCHEMA IF NOT EXISTS etl ;


CREATE OR REPLACE FUNCTION etl."InsertNewLoadCycle" ("_streamId" integer, "_envCode" text , "_sourceSchema" text , "_destSchema" text, "_loadType" text) 
RETURNS void AS $$
BEGIN
   
 INSERT INTO ct."LoadCycle"
 (
	 "EnvCode",
	 "SourceSchema",
	 "DestinationSchema",
	 "LoadType",
	 "StartingDateTime",
	 "EndDateTime",
	 "Status",
	 "StreamId"
 )
 VALUES ("_envCode","_sourceSchema", "_destSchema", "_loadType", clock_timestamp(), NULL, NULL,"_streamId" );

END;
$$ LANGUAGE plpgsql;


INSERT INTO public."DatabaseVersionHistory" VALUES ('064_DW_ETL_Create_Scripts');
TRUNCATE dw."DimAccount" CASCADE;


---------------------------------------------------------------

CREATE OR REPLACE FUNCTION etl."MergeAccountData"()
RETURNS void
LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
AS $BODY$

BEGIN

			INSERT INTO  etl.ACCOUNT_TEMP  
			SELECT ACC_TEMP.*, Cust."CustomerKey" as "InsertionCustomerKey"
			FROM 
			(
					SELECT 
						"AccountId",
						"CustomerId",
						"CustomerName",
						CASE 
							WHEN  ASrc."ApplicationCode"= 'OMDA'  THEN "CustomerId"::text
							ELSE "CustomerName"
						END AS "CustomerAlternateId",
						"ClientId",
						CL."ClientKey" as "InsertionClientKey",
						ASrc."AccountNumber",
						ASrc."PremiseNumber",
						"ControlAreaId",
						CA."ControlAreaKey" as "InsertionControlAreaKey",
						"TimeZoneId",
						TZ."TimeZoneKey" as "InsertionTimeZoneKey",
						ASrc."ClientAccountKey",
						ASrc."ApplicationCode",
						ASrc."StartActiveDateTimeUTC",
						ASrc."EndActiveDateTimeUTC",
						ASrc."StartActiveDateTimeLocal",
						ASrc."EndActiveDateTimeLocal",
						ASrc."StartDateTime",
						ADes."AccountKey",
						ADes."ClientKey"      

				FROM stg."Account" ASrc
				LEFT JOIN dw."DimAccount" ADes
				ON ASrc."AccountId" = ADes."AccountAlternateKey"  AND ASrc."ApplicationCode" = ADes."ApplicationCode" AND ADes."Current" = TRUE
				LEFT JOIN dw."DimClient" CL
				ON CL."ClientAlternateKey" = ASrc."ClientId" AND CL."Current" =  TRUE
				LEFT JOIN dw."DimControlArea" CA
				ON CA."ControlAreaAlternateKey" = ASrc."ControlAreaId"
				LEFT JOIN dw."DimTimeZone" TZ
				ON TZ."TimeZoneAlternateKey" =  ASrc."TimeZoneId"
			) ACC_TEMP
			LEFT JOIN dw."DimCustomer" Cust
			ON  Cust."CustomerAlternateKey" = ACC_TEMP."CustomerAlternateId" AND Cust."ApplicationCode" = ACC_TEMP."ApplicationCode" AND Cust."Current" =  TRUE ;

			-- INSERT NEW ROWS
			INSERT INTO dw."DimAccount"(
				"AccountAlternateKey",
				"ApplicationCode",
				"AccountNumber",
				"PremiseNumber",
				"TimeZoneKey",
				"ClientAccountKey",
				"ClientKey",
				"CustomerKey",
				"ControlAreaKey",
				"StartActiveDateTimeUTC",
				"EndActiveDateTimeUTC",
				"StartActiveDateTimeLocal",
				"EndActiveDateTimeLocal",
				"StartDateTime",
				"EndDateTime",
				"Current")
			SELECT 
					"AccountId",
					"ApplicationCode",
					"AccountNumber",
					"PremiseNumber",
					"InsertionTimeZoneKey",
					"ClientAccountKey",
					"InsertionClientKey",
					"InsertionCustomerKey",
					"InsertionControlAreaKey",
					"StartActiveDateTimeUTC",
					"EndActiveDateTimeUTC",
					"StartActiveDateTimeLocal",
					"EndActiveDateTimeLocal",
					"StartDateTime",
					NULL,
					TRUE
			FROM etl.ACCOUNT_TEMP
			WHERE "AccountKey" IS NULL ;

			-- UPDATE ROWS WITH NO HISTORICAL
			UPDATE dw."DimAccount"

				SET     	
					"ApplicationCode"= etl.ACCOUNT_TEMP."ApplicationCode",
					"AccountNumber"= etl.ACCOUNT_TEMP."AccountNumber",
					"PremiseNumber"= etl.ACCOUNT_TEMP."PremiseNumber",
					"TimeZoneKey"= etl.ACCOUNT_TEMP."InsertionTimeZoneKey",
					"ClientAccountKey"= etl.ACCOUNT_TEMP."ClientAccountKey",
					"ClientKey"= etl.ACCOUNT_TEMP."InsertionClientKey",
					"CustomerKey"= etl.ACCOUNT_TEMP."InsertionCustomerKey",
					"ControlAreaKey"= etl.ACCOUNT_TEMP."InsertionControlAreaKey",
					"StartActiveDateTimeUTC"= etl.ACCOUNT_TEMP."StartActiveDateTimeUTC",
					"EndActiveDateTimeUTC"= etl.ACCOUNT_TEMP."EndActiveDateTimeUTC",
					"StartActiveDateTimeLocal"= etl.ACCOUNT_TEMP."StartActiveDateTimeLocal",
					"EndActiveDateTimeLocal"= etl.ACCOUNT_TEMP."EndActiveDateTimeLocal"

			FROM     etl.ACCOUNT_TEMP
			WHERE    etl.ACCOUNT_TEMP."AccountKey" IS NOT NULL  
				  AND     etl.ACCOUNT_TEMP."AccountKey"              = dw."DimAccount"."AccountKey"
				  AND    COALESCE(etl.ACCOUNT_TEMP."InsertionClientKey",0)      = COALESCE(dw."DimAccount"."ClientKey",0)
				  AND    COALESCE(etl.ACCOUNT_TEMP."InsertionCustomerKey",0)    = COALESCE(dw."DimAccount"."CustomerKey",0)
				  AND    COALESCE(etl.ACCOUNT_TEMP."InsertionControlAreaKey",0) = COALESCE(dw."DimAccount"."ControlAreaKey",0) ;

			-- UPDATE ROWS WITH HISTORICAL (ENDDATETIME UPDATE)
			UPDATE dw."DimAccount"
			SET 
				"EndDateTime" = now()::timestamp,
				"Current" = FALSE                  
			FROM  etl.ACCOUNT_TEMP 
			WHERE    etl.ACCOUNT_TEMP."AccountKey" IS NOT NULL 
				  AND  etl.ACCOUNT_TEMP."AccountKey" = dw."DimAccount"."AccountKey"
				  AND  (
			  			COALESCE (etl.ACCOUNT_TEMP."InsertionClientKey",-1)      != COALESCE (dw."DimAccount"."ClientKey",-1) 
						OR 
						COALESCE (etl.ACCOUNT_TEMP."InsertionCustomerKey",-1)    != COALESCE (dw."DimAccount"."CustomerKey",-1)
						OR
						COALESCE (etl.ACCOUNT_TEMP."InsertionControlAreaKey",-1) != COALESCE (dw."DimAccount"."ControlAreaKey",-1)
					   );

			-- INSERT HISTORICAL ROWS
			INSERT INTO dw."DimAccount"(
				"AccountAlternateKey",
				"ApplicationCode",
				"AccountNumber",
				"PremiseNumber",
				"TimeZoneKey",
				"ClientAccountKey",
				"ClientKey",
				"CustomerKey",
				"ControlAreaKey",
				"StartActiveDateTimeUTC",
				"EndActiveDateTimeUTC",
				"StartActiveDateTimeLocal",
				"EndActiveDateTimeLocal",
				"StartDateTime",
				"EndDateTime",
				"Current")
			SELECT 
					ATemp."AccountId",
					ATemp."ApplicationCode",
					ATemp."AccountNumber",
					ATemp."PremiseNumber",
					ATemp."InsertionTimeZoneKey",
					ATemp."ClientAccountKey",
					ATemp."InsertionClientKey",
					ATemp."InsertionCustomerKey",
					ATemp."InsertionControlAreaKey",
					ATemp."StartActiveDateTimeUTC",
					ATemp."EndActiveDateTimeUTC",
					ATemp."StartActiveDateTimeLocal",
					ATemp."EndActiveDateTimeLocal",
					now()::timestamp as "StartDateTime",
					NULL,
					TRUE
			FROM etl.ACCOUNT_TEMP ATemp
			JOIN dw."DimAccount" ASrc 
			ON ASrc."AccountKey" = ATemp."AccountKey"
			WHERE         ATemp."AccountKey" IS NOT NULL  
					 AND  (
							COALESCE (ATemp."InsertionClientKey",-1)      != COALESCE (ASrc."ClientKey",-1) 
							OR 
							COALESCE (ATemp."InsertionCustomerKey",-1)    != COALESCE (ASrc."CustomerKey",-1)
							OR
							COALESCE (ATemp."InsertionControlAreaKey",-1) != COALESCE (ASrc."ControlAreaKey",-1)
						   );
	
END;
$BODY$;

ALTER FUNCTION etl."MergeAccountData"()
    OWNER TO postgres;


-----------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('065_DW_ETL_SchemaChange_Create_Scripts');-- FUNCTION: dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"clientId" integer,
	"ISO_Id" integer,
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" integer, "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
		FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
		
		AND ("clientId" IS NULL OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" IS NULL OR iso."ISOAlternateKey" = "ISO_Id") 
		
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('066_DW_stpGetSettlementIntervals');DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone);
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer);


CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone,
	"clientId" integer DEFAULT null::integer,
	"ISO_Id" integer DEFAULT null::integer)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" integer, "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
	    FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
		
		AND ("clientId" Is Null OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" Is Null OR iso."ISOAlternateKey" = "ISO_Id") 
		
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('067_DW_stpGetSettlementIntervals_clientOptional');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN


    RETURN  QUERY
    with intervalsData_CTE  as
	(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr"
		
        FROM dw."FactIntervals" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
	          AND chan."IsDelivered" = TRUE
			  AND fct."InsertionDateTime" <= "transactionDate"
			  AND status."Code" = 'CURRENT'
			  AND meter."ApplicationCode"  = 'SETT'
	),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";

END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('068_DW_GetMisoData');DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer);


CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone,
	"clientId" integer DEFAULT NULL::integer,
	"ISO_Id" integer DEFAULT NULL::integer)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" integer, "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,fis."AccountKey" as "AccountNumber"		
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
	    FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey" 
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey" 
		LEFT JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey" 
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
		
		AND ("clientId" Is Null OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" Is Null OR iso."ISOAlternateKey" = "ISO_Id") 
		
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;


INSERT INTO public."DatabaseVersionHistory" VALUES ('069_DW_sptGetSettlementIntervals_LeftJoinDimCustomer');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN


    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",
                dteLocal."FullAlternateDateKey",
                dtimeLocal."24_hr",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimTime" dtimeLocal
          ON dtimeLocal."TimeKey" = fct."EndTimeLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
	          AND chan."IsDelivered" = TRUE
			  AND fct."InsertionDateTime" <= "transactionDate"
			  AND status."Code" = 'CURRENT'
			  AND meter."ApplicationCode"  = 'SETT'
		),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"--,
                 --"ChannelAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";
END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('070_DW_stpGetMisoData');-- FUNCTION: dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptMonthlyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"monthDate" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Account" character varying, "Adj_Consumption" numeric, "StartDate" Date, "EndDate" Date, "DataType" TEXT, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("monthDate"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("monthDate" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "monthDate" + interval '1' day;	  

"som" Date := date_trunc('MONTH', "monthDate"::Date);
"eom" timestamp := date_trunc('MONTH', "monthDate"::timestamp) + INTERVAL '1 MONTH - 3 ms';

BEGIN

    RETURN  QUERY

SELECT act."AccountNumber" AS "Account"
	  ,SUM(fct."UsageDLF") AS "Adj_Consumption"
	  ,"som"::Date AS "StartDate"
      ,"eom"::Date AS "EndDate"
	  ,(CASE WHEN (ofv."Code" = 'CALC') THEN 'MONTHLY' ELSE 'INTERVAL' END) AS "DataType"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings"


FROM dw."FactIntervals_SETT" fct 
		JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
		JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
		JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
	    JOIN dw."DimOriginFactValue" ofv 
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"   
		JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" =  act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"   
		
WHERE   fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "monthDate"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id" 
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )													 														
												
GROUP BY act."AccountNumber", (CASE WHEN (ofv."Code" = 'CALC') THEN 'MONTHLY' ELSE 'INTERVAL' END), ofv."OriginValueEnglishDescription"
ORDER BY act."AccountNumber";
		
	
END;
$BODY$;

ALTER FUNCTION dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

		
INSERT INTO public."DatabaseVersionHistory" VALUES ('071_DW_procRptMonthlyTotals');DROP FUNCTION IF EXISTS dw."stpGetSettlementInfos";
CREATE or REPLACE FUNCTION dw."stpGetSettlementInfos" ( "clientIdParam"      INTEGER,
                                                        "isoIdParam"         INTEGER,
                                                        "startTradeDayUTC"   TIMESTAMP,
                                                        "transactionDate"    TIMESTAMP)
RETURNS
  TABLE
      (
          "TotalAccounts"        BIGINT ,
          "TotalIntervals"       BIGINT ,
          "CompletedIntervals"   BIGINT ,
          "EstimatedIntervals"   BIGINT ,
          "ExtraneousMeterReads" BIGINT ,
          "TotalKWH"             NUMERIC(28,4),
		  "TotalKWHReal"		 NUMERIC(28,4),
          "TotalMeters"          BIGINT,
          "TotalChannels"        BIGINT
      ) AS $$
DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN

    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                orig."Code" as "OriginConsumptionCode",
                act."AccountAlternateKey",
                meter."MeterAlternateKey",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateUTCKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimOriginFactValue" orig
          ON orig."OriginConsumptionKey" = fct."OriginConsumptionKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND status."Code" = 'CURRENT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND fct."InsertionDateTime" <= "transactionDate"
              AND act."ApplicationCode"    = 'SETT'
              AND meter."ApplicationCode"  = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
		),
    totals_CTE as
    (
        SELECT
              COUNT(DISTINCT "AccountAlternateKey") AS "Accounts",
              COUNT(*) AS "Intervals",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('REAL','CALC') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsCompleted",
              COUNT
              (
                CASE
                    WHEN  "OriginConsumptionCode" in ('ESTI') THEN 1
                    ELSE NULL
                END
              ) AS "IntervalsEstimated",
              0::BIGINT AS "ExtraneousReads",
              sum("UsageDLF") AS "KWH",
			  sum(
                CASE
                    WHEN "OriginConsumptionCode" in ('REAL') THEN "Usage"
                    ELSE 0
                END
			  ) AS "KWHReal",
              COUNT(DISTINCT "MeterAlternateKey") AS "Meters",
              COUNT(DISTINCT "ChannelAlternateKey") AS "Channels"
        FROM intervalsData_CTE
    )
    SELECT  *
    FROM totals_CTE;
END;
$$  LANGUAGE plpgsql;

INSERT INTO public."DatabaseVersionHistory" VALUES ('072_DW_SettlementInfos_Create_Scripts');DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       fct."UsageDLF" AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "tradeDay1"
			  AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       fct."UsageDLF" AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey2"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey2"
              AND fct."EndDateTimeUTC"  >=  "tradeDay2"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC2"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				           
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   tmpResult."Account1",
				   tmpResult."Adj_Total1",
				   tmpResult."Adj_Total2",
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   tmpResult."Account2",
				   tmpResult."Difference_Adj_1"
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
	    
				
ORDER BY tmpResult."Account1", tmpResult."Account2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('073_DW_procRptCompare2DaysByAllAccountsDetails');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
          "startDateTimeLocal"         TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN
    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",

                CASE WHEN ((((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1) AND (dteLocal."FullAlternateDateKey" > "startTradeDayUTC")) THEN (dteLocal."FullAlternateDateKey" + interval '-1' day)
                  ELSE dteLocal."FullAlternateDateKey" END AS "FullAlternateDateKey",


                CASE WHEN TO_CHAR(fct."EndDateTimeLocal", 'MI') = '00' THEN
                                CASE WHEN ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1
                                          THEN 23
                                          ELSE ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1)
                                END
                                ELSE (TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer)
                END  "24_hr",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE fct."EndDateTimeLocal"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeLocal"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
		),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";
END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('074_DW_stpGetMisoData_LocalDate');DROP FUNCTION IF EXISTS dw."stpGetMisoData";

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer,
                                "isoIdParam" integer,
                                "startTradeDayUTC" timestamp without time zone,
                                "transactionDate" timestamp without time zone)

RETURNS TABLE
(
 "MSId" TEXT,
 "TradeDate" TEXT,
 "TradeTime" TEXT,
 "UsageDLF"  NUMERIC,
 "Stat" TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
          "startDateTimeLocal"         TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN
    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",

                CASE WHEN ((((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1) AND (dteLocal."FullAlternateDateKey" > "startTradeDayUTC")) THEN (dteLocal."FullAlternateDateKey" + interval '-1' day)
                  ELSE dteLocal."FullAlternateDateKey" END AS "FullAlternateDateKey",


                CASE WHEN TO_CHAR(fct."EndDateTimeLocal", 'MI') = '00' THEN
                                CASE WHEN ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1
                                          THEN 23
                                          ELSE ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1)
                                END
                                ELSE (TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer)
                END  "24_hr",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dteLocal
          ON dteLocal."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
		),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";
END;
$$;

INSERT INTO public."DatabaseVersionHistory" VALUES ('075_DW_stpGetMisoData');-- FUNCTION: dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "tradeDay1"
			  AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey2"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey2"
              AND fct."EndDateTimeUTC"  >=  "tradeDay2"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC2"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
       	  fct."InsertionDateTime"::Date,
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   tmpResult."Account1",
				   SUM(tmpResult."Adj_Total1"),
				   SUM(tmpResult."Adj_Total2"),
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   tmpResult."Account2",
				   SUM(tmpResult."Difference_Adj_1")
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	   	 tmpResult."Account1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2",
	     tmpResult."Account2"
	    
				
ORDER BY tmpResult."Account1", tmpResult."Account2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('076_DW_procRptCompare2DaysByAllAccountsDetails');-- FUNCTION: dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccounts"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "tradeDay1"
			  AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey2"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey2"
              AND fct."EndDateTimeUTC"  >=  "tradeDay2"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC2"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
       	  fct."InsertionDateTime"::Date,
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   SUM(tmpResult."Adj_Total1"),
				   SUM(tmpResult."Adj_Total2"),
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   SUM(tmpResult."Difference_Adj_1")
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('077_DW_procRptCompare2DaysByAllAccounts');-- FUNCTION: dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccounts"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ControlArea" character varying, 
				  "TradeDay1" date, 
				  "Accounts1" bigint, 
				  "TotalMWh1" numeric, 
				  "TotalMWh2" numeric, 
				  "TradeDay2" date, 
				  "Accounts2" bigint, 
				  "Diff" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  

BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       ca."Abbreviation",
       act."AccountNumber",
       fct."UsageDLF" AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "tradeDay1"
			  AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       ca."Abbreviation",
       act."AccountNumber",
       fct."UsageDLF" AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateUTCKey" >= "startTradeDayUTCKey2"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey2"
              AND fct."EndDateTimeUTC"  >=  "tradeDay2"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC2"
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				           
)
SELECT  COALESCE(tmpResult."ControlArea1", tmpResult."ControlArea2") AS "ControlArea",
		tmpResult."TradeDay1",
		COUNT(tmpResult."Account1") AS "Accounts1",
		SUM(tmpResult."Adj_Total1") AS "TotalMWh1",
		SUM(tmpResult."Adj_Total2") AS "TotalMWh2",
		tmpResult."TradeDay2",
		COUNT(tmpResult."Account2") AS "Accounts2",
		SUM(tmpResult."Difference_Adj_1") AS "Diff"
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
							
			   
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY COALESCE(tmpResult."ControlArea1", tmpResult."ControlArea2"),
		 tmpResult."TradeDay1",
		 tmpResult."TradeDay2";
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('078_DW_procRptCompare2DaysByAllAccounts');DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone);
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer);


CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone,
	"clientId" integer DEFAULT null::integer,
	"ISO_Id" integer DEFAULT null::integer)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" integer, "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,da."AccountNumber" as "AccountNumber"	
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
	    FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
		
		AND ("clientId" Is Null OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" Is Null OR iso."ISOAlternateKey" = "ISO_Id") 
		
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('079_DW_stpGetSettlementIntervals_clientOptional');DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone);
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer);


CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone,
	"clientId" integer DEFAULT null::integer,
	"ISO_Id" integer DEFAULT null::integer)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" character varying(50), "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,da."AccountNumber" as "AccountNumber"	
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
	    FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey"
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
		
		AND ("clientId" Is Null OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" Is Null OR iso."ISOAlternateKey" = "ISO_Id") 
		
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('080_DW_stpGetSettlementIntervals_clientOptional');DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);

INSERT INTO public."DatabaseVersionHistory" VALUES ('081_DW_procRptCompare2DaysByAllAccounts');DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(integer, integer, timestamp without time zone, timestamp without time zone);
DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer);

CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone,
	"clientId" integer DEFAULT NULL::integer,
	"ISO_Id" integer DEFAULT NULL::integer)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" character varying, "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,da."AccountNumber" as "AccountNumber"	
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
	    FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		LEFT JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey" 
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "startDateTime" AND fis."EndDateTimeLocal" <= "endDateTime"
		
		AND ("clientId" Is Null OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" Is Null OR iso."ISOAlternateKey" = "ISO_Id") 
		
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('082_DW_stpGetSettlementIntervals_clientOptional');-- FUNCTION: dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptDailyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"startTradeDayUTC" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Tradeday" date, "TransactionDate" timestamp without time zone, "Account" character varying, "MeterID" character varying, "ControlArea" character varying, "RawDailyUsage" numeric, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
   
"startTradeDayUTCKey"	INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"		INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);

 "endTradeDayUTC" 		TIMESTAMP := "startTradeDayUTC" + interval '1' day;
 "startDateTimeLocal" 	TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN

    RETURN  QUERY
	
SELECT tmp."Tradeday"
	  ,tmp."TransactionDate" 
	  ,tmp."Account"
	  ,tmp."MeterID"
	  ,tmp."ControlArea"
	  ,SUM(tmp."RawDailyUsage")
	  ,tmp."IntervalReadings"
	  
	  
FROM (
SELECT "startTradeDayUTC"::Date AS "Tradeday"
	  ,"transactionDate" AS "TransactionDate" 
	  ,act."AccountNumber" AS "Account"
	  ,mt."DeviceCode" AS "MeterID"
	  ,ca."Abbreviation" AS "ControlArea"
	  ,fct."Usage" AS "RawDailyUsage"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings"

FROM dw."FactIntervals_SETT" fct 
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"        
		JOIN dw."DimOriginFactValue" ofv
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"      
		JOIN dw."DimControlArea" ca																						
		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
		JOIN dw."DimMeter" mt
		  ON mt."MeterKey" = fct."MeterKey"  
			
	    WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
	
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
)tmp			
			
		GROUP BY tmp."Tradeday"
	  		 	 ,tmp."TransactionDate" 
	  		 	 ,tmp."Account"
	  		 	 ,tmp."MeterID"
	    	 	 ,tmp."ControlArea"
	  		 	 ,tmp."IntervalReadings"
			 
		ORDER BY tmp."Account"
	  			 ,tmp."MeterID"
	  			 ,tmp."ControlArea";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('083_DW_procRptDailyTotals_LocalDate');DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  
"startDateTimeLocal" 	TIMESTAMP := "tradeDay1" + interval '15' MINUTE;

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"startDateTimeLocal2" 	TIMESTAMP := "tradeDay2" + interval '15' MINUTE;
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal2"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC2"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
       	  fct."InsertionDateTime"::Date,
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   tmpResult."Account1",
				   SUM(tmpResult."Adj_Total1"),
				   SUM(tmpResult."Adj_Total2"),
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   tmpResult."Account2",
				   SUM(tmpResult."Difference_Adj_1")
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	   	 tmpResult."Account1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2",
	     tmpResult."Account2"
	    
				
ORDER BY tmpResult."Account1", tmpResult."Account2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('084_DW_RptCompare2DaysByAllAccountsDetails_LocalDate');DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccounts"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ControlArea" character varying, "TradeDay1" date, "TradeDay2" date, "AccountsDay1" bigint, "AccountsDay2" bigint, "TotalMwhDay1" numeric, "TotalMwhDay2" numeric, "Diff" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  
"startDateTimeLocal" 	TIMESTAMP := "tradeDay1" + interval '15' MINUTE;

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"startDateTimeLocal2" 	TIMESTAMP := "tradeDay2" + interval '15' MINUTE;
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal2"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC2"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
       	  fct."InsertionDateTime"::Date,
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ControlArea1" AS "ControlArea",
		tmpResult."TradeDay1",
		tmpResult."TradeDay2",
		COUNT(tmpResult."Account1") AS "AccountsDay1",
	    COUNT(tmpResult."Account2") AS "AccountsDay2",
		SUM(tmpResult."Adj_Total1") AS "TotalMwhDay1",
		SUM(tmpResult."Adj_Total2") AS "TotalMwhDay2",
		(COALESCE(SUM(tmpResult."Adj_Total1"), 0) - COALESCE(SUM(tmpResult."Adj_Total2"), 0)) AS "Diff"
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2";
	    
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;


INSERT INTO public."DatabaseVersionHistory" VALUES ('085_DW_procRptCompare2DaysByAllAccounts_LocalDate');DROP FUNCTION IF EXISTS dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptMonthlyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"monthDate" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Account" character varying, "Adj_Consumption" numeric, "StartDate" date, "EndDate" date, "DataType" text, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("monthDate"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("monthDate" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "monthDate" + interval '1' day;	  

"som" Date := date_trunc('MONTH', "monthDate"::Date);
"eom" timestamp := date_trunc('MONTH', "monthDate"::timestamp) + INTERVAL '1 MONTH - 3 ms';

BEGIN

    RETURN  QUERY

SELECT act."AccountNumber" AS "Account"
	  ,SUM(fct."UsageDLF") AS "Adj_Consumption"
	  ,"som"::Date AS "StartDate"
      ,"eom"::Date AS "EndDate"
	  ,(CASE WHEN (ofv."Code" = 'CALC') THEN 'MONTHLY' ELSE 'INTERVAL' END) AS "DataType"
	  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings"


FROM dw."FactIntervals_SETT" fct 
		JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
		JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
		JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
	    JOIN dw."DimOriginFactValue" ofv 
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"   
		JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" =  act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"   
		
WHERE   fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "monthDate"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
			
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id" 
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )													 														
												
GROUP BY act."AccountNumber", (CASE WHEN (ofv."Code" = 'CALC') THEN 'MONTHLY' ELSE 'INTERVAL' END), ofv."OriginValueEnglishDescription"
ORDER BY act."AccountNumber";
		
	
END;
$BODY$;

ALTER FUNCTION dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;
	
		
INSERT INTO public."DatabaseVersionHistory" VALUES ('086_DW_procRptMonthlyTotals');DROP FUNCTION IF EXISTS dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptMonthlyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"monthDate" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Account" character varying, "Adj_Consumption" numeric, "StartDate" date, "EndDate" date, "DataType" text) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("monthDate"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("monthDate" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "monthDate" + interval '1' day;	  

"som" Date := date_trunc('MONTH', "monthDate"::Date);
"eom" timestamp := date_trunc('MONTH', "monthDate"::timestamp) + INTERVAL '1 MONTH - 3 ms';

BEGIN

    RETURN  QUERY

SELECT act."AccountNumber" AS "Account"
	  ,SUM(fct."UsageDLF") AS "Adj_Consumption"
	  ,"som"::Date AS "StartDate"
      ,"eom"::Date AS "EndDate"
	  ,(CASE WHEN (ofv."Code" = 'CALC') THEN 'MONTHLY' ELSE 'INTERVAL' END) AS "DataType"
	  

FROM dw."FactIntervals_SETT" fct 
		JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
		JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
		JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
	    JOIN dw."DimOriginFactValue" ofv 
          ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"   
		JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" =  act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"   
		
WHERE   fct."EndDateUTCKey" >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >  "monthDate"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
			
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id" 
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )													 														
												
GROUP BY act."AccountNumber", (CASE WHEN (ofv."Code" = 'CALC') THEN 'MONTHLY' ELSE 'INTERVAL' END), ofv."OriginValueEnglishDescription"
ORDER BY act."AccountNumber";
		
	
END;
$BODY$;

ALTER FUNCTION dw."procRptMonthlyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('087_DW_procRptMonthlyTotals');DROP FUNCTION IF EXISTS dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer);

CREATE OR REPLACE FUNCTION dw."stpGetSettlementIntervals"(
	"startDateTime" timestamp without time zone,
	"endDateTime" timestamp without time zone,
	"clientId" integer DEFAULT NULL::integer,
	"ISO_Id" integer DEFAULT NULL::integer)
    RETURNS TABLE("IntervalId" bigint, "InsertionDateTime" timestamp without time zone, "MonthlyRead" numeric, "Usage" numeric, "UsageDLF" numeric, "Demand" numeric, "DemandDLF" numeric, "DLP" numeric, "DLPSum" numeric, "DLPRation" numeric, "DLF" numeric, "StartDateTimeUTC" timestamp without time zone, "TradeDay" timestamp without time zone, "StartDateTimeLocal" timestamp without time zone, "EndDateTimeLocal" timestamp without time zone, "AccountNumber" character varying, "MeterName" character varying, "ClientName" character varying, "CustomerName" character varying, "ControlAreaName" character varying, "ChannelNumber" integer) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE

"_startDateTime" TIMESTAMP WITH TIME ZONE :=  "startDateTime" + INTERVAL '15 minute';
"_endDateTime" TIMESTAMP WITH TIME ZONE :=  "endDateTime"::Date;

BEGIN
	RETURN QUERY 
	with INTERVALS_DATA as
	(
		SELECT fis."IntervalKey" as "IntervalId"
			  ,fis."InsertionDateTime" as "InsertionDateTime"
			  ,fis."MonthlyRead"
			  ,fis."Usage"
			  ,fis."UsageDLF"
			  ,fis."Demand"
			  ,fis."DemandDLF"
			  ,fis."DLP"
			  ,fis."DLPSum"
			  ,fis."DLPRation"
			  ,fis."DLF"
			  ,fis."StartDateTimeUTC" as "StartDateTimeUTC"
			  ,fis."EndDateTimeUTC" as "TradeDay"
			  ,fis."StartDateTimeLocal" as "StartDateTimeLocal"
			  ,fis."EndDateTimeLocal" as "EndDateTimeLocal"
			  ,da."AccountNumber" as "AccountNumber"	
			  ,dm."Name" as "MeterName"
		      ,dc."ClientName"
		      ,dcu."Name" as "CustomerName"
		      ,dca."Name" as "ControlAreaName"
			  ,CAST(dch."ChannelNumber" as Integer) as "ChannelNumber"
	 FROM dw."FactIntervals_SETT" as fis
		JOIN dw."DimAccount" as da on fis."AccountKey" = da."AccountKey"
		JOIN dw."DimClient" as dc on da."ClientKey" = dc."ClientKey"
		LEFT JOIN dw."DimCustomer" as dcu on da."CustomerKey" = dcu."CustomerKey" 
		JOIN dw."DimControlArea" as dca on dca."ControlAreaKey" = da."ControlAreaKey"
		JOIN dw."DimMeter" as dm on dm."MeterKey" = fis."MeterKey"
		JOIN dw."DimChannel" as dch on fis."ChannelKey" = dch."ChannelKey"
    	JOIN dw."DimISO" as iso ON iso."ISOKey" = dca."ISOKey"	
		WHERE fis."EndDateTimeLocal" >= "_startDateTime" AND fis."EndDateTimeLocal" <= "_endDateTime"
		
		AND ("clientId" Is Null OR dc."ClientAlternateKey" = "clientId")		
        AND ("ISO_Id" Is Null OR iso."ISOAlternateKey" = "ISO_Id") 
	)
	SELECT * 
	FROM INTERVALS_DATA;
END;

$BODY$;

ALTER FUNCTION dw."stpGetSettlementIntervals"(timestamp without time zone, timestamp without time zone, integer, integer)
    OWNER TO postgres;
			
INSERT INTO public."DatabaseVersionHistory" VALUES ('088_DW_stpGetSettlementIntervals');DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  
"startDateTimeLocal" 	TIMESTAMP := "tradeDay1" + interval '15' MINUTE;

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"startDateTimeLocal2" 	TIMESTAMP := "tradeDay2" + interval '15' MINUTE;
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal2"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC2"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
       	  fct."InsertionDateTime",
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   tmpResult."Account1",
				   SUM(tmpResult."Adj_Total1"),
				   SUM(tmpResult."Adj_Total2"),
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   tmpResult."Account2",
				   SUM(tmpResult."Difference_Adj_1")
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd HH24:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd HH24:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	   	 tmpResult."Account1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2",
	     tmpResult."Account2"
	    
				
ORDER BY tmpResult."Account1", tmpResult."Account2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('089_DW_procRptCompare2DaysByAllAccountsDetails');DROP FUNCTION IF EXISTS dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone);


CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ClientID" integer, "TradeDay1" date, "transactionDate1" timestamp without time zone, "ControlArea1" character varying, "Account1" character varying, "Adj_Total1" numeric, "Adj_Total2" numeric, "TradeDay2" date, "transactionDate2" timestamp without time zone, "ControlArea2" character varying, "Account2" character varying, "Difference_Adj_" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  
"startDateTimeLocal" 	TIMESTAMP := "tradeDay1" + interval '15' MINUTE;

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"startDateTimeLocal2" 	TIMESTAMP := "tradeDay2" + interval '15' MINUTE;
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2"::Date,
       MAX(fct."InsertionDateTime"::Timestamp) AS "InsertionDateTime2",
	   fct."InsertionDateTime"::Date AS "TransDate2" ,  
	   ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal2"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC2"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY "tradeDay2"::Date,
		"TransDate2",
		act."AccountNumber",
        ca."Abbreviation"
         
)
SELECT  tmpResult."ClientID",
				   tmpResult."TradeDay1",
				   tmpResult."transactionDate1",
				   tmpResult."ControlArea1",
				   tmpResult."Account1",
				   SUM(tmpResult."Adj_Total1"),
				   SUM(tmpResult."Adj_Total2"),
				   tmpResult."TradeDay2",
				   tmpResult."transactionDate2",
				   tmpResult."ControlArea2",
				   tmpResult."Account2",
				   SUM(tmpResult."Difference_Adj_1")
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd HH24:mi:ss.mmm')::timestamp AS "transactionDate1",
       day1."Abbreviation" AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime2",'yyyy-mm-dd HH24:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2", 
		
       CAST(ABS(COALESCE(day2."hourlyUsageDLFApplied", 0) - COALESCE(day1."hourlyUsageDLFApplied",0)) AS DECIMAL(28,7)) / 1000 AS "Difference_Adj_1"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	   	 tmpResult."Account1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2",
	     tmpResult."Account2"
	    
				
ORDER BY tmpResult."Account1", tmpResult."Account2";																 
																	 
END;
$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccountsDetails"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('090_DW_procRptCompare2DaysByAllAccountsDetails');
ALTER TABLE dw."FactIntervals_SETT" ADD "IsDelivered" boolean;

ALTER TABLE stg."FactIntervals" ADD "IsDelivered" boolean;

ALTER TABLE etl.facts_temp_sett ADD "stg_IsDelivered" boolean;

INSERT INTO public."DatabaseVersionHistory" VALUES ('091_DW_addFlowDirectionColumn');
-----------------------------------------------------------------------
DROP FUNCTION IF EXISTS public."stpMergeDailyFactIntervals_SETT";
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT";

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey",
				  fct."IsDelivered"   as "dw_IsDelivered"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey",
			fct."IsDelivered"       as "stg_IsDelivered"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett
  SELECT *
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );


  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

---------------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('092_DW_stpMergeDailyFactIntervals_SETT');ALTER TABLE etl.facts_temp_sett ADD "dw_IsDelivered" boolean;

INSERT INTO public."DatabaseVersionHistory" VALUES ('093_DW_addIsDeliveredFactTempSett');
-----------------------------------------------------------------------
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT";

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey",
				  fct."IsDelivered"   as "dw_IsDelivered"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey",
			fct."IsDelivered"       as "stg_IsDelivered"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett (
	"dw_IntervalKey",
	"dw_InsertionDateTime" ,
	"dw_MonthlyRead",
	"dw_Usage",
	"dw_UsageDLF",
	"dw_Demand",
	"dw_DemandDLF",
	"dw_DLP",
	"dw_DLPSum",
	"dw_DLPRation",
	"dw_DLF",
	"dw_StartDateTimeUTC",
	"dw_EndDateTimeUTC",
	"dw_StartDateTimeLocal",
	"dw_EndDateTimeLocal",
	"dw_AccountKey",
	"dw_SDPKey",
	"dw_MeterKey",
	"dw_ChannelKey",
	"dw_OriginConsumptionKey",
	"dw_FactValueGoalKey",
	"dw_ServiceTypeKey",
	"dw_ParentIntervalKey",
	"dw_FactStatusKey",
	"dw_EndDateLocalKey",
	"dw_EndTimeLocalKey",
	"dw_EndDateUTCKey",
	"dw_EndTimeUTCKey",
	"dw_RecordedDateUTCKey",
	"dw_ClientKey",
	"dw_IsDelivered"  
  )
  SELECT "dw_IntervalKey",
  		 "dw_InsertionDateTime" ,
		 "dw_MonthlyRead",
		 "dw_Usage",
		 "dw_UsageDLF",
		 "dw_Demand",
		 "dw_DemandDLF",
		 "dw_DLP",
		 "dw_DLPSum",
		 "dw_DLPRation",
		 "dw_DLF",
		 "dw_StartDateTimeUTC",
		 "dw_EndDateTimeUTC",
		 "dw_StartDateTimeLocal",
		 "dw_EndDateTimeLocal",
		 "dw_AccountKey",
		 "dw_SDPKey",
		 "dw_MeterKey",
		 "dw_ChannelKey",
		 "dw_OriginConsumptionKey",
		 "dw_FactValueGoalKey",
		 "dw_ServiceTypeKey",
		 "dw_ParentIntervalKey",
		 "dw_FactStatusKey",
		 "dw_EndDateLocalKey",
		 "dw_EndTimeLocalKey",
		 "dw_EndDateUTCKey",
		 "dw_EndTimeUTCKey",
		 "dw_RecordedDateUTCKey",
		 "dw_ClientKey",
		 "dw_IsDelivered"  
  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );


  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

---------------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('094_DW_exposeAllFieldsInsert_stpMergeDailyFactIntervals_SETT');
-----------------------------------------------------------------------
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT";

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey",
				  fct."IsDelivered"   as "dw_IsDelivered"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey",
			fct."IsDelivered"       as "stg_IsDelivered"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett (
	"dw_IntervalKey",
	"dw_InsertionDateTime" ,
	"dw_MonthlyRead",
	"dw_Usage",
	"dw_UsageDLF",
	"dw_Demand",
	"dw_DemandDLF",
	"dw_DLP",
	"dw_DLPSum",
	"dw_DLPRation",
	"dw_DLF",
	"dw_StartDateTimeUTC",
	"dw_EndDateTimeUTC",
	"dw_StartDateTimeLocal",
	"dw_EndDateTimeLocal",
	"dw_AccountKey",
	"dw_SDPKey",
	"dw_MeterKey",
	"dw_ChannelKey",
	"dw_OriginConsumptionKey",
	"dw_FactValueGoalKey",
	"dw_ServiceTypeKey",
	"dw_ParentIntervalKey",
	"dw_FactStatusKey",
	"dw_EndDateLocalKey",
	"dw_EndTimeLocalKey",
	"dw_EndDateUTCKey",
	"dw_EndTimeUTCKey",
	"dw_RecordedDateUTCKey",
	"dw_ClientKey",
	"dw_IsDelivered",

    "stg_MonthlyRead",
    "stg_Usage",
    "stg_UsageDLF",
    "stg_Demand",
    "stg_DemandDLF",
    "stg_DLP",
    "stg_DLPSum",
    "stg_DLPRation",
    "stg_DLF",
    "stg_StartDateTimeUTC",
    "stg_EndDateTimeUTC",
    "stg_StartDateTimeLocal",
    "stg_EndDateTimeLocal",
    "stg_ClientKey",
    "stg_AccountKey",
    "stg_SDPKey",
    "stg_MeterKey",
    "stg_ChannelKey",
    "stg_OriginConsumptionKey",
    "stg_OriginConsumptionCode",
    "stg_ServiceTypeKey",
    "stg_EndDateLocalKey",
    "stg_EndDateUTCKey",
    "stg_EndTimeLocalKey",
    "stg_EndTimeUTCKey",
    "stg_RecordedDateKey",
	"stg_IsDelivered"
  )
  SELECT "dw_IntervalKey",
  		 "dw_InsertionDateTime" ,
		 "dw_MonthlyRead",
		 "dw_Usage",
		 "dw_UsageDLF",
		 "dw_Demand",
		 "dw_DemandDLF",
		 "dw_DLP",
		 "dw_DLPSum",
		 "dw_DLPRation",
		 "dw_DLF",
		 "dw_StartDateTimeUTC",
		 "dw_EndDateTimeUTC",
		 "dw_StartDateTimeLocal",
		 "dw_EndDateTimeLocal",
		 "dw_AccountKey",
		 "dw_SDPKey",
		 "dw_MeterKey",
		 "dw_ChannelKey",
		 "dw_OriginConsumptionKey",
		 "dw_FactValueGoalKey",
		 "dw_ServiceTypeKey",
		 "dw_ParentIntervalKey",
		 "dw_FactStatusKey",
		 "dw_EndDateLocalKey",
		 "dw_EndTimeLocalKey",
		 "dw_EndDateUTCKey",
		 "dw_EndTimeUTCKey",
		 "dw_RecordedDateUTCKey",
		 "dw_ClientKey",
		 "dw_IsDelivered",  

		"stg_MonthlyRead",
		"stg_Usage",
		"stg_UsageDLF",
		"stg_Demand",
		"stg_DemandDLF",
		"stg_DLP",
		"stg_DLPSum",
		"stg_DLPRation",
		"stg_DLF",
		"stg_StartDateTimeUTC",
		"stg_EndDateTimeUTC",
		"stg_StartDateTimeLocal",
		"stg_EndDateTimeLocal",
		"stg_ClientKey",
		"stg_AccountKey",
		"stg_SDPKey",
		"stg_MeterKey",
		"stg_ChannelKey",
		"stg_OriginConsumptionKey",
		"stg_OriginConsumptionCode",
		"stg_ServiceTypeKey",
		"stg_EndDateLocalKey",
		"stg_EndDateUTCKey",
		"stg_EndTimeLocalKey",
		"stg_EndTimeUTCKey",
		"stg_RecordedDateKey",
		"stg_IsDelivered"

  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );


  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;


---------------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('095_DW_stpMergeDailyFactIntervals_SETT');
-----------------------------------------------------------------------
DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT";

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" TIMESTAMP, "dailyEndDateUTC" TIMESTAMP)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey",
				  fct."IsDelivered"   as "dw_IsDelivered"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey",
			fct."IsDelivered"       as "stg_IsDelivered"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett (
	"dw_IntervalKey",
	"dw_InsertionDateTime" ,
	"dw_MonthlyRead",
	"dw_Usage",
	"dw_UsageDLF",
	"dw_Demand",
	"dw_DemandDLF",
	"dw_DLP",
	"dw_DLPSum",
	"dw_DLPRation",
	"dw_DLF",
	"dw_StartDateTimeUTC",
	"dw_EndDateTimeUTC",
	"dw_StartDateTimeLocal",
	"dw_EndDateTimeLocal",
	"dw_AccountKey",
	"dw_SDPKey",
	"dw_MeterKey",
	"dw_ChannelKey",
	"dw_OriginConsumptionKey",
	"dw_FactValueGoalKey",
	"dw_ServiceTypeKey",
	"dw_ParentIntervalKey",
	"dw_FactStatusKey",
	"dw_EndDateLocalKey",
	"dw_EndTimeLocalKey",
	"dw_EndDateUTCKey",
	"dw_EndTimeUTCKey",
	"dw_RecordedDateUTCKey",
	"dw_ClientKey",
	"dw_IsDelivered",

    "stg_MonthlyRead",
    "stg_Usage",
    "stg_UsageDLF",
    "stg_Demand",
    "stg_DemandDLF",
    "stg_DLP",
    "stg_DLPSum",
    "stg_DLPRation",
    "stg_DLF",
    "stg_StartDateTimeUTC",
    "stg_EndDateTimeUTC",
    "stg_StartDateTimeLocal",
    "stg_EndDateTimeLocal",
    "stg_ClientKey",
    "stg_AccountKey",
    "stg_SDPKey",
    "stg_MeterKey",
    "stg_ChannelKey",
    "stg_OriginConsumptionKey",
    "stg_OriginConsumptionCode",
    "stg_ServiceTypeKey",
    "stg_EndDateLocalKey",
    "stg_EndDateUTCKey",
    "stg_EndTimeLocalKey",
    "stg_EndTimeUTCKey",
    "stg_RecordedDateKey",
	"stg_IsDelivered"
  )
  SELECT "dw_IntervalKey",
  		 "dw_InsertionDateTime" ,
		 "dw_MonthlyRead",
		 "dw_Usage",
		 "dw_UsageDLF",
		 "dw_Demand",
		 "dw_DemandDLF",
		 "dw_DLP",
		 "dw_DLPSum",
		 "dw_DLPRation",
		 "dw_DLF",
		 "dw_StartDateTimeUTC",
		 "dw_EndDateTimeUTC",
		 "dw_StartDateTimeLocal",
		 "dw_EndDateTimeLocal",
		 "dw_AccountKey",
		 "dw_SDPKey",
		 "dw_MeterKey",
		 "dw_ChannelKey",
		 "dw_OriginConsumptionKey",
		 "dw_FactValueGoalKey",
		 "dw_ServiceTypeKey",
		 "dw_ParentIntervalKey",
		 "dw_FactStatusKey",
		 "dw_EndDateLocalKey",
		 "dw_EndTimeLocalKey",
		 "dw_EndDateUTCKey",
		 "dw_EndTimeUTCKey",
		 "dw_RecordedDateUTCKey",
		 "dw_ClientKey",
		 "dw_IsDelivered",  

		"stg_MonthlyRead",
		"stg_Usage",
		"stg_UsageDLF",
		"stg_Demand",
		"stg_DemandDLF",
		"stg_DLP",
		"stg_DLPSum",
		"stg_DLPRation",
		"stg_DLF",
		"stg_StartDateTimeUTC",
		"stg_EndDateTimeUTC",
		"stg_StartDateTimeLocal",
		"stg_EndDateTimeLocal",
		"stg_ClientKey",
		"stg_AccountKey",
		"stg_SDPKey",
		"stg_MeterKey",
		"stg_ChannelKey",
		"stg_OriginConsumptionKey",
		"stg_OriginConsumptionCode",
		"stg_ServiceTypeKey",
		"stg_EndDateLocalKey",
		"stg_EndDateUTCKey",
		"stg_EndTimeLocalKey",
		"stg_EndTimeUTCKey",
		"stg_RecordedDateKey",
		"stg_IsDelivered"

  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
		AND dw_fact."dw_IsDelivered"    = stg_fact."stg_IsDelivered"
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );


  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;


---------------------------------------------------------------

INSERT INTO public."DatabaseVersionHistory" VALUES ('096_DW_stpMergeDailyFactIntervals_SETT_IsDeliveredKey');----------------------------------------------------------------------
DROP FUNCTION IF EXISTS  dw."procRptCompare2DaysByAllAccounts";

CREATE OR REPLACE FUNCTION dw."procRptCompare2DaysByAllAccounts"(
	"clientId" integer,
	"ISO_Id" integer,
	"tradeDay1" timestamp without time zone,
	"tradeDay2" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("ControlArea" character varying, "TradeDay1" date, "TradeDay2" date, "AccountsDay1" bigint, "AccountsDay2" bigint, "TotalMwhDay1" numeric, "TotalMwhDay2" numeric, "Diff" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE
    ROWS 1000
AS $BODY$

DECLARE

"startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("tradeDay1"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("tradeDay1" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTC"        TIMESTAMP := "tradeDay1" + interval '1' day;	  
"startDateTimeLocal" 	TIMESTAMP := "tradeDay1" + interval '15' MINUTE;

"startTradeDayUTCKey2"   INTEGER   := CAST (TO_CHAR("tradeDay2"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("tradeDay2" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
"startDateTimeLocal2" 	TIMESTAMP := "tradeDay2" + interval '15' MINUTE;
"endTradeDayUTC2"        TIMESTAMP := "tradeDay2" + interval '1' day;	  


BEGIN

    RETURN  QUERY

WITH tmp1 AS 
(	
	SELECT
	   "tradeDay1", 
       "transactionDate",
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 
	
	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca																					
		  ON ca."ControlAreaKey" = act."ControlAreaKey"																									
	    JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	 WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )						
	              	  
GROUP BY "tradeDay1"::Date,
       	 "transactionDate",
         act."AccountNumber",
		 ca."Abbreviation"
),
tmp2 AS 
(																					  
SELECT
	   "tradeDay2",
       fct."InsertionDateTime"::Date,
       ca."Abbreviation",
       act."AccountNumber",
       SUM(fct."UsageDLF") AS "hourlyUsageDLFApplied" 

	FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"																											
		JOIN dw."DimServiceType" serv																			
		  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
 		  ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
		  ON iso."ISOKey" = ca."ISOKey"
	
	   WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal2"
              AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC2"	
			  
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "ISO_Id"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )				  
	                
GROUP BY  ca."Abbreviation",
		  "tradeDay2"::Date,
       	  fct."InsertionDateTime"::Date,
       	  act."AccountNumber",
          ca."Abbreviation"
         
)
SELECT  tmpResult."ControlArea1" AS "ControlArea",
		tmpResult."TradeDay1",
		tmpResult."TradeDay2",
		COUNT(tmpResult."Account1") AS "AccountsDay1",
	    COUNT(tmpResult."Account2") AS "AccountsDay2",
		SUM(tmpResult."Adj_Total1") AS "TotalMwhDay1",
		SUM(tmpResult."Adj_Total2") AS "TotalMwhDay2",
		(COALESCE(SUM(tmpResult."Adj_Total1"), 0) - COALESCE(SUM(tmpResult."Adj_Total2"), 0)) AS "Diff"
				   
				   
				   FROM(
SELECT "clientId" as "ClientID",
	   "day1"."tradeDay1"::Date AS "TradeDay1",
	   TO_CHAR("day1"."transactionDate",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate1",
       COALESCE(day1."Abbreviation", day2."Abbreviation") AS "ControlArea1", 
       day1."AccountNumber" AS "Account1", 
       day1."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total1",
       day2."hourlyUsageDLFApplied"::DECIMAL(28,7) / 1000 AS "Adj_Total2",
	   "day2"."tradeDay2"::Date AS "TradeDay2",  
       TO_CHAR("day2"."InsertionDateTime",'yyyy-mm-dd hh:mi:ss.mmm')::timestamp AS "transactionDate2", 
	   day2."Abbreviation" AS "ControlArea2",
       day2."AccountNumber" AS "Account2"
FROM tmp1 AS day1
FULL OUTER JOIN tmp2 AS day2 ON day1."AccountNumber" =  day2."AccountNumber"
								
																					
ORDER BY day1."AccountNumber", day2."AccountNumber"		
)tmpResult
	
GROUP BY tmpResult."ClientID",
	   	 tmpResult."TradeDay1",
	     tmpResult."transactionDate1",
		 tmpResult."ControlArea1",
	     tmpResult."TradeDay2",
		 tmpResult."transactionDate2",
	   	 tmpResult."ControlArea2";
	    
END;

$BODY$;

ALTER FUNCTION dw."procRptCompare2DaysByAllAccounts"(integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

    
INSERT INTO public."DatabaseVersionHistory" VALUES ('097_DW_procRptCompare2DaysByAllAccounts');CREATE INDEX DimAccount_AccountKey_ApplicationCode_index ON dw."DimAccount" ("AccountKey", "ApplicationCode");
CREATE INDEX DimClient_ClientKey_ClientAlternateKey_index ON dw."DimClient" ("ClientKey", "ClientAlternateKey");
CREATE INDEX DimServiceType_ServiceTypeKey_Code_index ON dw."DimServiceType" ("ServiceTypeKey", "Code");
CREATE INDEX DimFactStatus_FactStatusKey_Code_index ON dw."DimFactStatus" ("FactStatusKey", "Code");
CREATE INDEX DimControlArea_ISOKey_index ON dw."DimControlArea" ("ISOKey");
CREATE INDEX intervals_y2015m06_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m06 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2015m07_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m07 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2015m08_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m08 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2015m09_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m09 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2015m10_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m10 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2015m11_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m11 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2015m12_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2015m12 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m01_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m01 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m02_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m02 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m03_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m03 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m04_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m04 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m05_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m05 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m06_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m06 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m07_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m07 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m08_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m08 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m09_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m09 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m10_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m10 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m11_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m11 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2016m12_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2016m12 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m01_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m01 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m02_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m02 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m03_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m03 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m04_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m04 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m05_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m05 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m06_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m06 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m07_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m07 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m08_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m08 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m09_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m09 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m10_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m10 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m11_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m11 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2017m12_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2017m12 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m01_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m01 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m02_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m02 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m03_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m03 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m04_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m04 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m05_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m05 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m06_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m06 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m07_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m07 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m08_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m08 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m09_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m09 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m10_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m10 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m11_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m11 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2018m12_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2018m12 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m01_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m01 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m02_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m02 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m03_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m03 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m04_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m04 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m05_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m05 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m06_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m06 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m07_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m07 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m08_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m08 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m09_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m09 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m10_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m10 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m11_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m11 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");
CREATE INDEX intervals_y2019m12_AKey_STKey_FSKey_OCKey_MKey_index ON dw.intervals_y2019m12 ("AccountKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey", "MeterKey");

INSERT INTO public."DatabaseVersionHistory" VALUES ('098_DW_CreateIndex');CREATE INDEX DimAccount_AccountKey_ControlAreaKey_index ON dw."DimAccount" ("AccountKey", "ControlAreaKey");
CREATE INDEX DimControlArea_ControlAreaKey_ISOKey_index ON dw."DimControlArea" ("ControlAreaKey", "ISOKey");
CREATE INDEX DimAccount_ClientKey_index ON dw."DimAccount" ("ClientKey");
CREATE INDEX DimAccount_ClientKey_AccountKey_ControlAreaKey_index ON dw."DimAccount" ("ClientKey", "AccountKey", "ControlAreaKey");
CREATE INDEX DimAccount_ClientKey_AccountKey_ApplicationCode_index ON dw."DimAccount" ("ClientKey", "AccountKey", "ApplicationCode");
CREATE INDEX intervals_y2015m06_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m06 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2015m07_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m07 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2015m08_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m08 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2015m09_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m09 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2015m10_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m10 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2015m11_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m11 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2015m12_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2015m12 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m01_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m01 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m02_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m02 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m03_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m03 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m04_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m04 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m05_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m05 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m06_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m06 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m07_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m07 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m08_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m08 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m09_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m09 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m10_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m10 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m11_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m11 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2016m12_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2016m12 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m01_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m01 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m02_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m02 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m03_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m03 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m04_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m04 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m05_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m05 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m06_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m06 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m07_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m07 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m08_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m08 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m09_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m09 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m10_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m10 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m11_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m11 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2017m12_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2017m12 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m01_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m01 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m02_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m02 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m03_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m03 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m04_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m04 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m05_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m05 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m06_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m06 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m07_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m07 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m08_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m08 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m09_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m09 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m10_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m10 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m11_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m11 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2018m12_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2018m12 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m01_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m01 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m02_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m02 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m03_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m03 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m04_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m04 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m05_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m05 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m06_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m06 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m07_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m07 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m08_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m08 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m09_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m09 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m10_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m10 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m11_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m11 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");
CREATE INDEX intervals_y2019m12_AKey_MKey_ChKey_EDUKey_STKey_FSKey_OCKey_index ON dw.intervals_y2019m12 ("AccountKey", "MeterKey", "ChannelKey", "EndDateUTCKey", "ServiceTypeKey", "FactStatusKey", "OriginConsumptionKey");

INSERT INTO public."DatabaseVersionHistory" VALUES ('099_DW_CreateIndex2');DROP FUNCTION IF EXISTS dw."stpGetSettlementGrandTotalInfos";


CREATE OR REPLACE FUNCTION dw."stpGetSettlementGrandTotalInfos"(
	"clientIdParam" integer,
	"isoIdParam" integer,
	"startTradeDayUTC" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("IndisOperatorId" integer, "Abbreviation" character varying, "Name" character varying, "TotalAccounts" bigint, "TotalKWH" numeric, "TotalKWHReal" numeric) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$

DECLARE
          "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
          "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
BEGIN

    RETURN  QUERY
   
				SELECT
                
				ca."ControlAreaAlternateKey" as "IndisOperatorId",
				ca."Abbreviation",
				ca."Name",
              	COUNT(DISTINCT act."AccountAlternateKey") AS "TotalAccounts",   
              	sum(fct."UsageDLF") AS "TotalKWH",
			  	sum(
                CASE
                    WHEN orig."Code" in ('REAL') THEN fct."Usage"
                    ELSE 0
                END
			  	) AS "TotalKWHReal"
              	
			
	FROM dw."FactIntervals_SETT" fct 
		JOIN dw."DimAccount" act 
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli 
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimMeter" meter
          ON meter."MeterKey" = fct."MeterKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimOriginFactValue" orig
          ON orig."OriginConsumptionKey" = fct."OriginConsumptionKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
		JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"
       		
   WHERE   fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
    	AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
        AND fct."EndDateTimeUTC"   >  "startTradeDayUTC"
        AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"
        AND serv."Code" = 'SETT'
        AND status."Code" = 'CURRENT'
        AND cli."ClientAlternateKey" = "clientIdParam"
        AND fct."InsertionDateTime" <= "transactionDate"
        AND act."ApplicationCode"    = 'SETT'
        AND meter."ApplicationCode"  = 'SETT'
        AND iso."ISOAlternateKey" = "isoIdParam"
			
	GROUP BY 
		ca."ControlAreaAlternateKey",
		ca."Abbreviation",			
		ca."Name";

END

$BODY$;

ALTER FUNCTION dw."stpGetSettlementGrandTotalInfos"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('100_DW_stpGetSettlementGrandTotalInfos');DROP FUNCTION IF EXISTS etl."GetTimeData"();

CREATE OR REPLACE FUNCTION etl."GetTimeData"()
  RETURNS TABLE(key integer, time_value text, hour_12 text, hour_24 text, am_pm text, day_minutes double precision, time05min double precision, time10min integer, time15min integer, time30min integer, time60min double precision, time_value1 text)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY
	SELECT
        CAST(to_char(minute, 'hh24mi') AS INTEGER) AS key,
        to_char(minute, 'hh24mi') AS time_value,
        to_char(minute, 'hh12') hour_12,
        to_char(minute, 'hh24') AS hour_24,
        case
            when to_char(minute, 'hh24:mi') BETWEEN '00:00' AND '11:59' then 'AM'
            else 'PM'
        end AS am_pm,
        extract(minute FROM minute) day_minutes,
        case
            when extract(minute FROM minute) in(0) then 11
            else (extract(minute FROM minute) / 5) -1
        end AS time05Min,
        case
            when extract(minute FROM minute) in(5,10) then 0
            when extract(minute FROM minute) in(15,20) then 1
            when extract(minute FROM minute) in(25,30) then 2
            when extract(minute FROM minute) in(35,40) then 3
            when extract(minute FROM minute) in(45,50) then 4
            else 5
        end AS time10Min,
        case
            when extract(minute FROM minute) in(5,10,15) then 0
            when extract(minute FROM minute) in(20,25,30) then 1
            when extract(minute FROM minute) in(35,40,45) then 2
            else 3
        end AS time15Min,
        case
            when extract(minute FROM minute) in(5,10,15,20,25,30) then 0
            else 1
        end AS time30Min,
        case
            when extract(minute FROM minute) in(0) and to_char(minute, 'hh12') in ('12')  then 23
            when extract(minute FROM minute) in(0) then extract(HOUR FROM minute) - 1
            else extract(HOUR FROM minute)
        end AS time60Min,
        to_char(minute, 'hh24:mi') AS time_value
	FROM
	  (
			SELECT '0:00'::time + 5*(sequence.minute || ' minutes')::interval AS minute
			FROM generate_series(0,287) AS sequence(minute)
	  ) DQ;


END
$$;

ALTER FUNCTION etl."GetTimeData"()
    OWNER TO postgres;

DROP FUNCTION IF EXISTS etl."GetDateData"();
DROP FUNCTION IF EXISTS etl."GetDateData"(integer);

CREATE OR REPLACE FUNCTION etl."GetDateData"("_days" integer)
  RETURNS TABLE(date_dim_id integer, date_actual date, date_actual_timestamp timestamp without time zone, day_of_week double precision, day_name text, day_name1 text, day_of_month double precision, day_of_year double precision, week_of_year double precision, month_name text, month_name1 text, month_actual double precision, quarter_actual double precision, year_actual double precision, semester integer, style101 text, style103 text)
LANGUAGE plpgsql
AS $$
BEGIN

    RETURN QUERY
		SELECT TO_CHAR(datum,'yyyymmdd')::INT AS date_dim_id,
		   datum AS date_actual,
		   TO_CHAR(datum,'yyyymmdd')::TIMESTAMP AS date_actual_Timestamp,
		   EXTRACT(isodow FROM datum) AS day_of_week,
		   TO_CHAR(datum,'Day') AS day_name,
		   TO_CHAR(datum,'Day') AS day_name,
		   EXTRACT(DAY FROM datum) AS day_of_month,
		   EXTRACT(doy FROM datum) AS day_of_year,
		   EXTRACT(week FROM datum) AS week_of_year,
		   TO_CHAR(datum,'Month') AS month_name,
		   TO_CHAR(datum,'Month') AS month_name,
		   EXTRACT(MONTH FROM datum) AS month_actual,
		   EXTRACT(quarter FROM datum) AS quarter_actual,
		   EXTRACT(isoyear FROM datum) AS year_actual,
		   CASE
			 WHEN EXTRACT(MONTH FROM datum) <= 6 THEN 1
			   ELSE 2
		   END AS semester,
		   TO_CHAR(datum,'mm/dd/yyyy') AS style101,
		   TO_CHAR(datum,'dd/mm/yyyy') AS style103
	FROM (SELECT '2015-01-01'::DATE+ SEQUENCE.DAY AS datum
		  FROM GENERATE_SERIES (0,_days) AS SEQUENCE (DAY)
		  GROUP BY SEQUENCE.DAY
		  order by datum) DQ
	ORDER BY 1
;

END
$$;

ALTER FUNCTION etl."GetDateData"(integer)
    OWNER TO postgres;

DROP FUNCTION IF EXISTS etl."TruncateStagingTables"();

CREATE OR REPLACE FUNCTION etl."TruncateStagingTables"()
  RETURNS void AS
$$
DECLARE
   _tbl text;
BEGIN
   FOR _tbl IN SELECT * FROM etl."GetStagingTableListToTruncate"()
   LOOP
        EXECUTE format('TRUNCATE TABLE stg.%I CASCADE', _tbl);
   END LOOP;
END
$$ LANGUAGE plpgsql;

ALTER FUNCTION etl."TruncateStagingTables"()
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('101_DW_UpdateEtlSP');DROP FUNCTION IF EXISTS dw."stpGetOMARNewData"(integer, timestamp, timestamp, integer);

CREATE OR REPLACE FUNCTION dw."stpGetOMARNewData"("ClientId" integer, "TradeDayUTC" timestamp without time zone, "TransactionDateTimeUTC" timestamp without time zone, "IsoId" integer)
  RETURNS TABLE("CONTROLAREA" integer, "CHANNEL" text, "DATE" text, "TIME" text, "VALUE" numeric, "UOM" text, "INTERVAL" text, "STATUS" text, "DSTFLAG" text)
LANGUAGE plpgsql
AS $$
DECLARE
    "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("TradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("TradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTC"        TIMESTAMP := "TradeDayUTC" + interval '1' day;
BEGIN

   RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                chan."ChannelNumber",
                uom."UomFromMV90",
                ca."ControlAreaAlternateKey",
                dte."FullAlternateDateKey",
                dtime."24_hr"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateUTCKey"
        JOIN dw."DimTime" dtime
          ON dtime."TimeKey" = fct."EndTimeUTCKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"
        JOIN dw."DimUOM" uom
          ON uom."UomKey" = chan."UomKey"

        WHERE     fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey"
              AND fct."EndDateTimeUTC"   >=  "TradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "ClientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "IsoId"
              AND
                (
                  ("TransactionDateTimeUTC" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("TransactionDateTimeUTC" IS NOT NULL AND (fct."InsertionDateTime" <= "TransactionDateTimeUTC" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "TransactionDateTimeUTC")))
                )
		),
    omar_CTE as
    (
        SELECT
             fct."ControlAreaAlternateKey",
             '1' AS "Channel",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DD') as "_TradeDate",
             TO_CHAR("24_hr"+1, 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF"),0) AS "_UsageDLF",
             '1' AS "UOM",
             '60' AS "_INTERVAL",
             'A' as "STATUS",
             'N' AS "DSTFLAG"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM omar_CTE;
END
$$;

ALTER FUNCTION dw."stpGetOMARNewData"(integer, timestamp, timestamp, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('102_DW_UpdatestpGetOMARNewData');DROP FUNCTION IF EXISTS etl."stpMergeDailyFactIntervals_SETT"(timestamp, timestamp);

CREATE OR REPLACE FUNCTION etl."stpMergeDailyFactIntervals_SETT"("dailyStartDateUTC" timestamp without time zone, "dailyEndDateUTC" timestamp without time zone)
  RETURNS TABLE("_InsertedRowsCount" integer, "_UpdatedRowsCount" integer)
LANGUAGE plpgsql
AS $$
DECLARE
   dailyStartDateUTCKey INTEGER   := CAST (TO_CHAR("dailyStartDateUTC"::Date,'YYYYMMDD') AS INTEGER);
   dailyEndDateUTCKey   INTEGER   := CAST (TO_CHAR("dailyEndDateUTC"::Date,'YYYYMMDD') AS INTEGER);
BEGIN

  WITH dw_facts_CTE as
  (
      SELECT
                 "IntervalKey"        as "dw_IntervalKey",
                 "InsertionDateTime"  as "dw_InsertionDateTime" ,
                 "MonthlyRead"        as "dw_MonthlyRead",
                 "Usage"              as "dw_Usage",
                 "UsageDLF"           as "dw_UsageDLF",
                 "Demand"             as "dw_Demand",
                 "DemandDLF"          as "dw_DemandDLF",
                 "DLP"                as "dw_DLP",
                 "DLPSum"             as "dw_DLPSum",
                 "DLPRation"          as "dw_DLPRation",
                 "DLF"                as "dw_DLF",
                 "StartDateTimeUTC"   as "dw_StartDateTimeUTC",
                 "EndDateTimeUTC"     as "dw_EndDateTimeUTC",
                 "StartDateTimeLocal" as "dw_StartDateTimeLocal",
                 "EndDateTimeLocal"   as "dw_EndDateTimeLocal",
                 fct."AccountKey"         as "dw_AccountKey",
                 "SDPKey"             as "dw_SDPKey",
                 "MeterKey"           as "dw_MeterKey",
                 "ChannelKey"         as "dw_ChannelKey",
                 "OriginConsumptionKey" as "dw_OriginConsumptionKey",
                 "FactValueGoalKey"   as "dw_FactValueGoalKey",
                 fct."ServiceTypeKey"     as "dw_ServiceTypeKey",
                 coalesce("ParentIntervalKey", "IntervalKey")  as "dw_ParentIntervalKey",
                 fct."FactStatusKey"      as "dw_FactStatusKey",
                 "EndDateLocalKey"    as "dw_EndDateLocalKey",
                 "EndTimeLocalKey"    as "dw_EndTimeLocalKey",
                 "EndDateUTCKey"      as "dw_EndDateUTCKey",
                 "EndTimeUTCKey"      as "dw_EndTimeUTCKey",
                 "RecordedDateUTCKey" as "dw_RecordedDateUTCKey",
                  acc."ClientKey"     as "dw_ClientKey",
				  fct."IsDelivered"   as "dw_IsDelivered"

      FROM dw."FactIntervals_SETT" fct
      JOIN dw."DimServiceType" serv
        ON serv."ServiceTypeKey" = fct."ServiceTypeKey" AND serv."Code" = 'SETT'
      JOIN dw."DimAccount" acc
        ON acc."AccountKey" = fct."AccountKey"
      JOIN dw."DimFactStatus" status
        ON status."FactStatusKey" = fct."FactStatusKey" AND status."Code" = 'CURRENT'
      WHERE     fct."EndDateUTCKey"   >= dailyStartDateUTCKey
            AND fct."EndDateUTCKey"   <= dailyEndDateUTCKey
            AND fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
            AND fct."EndDateTimeUTC"  <=  "dailyEndDateUTC"
  ),
  stg_facts_CTE as
  (
      -- lookup for dimension (at this point all dimensions data should have been loaded)
      SELECT
            "MonthlyRead"           as "stg_MonthlyRead",
            "Usage"                 as "stg_Usage",
            "UsageDLF"              as "stg_UsageDLF",
            "Demand"                as "stg_Demand",
            "DemandDLF"             as "stg_DemandDLF",
            "DLP"                   as "stg_DLP",
            "DLPSum"                as "stg_DLPSum",
            "DLPRation"             as "stg_DLPRation",
            "DLF"                   as "stg_DLF",
            "StartDateTimeUTC"      as "stg_StartDateTimeUTC",
            "EndDateTimeUTC"        as "stg_EndDateTimeUTC",
            "StartDateTimeLocal"    as "stg_StartDateTimeLocal",
            "EndDateTimeLocal"      as "stg_EndDateTimeLocal",
            cl."ClientKey"          as "stg_ClientKey",
            acc."AccountKey"        as "stg_AccountKey",
            "SDPKey"                as "stg_SDPKey",
            "MeterKey"              as "stg_MeterKey",
            "ChannelKey"            as "stg_ChannelKey",
            "OriginConsumptionKey"  as "stg_OriginConsumptionKey",
            "OriginConsumptionCode" as "stg_OriginConsumptionCode",
            "ServiceTypeKey"        as "stg_ServiceTypeKey",
            dateLocal."DateKey"     as "stg_EndDateLocalKey",
            dateUTC."DateKey"       as "stg_EndDateUTCKey",
            timeLocal."TimeKey"     as "stg_EndTimeLocalKey",
            timeUTC."TimeKey"       as "stg_EndTimeUTCKey",
            recordedDate."DateKey"  as "stg_RecordedDateKey",
			fct."IsDelivered"       as "stg_IsDelivered"

      FROM stg."FactIntervals" fct
      JOIN dw."DimAccount" acc
        ON acc."AccountAlternateKey" = fct."AccountId" AND acc."ApplicationCode" = fct."ApplicationCode" AND acc."Current"  = TRUE
      JOIN dw."DimSDP" sdp
        ON sdp."SDPAlternateKey" = fct."SDPId" AND sdp."Current" = TRUE
      JOIN dw."DimMeter" meter
        ON meter."MeterAlternateKey" = fct."DeviceCode" AND meter."ApplicationCode" = fct."ApplicationCode" AND meter."Current" = TRUE
      JOIN dw."DimChannel" chan
        ON chan."ChannelAlternateKey" = fct."ChannelId" AND chan."Current" = TRUE
      JOIN dw."DimOriginFactValue" orig
        ON orig."Code" = fct."OriginConsumptionCode"
      JOIN dw."DimClient" cl
        ON cl."ClientAlternateKey" = fct."ClientId" AND cl."Current" = TRUE
      JOIN dw."DimServiceType" serv
        ON serv."Code" = fct."ApplicationCode"
      JOIN dw."DimDate" dateLocal
        ON dateLocal."FullAlternateDateTimeStamp" = fct."EndDateLocal"
      JOIN dw."DimDate" dateUTC
        ON dateUTC."FullAlternateDateTimeStamp" = fct."EndDateUTC"
      JOIN dw."DimTime" timeLocal
        ON timeLocal."TimeValue" = fct."EndTimeLocal"
      JOIN dw."DimTime" timeUTC
        ON timeUTC."TimeValue" = fct."EndTimeUTC"
      LEFT JOIN dw."DimDate" recordedDate
        ON recordedDate."FullAlternateDateTimeStamp" = fct."RecordedDateUTC"
      WHERE "EndDateTimeUTC"  > "dailyStartDateUTC" AND "EndDateTimeUTC" <= "dailyEndDateUTC" AND fct."ApplicationCode" = 'SETT'
  )
  INSERT INTO etl.facts_temp_sett (
	"dw_IntervalKey",
	"dw_InsertionDateTime" ,
	"dw_MonthlyRead",
	"dw_Usage",
	"dw_UsageDLF",
	"dw_Demand",
	"dw_DemandDLF",
	"dw_DLP",
	"dw_DLPSum",
	"dw_DLPRation",
	"dw_DLF",
	"dw_StartDateTimeUTC",
	"dw_EndDateTimeUTC",
	"dw_StartDateTimeLocal",
	"dw_EndDateTimeLocal",
	"dw_AccountKey",
	"dw_SDPKey",
	"dw_MeterKey",
	"dw_ChannelKey",
	"dw_OriginConsumptionKey",
	"dw_FactValueGoalKey",
	"dw_ServiceTypeKey",
	"dw_ParentIntervalKey",
	"dw_FactStatusKey",
	"dw_EndDateLocalKey",
	"dw_EndTimeLocalKey",
	"dw_EndDateUTCKey",
	"dw_EndTimeUTCKey",
	"dw_RecordedDateUTCKey",
	"dw_ClientKey",
	"dw_IsDelivered",

    "stg_MonthlyRead",
    "stg_Usage",
    "stg_UsageDLF",
    "stg_Demand",
    "stg_DemandDLF",
    "stg_DLP",
    "stg_DLPSum",
    "stg_DLPRation",
    "stg_DLF",
    "stg_StartDateTimeUTC",
    "stg_EndDateTimeUTC",
    "stg_StartDateTimeLocal",
    "stg_EndDateTimeLocal",
    "stg_ClientKey",
    "stg_AccountKey",
    "stg_SDPKey",
    "stg_MeterKey",
    "stg_ChannelKey",
    "stg_OriginConsumptionKey",
    "stg_OriginConsumptionCode",
    "stg_ServiceTypeKey",
    "stg_EndDateLocalKey",
    "stg_EndDateUTCKey",
    "stg_EndTimeLocalKey",
    "stg_EndTimeUTCKey",
    "stg_RecordedDateKey",
	"stg_IsDelivered"
  )
  SELECT "dw_IntervalKey",
  		 "dw_InsertionDateTime" ,
		 "dw_MonthlyRead",
		 "dw_Usage",
		 "dw_UsageDLF",
		 "dw_Demand",
		 "dw_DemandDLF",
		 "dw_DLP",
		 "dw_DLPSum",
		 "dw_DLPRation",
		 "dw_DLF",
		 "dw_StartDateTimeUTC",
		 "dw_EndDateTimeUTC",
		 "dw_StartDateTimeLocal",
		 "dw_EndDateTimeLocal",
		 "dw_AccountKey",
		 "dw_SDPKey",
		 "dw_MeterKey",
		 "dw_ChannelKey",
		 "dw_OriginConsumptionKey",
		 "dw_FactValueGoalKey",
		 "dw_ServiceTypeKey",
		 "dw_ParentIntervalKey",
		 "dw_FactStatusKey",
		 "dw_EndDateLocalKey",
		 "dw_EndTimeLocalKey",
		 "dw_EndDateUTCKey",
		 "dw_EndTimeUTCKey",
		 "dw_RecordedDateUTCKey",
		 "dw_ClientKey",
		 "dw_IsDelivered",

		"stg_MonthlyRead",
		"stg_Usage",
		"stg_UsageDLF",
		"stg_Demand",
		"stg_DemandDLF",
		"stg_DLP",
		"stg_DLPSum",
		"stg_DLPRation",
		"stg_DLF",
		"stg_StartDateTimeUTC",
		"stg_EndDateTimeUTC",
		"stg_StartDateTimeLocal",
		"stg_EndDateTimeLocal",
		"stg_ClientKey",
		"stg_AccountKey",
		"stg_SDPKey",
		"stg_MeterKey",
		"stg_ChannelKey",
		"stg_OriginConsumptionKey",
		"stg_OriginConsumptionCode",
		"stg_ServiceTypeKey",
		"stg_EndDateLocalKey",
		"stg_EndDateUTCKey",
		"stg_EndTimeLocalKey",
		"stg_EndTimeUTCKey",
		"stg_RecordedDateKey",
		"stg_IsDelivered"

  FROM dw_facts_CTE dw_fact
  FULL OUTER JOIN  stg_facts_CTE stg_fact
     ON    dw_fact."dw_ClientKey"       = stg_fact."stg_ClientKey"
        AND dw_fact."dw_AccountKey"     = stg_fact."stg_AccountKey"
        AND dw_fact."dw_SDPKey"         = stg_fact."stg_SDPKey"
        AND dw_fact."dw_MeterKey"       = stg_fact."stg_MeterKey"
        AND dw_fact."dw_ChannelKey"     = stg_fact."stg_ChannelKey"        
        AND dw_fact."dw_ServiceTypeKey" = stg_fact."stg_ServiceTypeKey"
        AND dw_fact."dw_EndDateUTCKey"  = stg_fact."stg_EndDateUTCKey"
        AND dw_fact."dw_EndTimeUTCKey"  = stg_fact."stg_EndTimeUTCKey"
		AND COALESCE (dw_fact."dw_IsDelivered",false)    = COALESCE (stg_fact."stg_IsDelivered",false)
    ;
    -- INSERT NEW FACTS
    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
           NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           1,
           "stg_ServiceTypeKey",
           NULL,
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE     fct."stg_EndDateUTCKey"  IS NOT NULL
          AND fct."dw_IntervalKey" IS NULL ;


  -- INSERT HISTORICAL FACTS AND UPDATE OLD RELATED FACTS
   UPDATE dw."FactIntervals_SETT" dw_fct
       SET "FactStatusKey" = 2,
	   "AgingDateTime" = now()::timestamp
   FROM etl.facts_temp_sett fct
   WHERE    dw_fct."EndDateUTCKey"   >= dailyStartDateUTCKey
        AND dw_fct."EndDateUTCKey"   <= dailyEndDateUTCKey
        AND dw_fct."EndDateTimeUTC"  >  "dailyStartDateUTC"
        AND dw_fct."EndDateTimeUTC"  <= "dailyEndDateUTC"
        AND dw_fct."IntervalKey" = fct."dw_IntervalKey"
        AND fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );

    INSERT INTO dw."FactIntervals_SETT"(
      "InsertionDateTime",
      "AgingDateTime",
      "MonthlyRead",
      "Usage",
      "UsageDLF",
      "Demand",
      "DemandDLF",
      "DLP",
      "DLPSum",
      "DLPRation",
      "DLF",
      "StartDateTimeUTC",
      "EndDateTimeUTC",
      "StartDateTimeLocal",
      "EndDateTimeLocal",
      "AccountKey",
      "SDPKey",
      "MeterKey",
      "ChannelKey",
      "OriginConsumptionKey",
      "FactValueGoalKey",
      "ServiceTypeKey",
      "ParentIntervalKey",
      "FactStatusKey",
      "EndDateLocalKey",
      "EndTimeLocalKey",
      "EndDateUTCKey",
      "EndTimeUTCKey",
      "RecordedDateUTCKey",
	  "IsDelivered"
    )
    SELECT
           now()::timestamp,
	   NULL,
           "stg_MonthlyRead",
           "stg_Usage",
           "stg_UsageDLF",
           "stg_Demand",
           "stg_DemandDLF",
           "stg_DLP",
           "stg_DLPSum",
           "stg_DLPRation",
           "stg_DLF",
           "stg_StartDateTimeUTC",
           "stg_EndDateTimeUTC",
           "stg_StartDateTimeLocal",
           "stg_EndDateTimeLocal",
           "stg_AccountKey",
           "stg_SDPKey",
           "stg_MeterKey",
           "stg_ChannelKey",
           "stg_OriginConsumptionKey",
           2,
           "stg_ServiceTypeKey",
           "dw_ParentIntervalKey",
           1,
           "stg_EndDateLocalKey",
           "stg_EndTimeLocalKey",
           "stg_EndDateUTCKey",
           "stg_EndTimeUTCKey",
           "stg_RecordedDateKey",
		   "stg_IsDelivered"

    FROM etl.facts_temp_sett fct
    WHERE   fct."dw_IntervalKey" IS NOT NULL
        AND fct."stg_EndDateUTCKey" IS NOT NULL
        AND (
                  COALESCE (fct."stg_MonthlyRead",-1)    != COALESCE (fct."dw_MonthlyRead",-1)
               OR COALESCE (fct."stg_Usage",-1)          != COALESCE (fct."dw_Usage",-1)
               OR COALESCE (fct."stg_UsageDLF",-1)       != COALESCE (fct."dw_UsageDLF",-1)
               OR COALESCE (fct."stg_Demand",-1)         != COALESCE (fct."dw_Demand",-1)
               OR COALESCE (fct."stg_DemandDLF",-1)      != COALESCE (fct."dw_DemandDLF",-1)
               OR COALESCE (fct."stg_DLP",-1)            != COALESCE (fct."dw_DLP",-1)
               OR COALESCE (fct."stg_DLPSum",-1)         != COALESCE (fct."dw_DLPSum",-1)
               OR COALESCE (fct."stg_DLPRation",-1)      != COALESCE (fct."dw_DLPRation",-1)
               OR COALESCE (fct."stg_DLF",-1)            != COALESCE (fct."dw_DLF",-1)
            );


  RETURN QUERY
  SELECT
	  0 AS "InsertedRowsCount",
	  0 AS "UpdatedRowsCount"
	  ;

END;
$$;

ALTER FUNCTION etl."stpMergeDailyFactIntervals_SETT"(timestamp, timestamp)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('103_DW_UpdatestpMergeDailyFactIntervals_SETT');DROP FUNCTION IF EXISTS dw."stpGetOMARNewData"(integer, timestamp, timestamp, integer);

CREATE OR REPLACE FUNCTION dw."stpGetOMARNewData"("ClientId" integer, "TradeDayUTC" timestamp without time zone, "TransactionDateTimeUTC" timestamp without time zone, "IsoId" integer)
  RETURNS TABLE("CONTROLAREA" integer, "CHANNEL" text, "DATE" text, "TIME" text, "VALUE" numeric, "UOM" text, "INTERVAL" text, "STATUS" text, "DSTFLAG" text)
LANGUAGE plpgsql
AS $$
DECLARE
    "startTradeDayUTCKey"   INTEGER   := CAST (TO_CHAR("TradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
    "endTradeDayUTCKey"     INTEGER   := CAST (TO_CHAR(("TradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);
    "startTradeDayUTC"      TIMESTAMP := "TradeDayUTC" + interval '1' hour;
    "endTradeDayUTC"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
    "startTradeDayUTCKey2"   INTEGER   := "endTradeDayUTCKey";
    "endTradeDayUTCKey2"     INTEGER   := CAST (TO_CHAR(("TradeDayUTC" + interval '2' day)::Date,'YYYYMMDD') AS INTEGER);
BEGIN

   RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                chan."ChannelNumber",
                uom."UomFromMV90",
                ca."ControlAreaAlternateKey",
                dte."FullAlternateDateKey",
                dtime."24_hr"
        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = "startTradeDayUTCKey"
        JOIN dw."DimTime" dtime
          ON dtime."TimeKey" = fct."EndTimeUTCKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"
        JOIN dw."DimUOM" uom
          ON uom."UomKey" = chan."UomKey"

        WHERE     ((fct."EndDateUTCKey"    >= "startTradeDayUTCKey"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey") OR
              (fct."EndDateUTCKey"    >= "startTradeDayUTCKey2"
              AND fct."EndDateUTCKey"    <= "endTradeDayUTCKey2"))
              AND fct."EndDateTimeUTC"   >=  "startTradeDayUTC"
              AND fct."EndDateTimeUTC"   <  "endTradeDayUTC"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "ClientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "IsoId"
              AND
                (
                  ("TransactionDateTimeUTC" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("TransactionDateTimeUTC" IS NOT NULL AND (fct."InsertionDateTime" <= "TransactionDateTimeUTC" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "TransactionDateTimeUTC")))
                )
		),
    omar_CTE as
    (
        SELECT
             fct."ControlAreaAlternateKey",
             '1' AS "Channel",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             case
                when (TO_CHAR("24_hr", 'fm00') || ':00:00') = '00:00:00' then '24:00:00'
                else (TO_CHAR("24_hr", 'fm00') || ':00:00')
             end as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF"),0) AS "_UsageDLF",
             '1' AS "UOM",
             '60' AS "_INTERVAL",
             'A' as "STATUS",
             'N' AS "DSTFLAG"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM omar_CTE;
END
$$;

ALTER FUNCTION dw."stpGetOMARNewData"(integer, timestamp, timestamp, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('104_DW_OMARNewData_Fix');-- FUNCTION: dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
DROP FUNCTION IF EXISTS dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptDailyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"startTradeDayUTC" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Tradeday" date, "TransactionDate" timestamp without time zone, "Account" character varying, "MeterID" character varying, "ControlArea" character varying, "RawDailyUsage" numeric, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
   
"startTradeDayUTCKey"	INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"		INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);

 "endTradeDayUTC" 		TIMESTAMP := "startTradeDayUTC" + interval '1' day;
 "startDateTimeLocal" 	TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN

    RETURN  QUERY
	
SELECT tmp."Tradeday"
	  ,tmp."TransactionDate" 
	  ,tmp."Account"
	  ,tmp."MeterID"
	  ,tmp."ControlArea"
	  ,SUM(tmp."RawDailyUsage")
	  ,tmp."IntervalReadings"
	  
	  
FROM (
	SELECT "startTradeDayUTC"::Date AS "Tradeday"
		  ,"transactionDate" AS "TransactionDate" 
		  ,act."AccountNumber" AS "Account"
		  ,mt."DeviceCode" AS "MeterID"
		  ,ca."Abbreviation" AS "ControlArea"
		  ,fct."Usage" AS "RawDailyUsage"
		  ,ofv."OriginValueEnglishDescription" AS "IntervalReadings"

	FROM dw."FactIntervals_SETT" fct 
			JOIN dw."DimAccount" act
			  ON act."AccountKey" = fct."AccountKey"
			JOIN dw."DimClient" cli
			  ON cli."ClientKey" = act."ClientKey"																											
			JOIN dw."DimServiceType" serv																			
			  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
			JOIN dw."DimFactStatus" status
			  ON status."FactStatusKey" = fct."FactStatusKey"        
			JOIN dw."DimOriginFactValue" ofv
			  ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"      
			JOIN dw."DimControlArea" ca																						
			  ON ca."ControlAreaKey" = act."ControlAreaKey"
			JOIN dw."DimISO" iso
			  ON iso."ISOKey" = ca."ISOKey"
			JOIN dw."DimMeter" mt
			  ON mt."MeterKey" = fct."MeterKey"  
			
			WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
				  AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
	
				  AND serv."Code" = 'SETT'
				  AND cli."ClientAlternateKey" = "clientId"
				  AND act."ApplicationCode"    = 'SETT'
				  AND iso."ISOAlternateKey" = "ISO_Id"
				  AND
					(
					  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
					  OR
					  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
					)
	)tmp
	GROUP BY tmp."Tradeday"
	 	 ,tmp."TransactionDate" 
	 	 ,tmp."Account"
	 	 ,tmp."MeterID"
   	 	 ,tmp."ControlArea"
	 	 ,tmp."IntervalReadings"
	ORDER BY tmp."IntervalReadings"
		 ,tmp."ControlArea"
		 ,tmp."Account"
		 ,tmp."MeterID";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('105_DW_procRptDailyTotals_LocalDate');DROP FUNCTION IF EXISTS dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptDailyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"startTradeDayUTC" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Tradeday" date, "TransactionDate" timestamp without time zone, "Account" character varying, "MeterID" character varying, "ControlArea" character varying, "RawDailyUsage" numeric, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
   
"startTradeDayUTCKey"	INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"		INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);

 "endTradeDayUTC" 		TIMESTAMP := "startTradeDayUTC" + interval '1' day;
 "startDateTimeLocal" 	TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN

    RETURN  QUERY
	
SELECT tmp."Tradeday"
	  ,tmp."TransactionDate" 
	  ,tmp."Account"
	  ,tmp."MeterID"
	  ,tmp."ControlArea"
	  ,SUM(tmp."RawDailyUsage")
	  ,tmp."IntervalReadings"
	  
	  
FROM (
	SELECT "startTradeDayUTC"::Date AS "Tradeday"
		  ,"transactionDate" AS "TransactionDate" 
		  ,act."AccountNumber" AS "Account"
		  ,mt."DeviceCode" AS "MeterID"
		  ,ca."Abbreviation" AS "ControlArea"
		  ,fct."Usage" AS "RawDailyUsage"
		  ,CASE WHEN ofv."OriginValueEnglishDescription" = 'Calculated' THEN 'Monthly' ELSE ofv."OriginValueEnglishDescription" END AS "IntervalReadings"

	FROM dw."FactIntervals_SETT" fct 
			JOIN dw."DimAccount" act
			  ON act."AccountKey" = fct."AccountKey"
			JOIN dw."DimClient" cli
			  ON cli."ClientKey" = act."ClientKey"																											
			JOIN dw."DimServiceType" serv																			
			  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
			JOIN dw."DimFactStatus" status
			  ON status."FactStatusKey" = fct."FactStatusKey"        
			JOIN dw."DimOriginFactValue" ofv
			  ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"      
			JOIN dw."DimControlArea" ca																						
			  ON ca."ControlAreaKey" = act."ControlAreaKey"
			JOIN dw."DimISO" iso
			  ON iso."ISOKey" = ca."ISOKey"
			JOIN dw."DimMeter" mt
			  ON mt."MeterKey" = fct."MeterKey"  
			
			WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
				  AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
	
				  AND serv."Code" = 'SETT'
				  AND cli."ClientAlternateKey" = "clientId"
				  AND act."ApplicationCode"    = 'SETT'
				  AND iso."ISOAlternateKey" = "ISO_Id"
				  AND
					(
					  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
					  OR
					  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
					)
	)tmp
	GROUP BY tmp."Tradeday"
	 	 ,tmp."TransactionDate" 
	 	 ,tmp."Account"
	 	 ,tmp."MeterID"
   	 	 ,tmp."ControlArea"
	 	 ,tmp."IntervalReadings"
	ORDER BY tmp."IntervalReadings"
		 ,tmp."ControlArea"
		 ,tmp."Account"
		 ,tmp."MeterID";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('106_DW_procRptDailyTotals_order');DROP FUNCTION IF EXISTS dw."stpGetMisoData"(INTEGER, INTEGER, TIMESTAMP, TIMESTAMP);

CREATE OR REPLACE FUNCTION dw."stpGetMisoData"("clientIdParam" integer, "isoIdParam" integer, "startTradeDayUTC" timestamp without time zone, "transactionDate" timestamp without time zone)
  RETURNS TABLE("MSId" text, "TradeDate" text, "TradeTime" text, "UsageDLF" numeric, "Stat" text)
LANGUAGE plpgsql
AS $$
DECLARE
          "endTradeDay"        TIMESTAMP := "startTradeDayUTC" + interval '1' day;
          "startDateTime"         TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN
    RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                ca."ControlAreaAlternateKey",

                CASE WHEN ((((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1) AND (dte."FullAlternateDateKey" > "startTradeDayUTC")) THEN (dte."FullAlternateDateKey" + interval '-1' day)
                  ELSE dte."FullAlternateDateKey" END AS "FullAlternateDateKey",


                CASE WHEN TO_CHAR(fct."EndDateTimeLocal", 'MI') = '00' THEN
                                CASE WHEN ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1
                                          THEN 23
                                          ELSE ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1)
                                END
                                ELSE (TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer)
                END  "24_hr",
                chan."ChannelAlternateKey"

        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"

        WHERE fct."EndDateTimeLocal"   >=  "startDateTime"
              AND fct."EndDateTimeLocal"   <=  "endTradeDay"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "clientIdParam"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "isoIdParam"
              AND
                (
                  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
                )
		),
    miso_CTE as
    (
        SELECT
             'CONS.SELC' as "_MSId",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             TO_CHAR("24_hr", 'fm00') || ':00:00' as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF" /1000),0) AS "_UsageDLF",
             ' ' as "_Stat"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM miso_CTE
    ORDER BY "_TradeDate", "_TradeTime";
END;
$$;

ALTER FUNCTION dw."stpGetMisoData"(INTEGER, INTEGER, TIMESTAMP, TIMESTAMP)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('107_DW_stpGetMisoData');DROP FUNCTION IF EXISTS dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone);

CREATE OR REPLACE FUNCTION dw."procRptDailyTotals"(
	"clientId" integer,
	"ISO_Id" integer,
	"startTradeDayUTC" timestamp without time zone,
	"transactionDate" timestamp without time zone)
    RETURNS TABLE("Tradeday" date, "TransactionDate" timestamp without time zone, "Account" character varying, "MeterID" character varying, "ControlArea" character varying, "RawDailyUsage" numeric, "IntervalReadings" character varying) 
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    ROWS 1000
AS $BODY$
DECLARE
   
"startTradeDayUTCKey"	INTEGER   := CAST (TO_CHAR("startTradeDayUTC"::Date,'YYYYMMDD') AS INTEGER);
"endTradeDayUTCKey"		INTEGER   := CAST (TO_CHAR(("startTradeDayUTC" + interval '1' day)::Date,'YYYYMMDD') AS INTEGER);

 "endTradeDayUTC" 		TIMESTAMP := "startTradeDayUTC" + interval '1' day;
 "startDateTimeLocal" 	TIMESTAMP := "startTradeDayUTC" + interval '15' MINUTE;

BEGIN

    RETURN  QUERY
	
SELECT tmp."Tradeday"
	  ,tmp."TransactionDate" 
	  ,tmp."Account"
	  ,tmp."MeterID"
	  ,tmp."ControlArea"
	  ,SUM(tmp."RawDailyUsage")
	  ,tmp."IntervalReadings"
	  
	  
FROM (
	SELECT "startTradeDayUTC"::Date AS "Tradeday"
		  ,"transactionDate" AS "TransactionDate" 
		  ,act."AccountNumber" AS "Account"
		  ,mt."DeviceCode" AS "MeterID"
		  ,ca."Abbreviation" AS "ControlArea"
		  ,fct."Usage" AS "RawDailyUsage"
		  ,CASE WHEN ofv."OriginValueEnglishDescription" = 'Calculated' THEN 'Monthly' WHEN ofv."OriginValueEnglishDescription" = 'Real' THEN 'Interval' ELSE ofv."OriginValueEnglishDescription" END AS "IntervalReadings"

	FROM dw."FactIntervals_SETT" fct 
			JOIN dw."DimAccount" act
			  ON act."AccountKey" = fct."AccountKey"
			JOIN dw."DimClient" cli
			  ON cli."ClientKey" = act."ClientKey"																											
			JOIN dw."DimServiceType" serv																			
			  ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
			JOIN dw."DimFactStatus" status
			  ON status."FactStatusKey" = fct."FactStatusKey"        
			JOIN dw."DimOriginFactValue" ofv
			  ON ofv."OriginConsumptionKey" = fct."OriginConsumptionKey"      
			JOIN dw."DimControlArea" ca																						
			  ON ca."ControlAreaKey" = act."ControlAreaKey"
			JOIN dw."DimISO" iso
			  ON iso."ISOKey" = ca."ISOKey"
			JOIN dw."DimMeter" mt
			  ON mt."MeterKey" = fct."MeterKey"  
			
			WHERE fct."EndDateTimeUTC"   >=  "startDateTimeLocal"
				  AND fct."EndDateTimeUTC"   <=  "endTradeDayUTC"	
	
				  AND serv."Code" = 'SETT'
				  AND cli."ClientAlternateKey" = "clientId"
				  AND act."ApplicationCode"    = 'SETT'
				  AND iso."ISOAlternateKey" = "ISO_Id"
				  AND
					(
					  ("transactionDate" IS NULL AND status."Code" = 'CURRENT')
					  OR
					  ("transactionDate" IS NOT NULL AND (fct."InsertionDateTime" <= "transactionDate" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "transactionDate")))
					)
	)tmp
	GROUP BY tmp."Tradeday"
	 	 ,tmp."TransactionDate" 
	 	 ,tmp."Account"
	 	 ,tmp."MeterID"
   	 	 ,tmp."ControlArea"
	 	 ,tmp."IntervalReadings"
	ORDER BY tmp."IntervalReadings"
		 ,tmp."ControlArea"
		 ,tmp."Account"
		 ,tmp."MeterID";

END;
$BODY$;

ALTER FUNCTION dw."procRptDailyTotals"(integer, integer, timestamp without time zone, timestamp without time zone)
    OWNER TO postgres;

			
INSERT INTO public."DatabaseVersionHistory" VALUES ('108_DW_procRptDailyTotals_order');DROP FUNCTION IF EXISTS dw."stpGetOMARNewData"(integer, timestamp, timestamp, integer);

CREATE OR REPLACE FUNCTION dw."stpGetOMARNewData"("ClientId" integer, "TradeDayUTC" timestamp without time zone, "TransactionDateTimeUTC" timestamp without time zone, "IsoId" integer)
  RETURNS TABLE("CONTROLAREA" integer, "CHANNEL" text, "DATE" text, "TIME" text, "VALUE" numeric, "UOM" text, "INTERVAL" text, "STATUS" text, "DSTFLAG" text)
LANGUAGE plpgsql
AS $$
DECLARE
    "endTradeDay" TIMESTAMP := "TradeDayUTC" + interval '1' day;
    "startDateTime" TIMESTAMP := "TradeDayUTC" + interval '15' MINUTE;
BEGIN

   RETURN  QUERY
    with intervalsData_CTE  as
		(
				SELECT
                fct.*,
                chan."ChannelNumber",
                uom."UomFromMV90",
                ca."ControlAreaAlternateKey",
                CASE WHEN ((((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1) AND (dte."FullAlternateDateKey" > "TradeDayUTC")) THEN (dte."FullAlternateDateKey" + interval '-1' day)
                  ELSE dte."FullAlternateDateKey" END AS "FullAlternateDateKey",
                CASE WHEN TO_CHAR(fct."EndDateTimeLocal", 'MI') = '00' THEN
                                CASE WHEN ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1) = -1
                                          THEN 23
                                          ELSE ((TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer) -1)
                                END
                                ELSE (TO_CHAR(fct."EndDateTimeLocal", 'HH24')::integer)
                END  "24_hr"
        FROM dw."FactIntervals_SETT" fct
        JOIN dw."DimAccount" act
          ON act."AccountKey" = fct."AccountKey"
        JOIN dw."DimClient" cli
          ON cli."ClientKey" = act."ClientKey"
        JOIN dw."DimChannel" chan
          ON chan."ChannelKey" = fct."ChannelKey"
        JOIN dw."DimDate" dte
          ON dte."DateKey" = fct."EndDateLocalKey"
        JOIN dw."DimServiceType" serv
          ON serv."ServiceTypeKey" = fct."ServiceTypeKey"
        JOIN dw."DimFactStatus" status
          ON status."FactStatusKey" = fct."FactStatusKey"
        JOIN dw."DimControlArea" ca
          ON ca."ControlAreaKey" = act."ControlAreaKey"
        JOIN dw."DimISO" iso
          ON iso."ISOKey" = ca."ISOKey"
        JOIN dw."DimUOM" uom
          ON uom."UomKey" = chan."UomKey"

        WHERE fct."EndDateTimeLocal" >= "startDateTime"
              AND fct."EndDateTimeLocal" < "endTradeDay"
              AND serv."Code" = 'SETT'
              AND cli."ClientAlternateKey" = "ClientId"
              AND act."ApplicationCode"    = 'SETT'
              AND iso."ISOAlternateKey" = "IsoId"
              AND
                (
                  ("TransactionDateTimeUTC" IS NULL AND status."Code" = 'CURRENT')
                  OR
                  ("TransactionDateTimeUTC" IS NOT NULL AND (fct."InsertionDateTime" <= "TransactionDateTimeUTC" AND (status."Code" = 'CURRENT' OR fct."AgingDateTime" >= "TransactionDateTimeUTC")))
                )
		),
    omar_CTE as
    (
        SELECT
             fct."ControlAreaAlternateKey",
             '1' AS "Channel",
             TO_CHAR("FullAlternateDateKey",'YYYY-MM-DDT') as "_TradeDate",
             case
                when (TO_CHAR("24_hr", 'fm00') || ':00:00') = '00:00:00' then '24:00:00'
                else (TO_CHAR("24_hr", 'fm00') || ':00:00')
             end as "_TradeTime",
             COALESCE(SUM(fct."UsageDLF"),0) AS "_UsageDLF",
             '1' AS "UOM",
             '60' AS "_INTERVAL",
             'A' as "STATUS",
             'N' AS "DSTFLAG"
        FROM intervalsData_CTE fct
        GROUP BY "FullAlternateDateKey",
                 "24_hr",
                 "ControlAreaAlternateKey"
    )
    SELECT  *
    FROM omar_CTE;
END
$$;

ALTER FUNCTION dw."stpGetOMARNewData"(integer, timestamp, timestamp, integer)
    OWNER TO postgres;

INSERT INTO public."DatabaseVersionHistory" VALUES ('109_DW_OMARNewData');CREATE TABLE public."DatabaseVersionHistory" 
(
	"DatabaseVersionId" VARCHAR(150) PRIMARY KEY,
	"InsertionDateTime" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO public."DatabaseVersion